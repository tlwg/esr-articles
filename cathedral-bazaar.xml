<?xml version="1.0" encoding="TIS-620"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" 
>

<article>
<!-- The Cathedral and the Bazaar -->
<title>มหาวิหารกับตลาดสด</title>
<articleinfo>

<!-- %%BEGIN STANDALONE%% -->
<author>
  <firstname>Eric</firstname>
  <othername>Steven</othername>
  <surname>Raymond</surname>
  <affiliation>
    <orgname><ulink url="http://www.tuxedo.org/~esr/">
    Thyrsus Enterprises</ulink></orgname> 
    <address>
    <email>esr@thyrsus.com</email>
    </address>
  </affiliation>
</author>
<pubdate role="cvs">$Date: 2006-12-01 13:40:42 $</pubdate>
<releaseinfo>This is version 3.0</releaseinfo>
<copyright>
  <year>2000</year>
  <holder role="mailto:esr@thyrsus.com">Eric S. Raymond</holder> 
</copyright>
<copyright>
  <year>2002</year>
  <holder role="markpeak@gmail.com">
    Isriya Paireepairit (Initial Thai translation)
  </holder> 
</copyright>
<copyright>
  <year>2002</year>
  <holder role="arthit@gmail.com">
    Arthit Suriyawongkul (Initial Thai translation)
  </holder> 
</copyright>
<copyright>
  <year>2006</year>
  <holder role="mailto:thep@linux.thai.net">
    Theppitak Karoonboonyanan (Thai translation)
  </holder> 
</copyright>
<copyright>
  <year>2006</year>
  <holder role="mailto:viseua@inet.co.th">
    Visanu Euarchukiati (Thai translation)
  </holder> 
</copyright>
<legalnotice>
  <title>Copyright</title>
  <para>Permission is granted to copy, distribute and/or modify
  this document under the terms of the Open Publication License,
  version 2.0.</para>
</legalnotice>

<revhistory>
   <revision>
      <revnumber>1.57.thai1</revnumber>
      <date>19 พฤศจิกายน 2006</date>
      <authorinitials>tkr</authorinitials>
       <revremark>
         Merge and edit Isriya's Thai translation of section 1 and 2.
       </revremark>
   </revision>
   <revision>
      <revnumber>1.57</revnumber>
      <date>11 September 2000</date>
      <authorinitials>esr</authorinitials>
       <revremark>
         New major section ``How Many Eyeballs Tame Complexity''.
       </revremark>
   </revision>
   <revision>
      <revnumber>1.52</revnumber>
      <date>28 August 2000</date>
      <authorinitials>esr</authorinitials>
       <revremark>
          MATLAB is a reinforcing parallel to Emacs.  Corbato&oacute;
          &amp; Vyssotsky got it in 1965.
       </revremark>
   </revision>

   <revision>
      <revnumber>1.51</revnumber>
      <date>24 August 2000</date>
      <authorinitials>esr</authorinitials>
       <revremark>
	 First DocBook version. Minor updates to Fall 2000 on the 
	 time-sensitive material. 
       </revremark>
   </revision>

   <revision>
      <revnumber>1.49</revnumber>
      <date>5 May 2000</date>
      <authorinitials>esr</authorinitials>
       <revremark>
         Added the HBS note on deadlines and scheduling.
       </revremark>
   </revision>

   <revision>
      <revnumber>1.51</revnumber>
      <date>31 August 1999</date>
      <authorinitials>esr</authorinitials>
       <revremark>
         This the version that O'Reilly printed in the first edition
         of the book.
       </revremark>
   </revision>

   <revision>
      <revnumber>1.45</revnumber>
      <date>8 August 1999</date>
      <authorinitials>esr</authorinitials>
       <revremark>
	Added the endnotes on the Snafu Principle, (pre)historical examples
	of bazaar development, and originality in the bazaar.
        </revremark>
   </revision>

   <revision>
      <revnumber>1.44</revnumber>
      <date>29 July 1999</date>
      <authorinitials>esr</authorinitials>
       <revremark>
         Added the ``On Management and the Maginot Line'' section, some
         insights about the usefulness of bazaars for exploring design space,
         and substantially improved the Epilog.
       </revremark>
   </revision>

   <revision>
      <revnumber>1.40</revnumber>
      <date>20 Nov 1998</date>
      <authorinitials>esr</authorinitials>
       <revremark>
	 Added a correction of Brooks based on the Halloween Documents.
       </revremark>
   </revision>

   <revision>
      <revnumber>1.39</revnumber>
      <date>28 July 1998</date>
      <authorinitials>esr</authorinitials>
       <revremark>
	  I removed Paul Eggert's 'graph on GPL vs. bazaar in response
	  to cogent aguments from RMS on
       </revremark>
   </revision>

   <revision>
      <revnumber>1.31</revnumber>
      <date>February 10 1998 </date>
      <authorinitials>esr</authorinitials>
       <revremark>
         Added ``Epilog: Netscape Embraces the Bazaar!''
       </revremark>
   </revision>

   <revision>
      <revnumber>1.29</revnumber>
      <date>February 9 1998</date>
      <authorinitials>esr</authorinitials>
       <revremark>
         Changed ``free software'' to ``open source''.
       </revremark>
   </revision>

   <revision>
      <revnumber>1.27</revnumber>
      <date>18 November 1997</date>
      <authorinitials>esr</authorinitials>
       <revremark>
         Added the Perl Conference anecdote.
       </revremark>
   </revision>

   <revision>
      <revnumber>1.20</revnumber>
      <date>7 July 1997</date>
      <authorinitials>esr</authorinitials>
       <revremark>
         Added the bibliography.
       </revremark>
   </revision>

   <revision>
      <revnumber>1.16</revnumber>
      <date>21 May 1997</date>
      <authorinitials>esr</authorinitials>
       <revremark>
          First official presentation at the Linux Kongress.
       </revremark>
   </revision>
</revhistory>
<!-- %%END STANDALONE%% -->

<abstract>
<para>I anatomize a successful open-source project, fetchmail, that was
run as a deliberate test of the surprising theories about software
engineering suggested by the history of Linux.  I discuss these
theories in terms of two fundamentally different development styles,
the ``cathedral'' model of most of the commercial world versus the ``bazaar''
model of the Linux world.  I show that these models derive from
opposing assumptions about the nature of the software-debugging task.
I then make a sustained argument from the Linux experience for the
proposition that ``Given enough eyeballs, all bugs are shallow'',
suggest productive analogies with other self-correcting systems of
selfish agents, and conclude with some exploration of the implications
of this insight for the future of software.</para>

<para>ผมวิเคราะห์แยกแยะโครงการโอเพนซอร์สที่ประสบความสำเร็จโครงการหนึ่ง คือ 
fetchmail 
ซึ่งดำเนินการโดยเป็นการวางแผนทดสอบทฤษฎีที่น่าประหลาดใจเกี่ยวกับวิศวกรรมซอฟต์แวร์ 
ที่ชี้แนะโดยประวัติศาสตร์ของลินุกซ์ 
ผมอภิปรายทฤษฎีเหล่านี้ในรูปของรูปแบบการพัฒนาสองแบบที่แตกต่างกันโดยสิ้นเชิง 
คือรูปแบบ ``มหาวิหาร'' ที่ใช้กันในโลกพาณิชย์เกือบทั้งหมด กับรูปแบบ ``ตลาดสด'' 
ของโลกลินุกซ์ ผมแสดงให้เห็นว่า รูปแบบเหล่านี้เกิดจากข้อสมมุติที่ตรงข้ามกัน 
เกี่ยวกับธรรมชาติของงานแก้บั๊กซอฟต์แวร์ จากนั้น 
ผมได้สร้างข้อโต้แย้งที่มั่นคงจากประสบการณ์ของลินุกซ์ สำหรับข้อเสนอที่ว่า 
``มีลูกตามากพอ บั๊กทุกตัวจะง่ายลงเอง'' 
แล้วก็เสนอแนะการเปรียบเปรยกับระบบของตัวกระทำที่เห็นแก่ตัวซึ่งมีการแก้ไขตัวเอง 
และสรุปด้วยการสำรวจนัยของแนวคิดนี้สำหรับอนาคตของซอฟต์แวร์</para>
</abstract>
</articleinfo>

<!-- The Cathedral and the Bazaar -->
<sect1 id="catbmain"><title>มหาวิหารกับตลาดสด</title>

<para>Linux is subversive.  Who would have thought even five years ago
(1991) that a world-class operating system could coalesce as if by
magic out of part-time hacking by several thousand developers
scattered all over the planet, connected only by the tenuous strands
of the Internet?</para>

<para>ลินุกซ์คือผู้ล้มยักษ์ เมื่อ 5 ปีที่แล้ว (ปี 1991) 
ใครจะไปคิดว่าระบบปฏิบัติการระดับโลก จะก่อตัวขึ้นราวกับมีเวทมนตร์จากการแฮ็กเล่นๆ 
ในเวลาว่างของนักพัฒนานับพันจากทั่วโลกที่เชื่อมต่อกันด้วยเส้นใยบางๆ 
อย่างอินเทอร์เน็ตเท่านั้น</para>

<para>Certainly not I. By the time Linux swam onto my radar screen in early
1993, I had already been involved in Unix and open-source development
for ten years.  I was one of the first GNU contributors in the
mid-1980s.  I had released a good deal of open-source software onto
the net, developing or co-developing several programs (nethack, Emacs's
VC and GUD modes, xlife, and others) that are still in wide use today.
I thought I knew how it was done.</para>

<para>ผมคนหนึ่งล่ะ ที่ไม่เชื่อ ตอนที่ลินุกซ์เข้ามาอยู่ในความสนใจของผมเมื่อต้นปี 
1993 นั้น ผมได้เข้ามาเกี่ยวข้องกับยูนิกซ์ และการพัฒนาแบบโอเพนซอร์สมาสิบปีแล้ว 
ผมยังเป็นหนึ่งในผู้สมทบงานให้ GNU เป็นคนแรกๆ ในช่วงกลางทศวรรษ 1980 
ผมได้ปล่อยซอฟต์แวร์โอเพนซอร์สออกสู่อินเทอร์เน็ตแล้วหลายตัว 
โดยได้สร้างและร่วมสร้างโปรแกรมหลายโปรแกรม (nethack, โหมด VC และ GUD ของ Emacs, 
xlife และอื่นๆ) ซึ่งยังคงใช้กันอยู่แพร่หลายในทุกวันนี้ 
ผมคิดว่าตัวเองรู้ดีเรื่องการพัฒนาซอฟต์แวร์</para>

<para>Linux overturned much of what I thought I knew.  I had been preaching
the Unix gospel of small tools, rapid prototyping and evolutionary
programming for years.  But I also believed there was a certain
critical complexity above which a more centralized, a priori approach
was required.  I believed that the most important software (operating
systems and really large tools like the Emacs programming editor)
needed to be built like cathedrals, carefully crafted by individual
wizards or small bands of mages working in splendid isolation, with no
beta to be released before its time.</para>

<para>แต่ลินุกซ์ได้ลบล้างสิ่งที่ผมเคยคิดว่ารู้ไปมาก 
ผมเคยพร่ำสอนเกี่ยวกับบัญญัติยูนิกซ์ เรื่องการเขียนโปรแกรมขนาดเล็ก 
การสร้างต้นแบบอย่างเร็ว และการเขียนโปรแกรมแบบวิวัฒนาการมาหลายปี 
แต่ผมยังเชื่ออีกด้วย ว่ามีความซับซ้อนวิกฤติระดับหนึ่ง ที่ถ้าเลยขั้นนี้ไป 
ก็ต้องใช้วิธีพัฒนาที่รวมศูนย์ มีทฤษฎีมากกว่านั้น ผมเชื่อว่าซอฟต์แวร์ที่สำคัญๆ 
(เช่น ระบบปฏิบัติการ และโปรแกรมขนาดใหญ่อย่าง Emacs) 
ควรจะถูกสร้างเหมือนสร้างมหาวิหาร (cathedral) 
โดยพ่อมดซอฟต์แวร์สักคน หรือผู้วิเศษกลุ่มเล็กๆ เป็นผู้ประดิษฐ์ขึ้นอย่างบรรจง 
ในดินแดนโดดเดี่ยวอันศักดิ์สิทธิ์ ไม่มีตัวทดสอบ (beta) 
ออกมาให้ลองก่อนเวอร์ชันจริง</para>

<para>Linus Torvalds's style of development&mdash;release early and
often, delegate everything you can, be open to the point of
promiscuity&mdash;came as a surprise.  No quiet, reverent
cathedral-building here&mdash;rather, the Linux community seemed to
resemble a great babbling bazaar of differing agendas and approaches
(aptly symbolized by the Linux archive sites, who'd take submissions
from <emphasis>anyone</emphasis>) out of which a coherent and stable
system could seemingly emerge only by a succession of miracles.</para>

<para>วิธีการพัฒนาของไลนัส ทอร์วัลด์ เป็นเรื่องแปลกประหลาด วิธีของเขาคือ 
`ออกเนิ่นๆ ออกถี่ๆ มอบงานทุกส่วนให้คนอื่นเท่าที่จะทำได้ 
และเปิดกว้างถึงขั้นสำส่อน' 
นี่ไม่ใช่การสร้างมหาวิหารอย่างเงียบเชียบด้วยความเทิดทูนบูชา ชุมชนของลินุกซ์นั้น 
เหมือนกับตลาดสด (bazaar) ที่เอะอะอื้ออึงฟังไม่ได้ศัพท์ 
ซึ่งแต่ละคนมีวาระและวิธีการที่แตกต่างหลากหลาย (เห็นได้จากไซต์ FTP 
ของลินุกซ์ ที่ใครก็สามารถส่งผลงานของตัวเองเข้ามาได้) 
การจะเกิดระบบปฏิบัติการที่เสถียรและเป็นเอกภาพขึ้นได้จากสภาพดังกล่าว 
จึงดูเหมือนต้องเป็นผลจากปาฏิหาริย์เท่านั้น</para>

<para>The fact that this bazaar style seemed to work, and work well,
came as a distinct shock.  As I learned my way around, I worked hard
not just at individual projects, but also at trying to understand why
the Linux world not only didn't fly apart in confusion but seemed to
go from strength to strength at a speed barely imaginable to
cathedral-builders.</para>

<para>ความจริงที่ว่าการพัฒนาแบบตลาดสดนี้ใช้งานได้ และได้ผลดีด้วยนั้น 
เป็นเรื่องน่าตกใจมาก ขณะที่ผมเรียนรู้ไปเรื่อยๆ นั้น 
ผมไม่เพียงทุ่มเทให้กับโครงการทั้งหลาย แต่ผมยังพยายามหาสาเหตุ 
ว่าทำไมโลกของลินุกซ์จึงไม่เพียงไม่แตกเป็นเสี่ยงๆ ด้วยความโกลาหล 
แต่ยังกลับแข็งแกร่งและมั่นคงขึ้นเรื่อยๆ 
ด้วยอัตราเร็วที่นักสร้างมหาวิหารแทบไม่สามารถจินตนาการถึงได้</para>

<para>By mid-1996 I thought I was beginning to understand.  Chance
handed me a perfect way to test my theory, in the form of an
open-source project that I could consciously try to run in the bazaar
style.  So I did&mdash;and it was a significant success.</para>

<para>กลางปี 1996 ผมคิดว่าผมเริ่มเข้าใจแล้ว 
ผมมีโอกาสอันยอดเยี่ยมที่จะทดสอบทฤษฎีของตัวเอง 
ในรูปแบบของโครงการโอเพนซอร์ส ซึ่งผมสามารถเจาะจงให้พัฒนาในแบบตลาดสดได้ 
ผมจึงลองทำดู และมันก็ประสบความสำเร็จดีทีเดียว</para>

<para>This is the story of that project.  I'll use it to propose some
aphorisms about effective open-source development.  Not all of these
are things I first learned in the Linux world, but we'll see how the
Linux world gives them particular point.  If I'm correct, they'll help
you understand exactly what it is that makes the Linux community such
a fountain of good software&mdash;and, perhaps, they will help you become
more productive yourself.</para>

<para>เรื่องราวต่อไปนี้เป็นเรื่องของโครงการดังกล่าว 
ผมจะใช้ตัวอย่างนี้เสนอคติสำหรับการพัฒนาแบบโอเพนซอร์สที่ได้ผล 
หลายอย่างไม่ใช่สิ่งที่ผมเพิ่งเรียนรู้เป็นครั้งแรกจากโลกของลินุกซ์ 
แต่เราจะเห็นว่าโลกของลินุกซ์ทำให้มันสำคัญขึ้นมาอย่างไร ถ้าผมคิดไม่ผิด 
คติเหล่านี้จะช่วยให้คุณเข้าใจมากขึ้น 
ว่าอะไรคือสิ่งที่ทำให้สังคมลินุกซ์กลายเป็นบ่อเกิดของซอฟต์แวร์ดีๆ 
และอาจช่วยทำให้คุณพัฒนาผลิตภาพของคุณเองให้มากขึ้นได้ด้วย</para>

</sect1>
<!-- The Mail Must Get Through -->
<sect1><title>ต้องส่งเมลให้ได้</title>

<para>Since 1993 I'd been running the technical side of a small
free-access Internet service provider called Chester County InterLink
(CCIL) in West Chester, Pennsylvania. I co-founded CCIL and wrote our
unique multiuser bulletin-board software&mdash;you can check it out by
telnetting to <ulink
url="telnet://locke.ccil.org">locke.ccil.org</ulink>.  Today it
supports almost three thousand users on thirty lines.  The job allowed
me 24-hour-a-day access to the net through CCIL's 56K line&mdash;in fact,
the job practically demanded it!</para>

<para>ตั้งแต่ปี 1993 ผมได้ทำงานด้านเทคนิคให้กับผู้ให้บริการอินเทอร์เน็ตฟรีเล็กๆ 
ที่ชื่อว่า Chester Country InterLink (CCIL) ซึ่งอยู่ใน West Chester 
รัฐเพนซิลวาเนีย ผมร่วมก่อตั้ง CCIL 
และได้เขียนซอฟต์แวร์กระดานข่าวที่รองรับหลายผู้ใช้ของเราขึ้น 
ซึ่งคุณสามารถลองได้โดยเทลเน็ตไปยัง 
<ulink url="telnet://locke.ccil.org">locke.ccil.org</ulink> 
ในปัจจุบัน มันรองรับผู้ใช้สามพันคนด้วยสามสิบคู่สาย 
งานนี้ทำให้ผมสามารถเข้าสู่อินเทอร์เน็ตได้ตลอด 24 ชั่วโมง ผ่านเครือข่ายความเร็ว 
56K ของ CCIL ซึ่งจะว่าไปแล้ว ก็จำเป็นต้องใช้ในงานแบบนี้อยู่แล้ว</para>

<para>I had gotten quite used to instant Internet email.  I found having to
periodically telnet over to locke to check my mail annoying.  What I
wanted was for my mail to be delivered on snark (my home system) so
that I would be notified when it arrived and could handle it using all
my local tools.</para>

<para>ผมได้คุ้นเคยกับการส่งอีเมลอย่างรวดเร็ว ผมพบว่าการเทลเน็ตไปยัง locke 
เป็นระยะๆ เพื่อเช็กอีเมลนั้น เป็นเรื่องน่ารำคาญ 
ผมต้องการให้อีเมลของผมถูกส่งไปยัง snark (ชื่อเครื่องที่บ้านผม) 
เพื่อที่ผมจะได้รับการแจ้งเตือนเมื่ออีเมลมาถึง 
และสามารถจัดการเมลด้วยโปรแกรมบนเครื่องของผมเอง</para>

<para>The Internet's native mail forwarding protocol, SMTP (Simple Mail
Transfer Protocol), wouldn't suit, because it works best when machines
are connected full-time, while my personal machine isn't always on the
Internet, and doesn't have a static IP address.  What I needed was a program
that would reach out over my intermittent dialup connection and pull
across my mail to be delivered locally.  I knew such things existed, and
that most of them used a simple application protocol called POP (Post
Office Protocol).  POP is now widely supported by most common mail
clients, but at the time, it wasn't built in to the mail reader I was
using.</para>

<para>โพรโทคอลหลักสำหรับส่งจดหมายบนอินเทอร์เน็ต ซึ่งก็คือ SMTP (Simple Mail 
Tranfer Protocal) นั้น ไม่ตรงกับความต้องการ 
เพราะมันจะทำงานได้ดีต่อเมื่อเครื่องของเราต่ออินเทอร์เน็ตอยู่ตลอดเวลา 
ซึ่งเครื่องของผมไม่ได้ต่ออยู่ตลอด และไม่มีหมายเลขไอพีที่แน่นอนด้วย 
สิ่งที่ผมต้องการคือโปรแกรมที่ติดต่อออกไปผ่านการเชื่อมต่อที่ไม่ต่อเนื่อง 
และดึงจดหมายมาส่งบนเครื่อง ผมรู้ว่ามีโปรแกรมประเภทนี้อยู่ 
และส่วนมากมักจะใช้โพรโทคอลแบบง่ายๆ ที่ชื่อ POP (Post Office Protocal) 
ซึ่งโปรแกรมอีเมลทุกวันนี้จำนวนมากรู้จักและสนับสนุน แต่ว่าตอนนั้น 
มันไม่มีอยู่ในโปรแกรมเมลที่ผมใช้อยู่</para>

<para>I needed a POP3 client.  So I went out on the Internet and found
one.  Actually, I found three or four.  I used one of them for a
while, but it was missing what seemed an obvious feature, the ability
to hack the addresses on fetched mail so replies would work
properly.</para>

<para>ผมต้องการโปรแกรมอ่าน POP3 ดังนั้นผมจึงค้นหาในอินเทอร์เน็ต 
และพบโปรแกรมหนึ่ง ซึ่งอันที่จริง ผมพบอยู่ 3-4 ตัว ผมลองใช้โปรแกรมหนึ่งดูสักพัก 
แต่มันขาดความสามารถที่เด่นๆ อย่างการเข้าไปแก้ที่อยู่ของเมลที่ดึงมา 
เพื่อที่จะตอบจดหมายกลับได้ถูกต้อง</para>

<para>The problem was this: suppose someone named `joe' on locke sent
me mail.  If I fetched the mail to snark and then tried to reply to
it, my mailer would cheerfully try to ship it to a nonexistent `joe'
on snark.  Hand-editing reply addresses to tack on
<email>@ccil.org</email> quickly got to be a serious pain.</para>

<para>ปัญหามีดังนี้ สมมติว่าใครบางคนชื่อ joe ที่อยู่ที่ locke ส่งเมลมาหาผม 
ถ้าผมดึงเมลมายัง snark และตอบเมลฉบับนี้ 
โปรแกรมเมลของผมจะพยายามส่งไปยังผู้ใช้ที่ชื่อ joe บน snark ซึ่งไม่มีอยู่ 
และการแก้ที่อยู่เองให้เป็น <email>@ccil.org</email> นั้น 
ก็ไม่ใช่เรื่องที่น่าสนุกนัก</para>

<para>This was clearly something the computer ought to be doing for me.  But
none of the existing POP clients knew how!  And this brings us to the
first lesson:</para>

<para>สิ่งนี้เป็นสิ่งที่คอมพิวเตอร์ควรจะทำให้ผม แต่ว่าไม่มีโปรแกรมอ่าน POP 
ตัวไหนเลยที่ทำได้ และนี่ก็ทำให้เราได้รู้จักกับบทเรียนข้อแรก:</para>

<blockquote><para>1. Every good work of software starts by scratching
       a developer's personal itch.</para></blockquote>

<blockquote><para>1. ซอฟต์แวร์ดีๆ นั้น 
       เริ่มมาจากการสนองความต้องการส่วนตัวของผู้พัฒนา</para></blockquote>

<para>Perhaps this should have been obvious (it's long been proverbial that
``Necessity is the mother of invention'') but too often software
developers spend their days grinding away for pay at programs they
neither need nor love.  But not in the Linux world&mdash;which may
explain why the average quality of software originated in the Linux
community is so high.</para>

<para>เรื่องนี้คงชัดเจนอยู่แล้ว (มีสุภาษิตมานานแล้วว่า ``ความจำเป็น 
เป็นบ่อเกิดของการคิดค้น'') 
แต่ก็มีนักพัฒนาจำนวนมากที่ใช้เวลาแต่ละวันไปกับการปั่นงานแลกเงิน 
เพื่อสร้างโปรแกรมที่เขาไม่ได้ต้องการ หรือไม่ได้รักที่จะทำ 
แต่ว่าไม่เป็นเช่นนั้นในโลกของลินุกซ์ 
ซึ่งอาจอธิบายได้ว่าทำไมคุณภาพเฉลี่ยของงานที่สร้างโดยชุมชนลินุกซ์จึงสูงกว่าปกติ
</para>

<para>So, did I immediately launch into a furious whirl of coding up a
brand-new POP3 client to compete with the existing ones?  Not on your
life!  I looked carefully at the POP utilities I had in hand, asking
myself ``Which one is closest to what I want?''  Because:</para>

<para>แล้วผมก็เลยตัดสินใจเข้าไปสู่วังวนของการสร้างโปรแกรม POP3 ตัวใหม่ 
เพื่อที่จะแข่งกับตัวเดิมๆ ทันทีเลยงั้นหรือ? ไม่มีวันหรอก! 
ผมได้สำรวจเครื่องมือจัดการ POP ที่ผมมีอยู่ในมือ และถามตัวเองว่า 
``โปรแกรมไหนที่ใกล้เคียงกับสิ่งที่ผมต้องการมากที่สุด?'' เพราะว่า:</para>

<blockquote><para>2. Good programmers know what to write.  Great ones
       know what to rewrite (and reuse).</para></blockquote>

<blockquote><para>2. โปรแกรมเมอร์ที่ดีย่อมรู้ว่าจะเขียนอะไร 
       แต่โปรแกรมเมอร์ที่ยอดเยี่ยมจะรู้ว่าเมื่อไรต้องเขียนใหม่ 
       และเมื่อไรใช้ของเก่าได้</para></blockquote>

<para>While I don't claim to be a great programmer, I try to imitate one.
An important trait of the great ones is constructive laziness.  They
know that you get an A not for effort but for results, and that it's
almost always easier to start from a good partial solution than from
nothing at all.</para>

<para>ผมไม่ได้บอกว่าตัวเองเป็นโปรแกรมเมอร์ที่ยอดเยี่ยม ผมแค่พยายามเลียนแบบดู 
คุณสมบัติที่สำคัญของโปรแกรมเมอร์ที่ยอดเยี่ยมก็คือ ความขี้เกียจอย่างสร้างสรรค์ 
พวกเขารู้ว่าการที่คุณได้ A ไม่ใช่เพราะความพยายาม แต่เพราะผลลัพธ์ของมัน 
และมันก็ง่ายกว่าที่จะเริ่มต้นจากบางส่วนที่มีอยู่แล้ว 
แทนที่จะเริ่มใหม่ทั้งหมด</para>

<para><ulink url="http://www.tuxedo.org/~esr/faqs/linus">Linus
Torvalds</ulink>, for example, didn't actually try to write Linux from
scratch.  Instead, he started by reusing code and ideas from Minix, a
tiny Unix-like operating system for PC clones.  Eventually all the
Minix code went away or was completely rewritten&mdash;but while it was
there, it provided scaffolding for the infant that would eventually
become Linux.</para>

<para><ulink url="http://catb.org/~esr/faqs/linus">ไลนัส 
ทอร์วัลด์</ulink> เป็นตัวอย่างที่ดี เขาไม่ได้สร้างลินุกซ์ขึ้นมาใหม่ทั้งหมด 
เขาเริ่มจากใช้โค้ดและความคิดบางส่วนจากมินิกซ์ 
ซึ่งเป็นยูนิกซ์ขนาดเล็กสำหรับเครื่องพีซี 
ถึงแม้ว่าโค้ดของมินิกซ์ในลินุกซ์นั้นจะถูกแทนที่ด้วยโค้ดใหม่ๆ ไปหมดแล้ว 
แต่ว่าตอนที่ยังอยู่ 
มันได้เป็นพื้นฐานให้กับทารกที่จะกลายมาเป็นลินุกซ์ในภายหลัง</para>

<para>In the same spirit, I went looking for an existing POP utility that
was reasonably well coded, to use as a development base.</para>

<para>ด้วยความคิดเดียวกัน ผมได้พยายามหาโปรแกรม POP ที่มีอยู่แล้ว 
ที่โค้ดของมันได้ถูกเขียนมาอย่างดี เพื่อใช้เป็นจุดเริ่มต้นในการพัฒนา</para>

<para>The source-sharing tradition of the Unix world has always been
friendly to code reuse (this is why the GNU project chose Unix as a
base OS, in spite of serious reservations about the OS itself).  The
Linux world has taken this tradition nearly to its technological
limit; it has terabytes of open sources generally available.  So
spending time looking for some else's almost-good-enough is more
likely to give you good results in the Linux world than anywhere
else.</para>

<para>ธรรมเนียมการแบ่งปันซอร์สโค้ดในโลกของยูนิกซ์เป็นมิตรต่อการใช้โค้ดซ้ำเสมอ 
(นี่เป็นเหตุผลว่าทำไม GNU ถึงได้เลือกยูนิกซ์เป็นระบบปฏิบัติการหลัก 
แม้จะสงวนท่าทีชัดเจนว่าไม่ใช่ยูนิกซ์) 
โลกของลินุกซ์ได้นำเอาธรรมเนียมนี้มาใช้อย่างเต็มพิกัด เรามีโปรแกรมโอเพนซอร์สดีๆ 
จำนวนมหาศาล ดังนั้นการใช้เวลาเสาะหาโปรแกรมดีๆ ที่เกือบใช้การได้ของใครซักคน 
จะทำให้คุณได้ผลลัพธ์ดีๆ ในโลกของลินุกซ์มากกว่าที่อื่น</para>

<para>And it did for me.  With those I'd found earlier, my second
search made up a total of nine candidates&mdash;fetchpop, PopTart,
get-mail, gwpop, pimp, pop-perl, popc, popmail and upop.  The one I
first settled on was `fetchpop' by Seung-Hong Oh.  I put my
header-rewrite feature in it, and made various other improvements
which the author accepted into his 1.9 release.</para>

<para>แล้วมันก็ได้ผลสำหรับผม จากการค้นหาที่ผมพบครั้งก่อน 
การค้นหาครั้งที่สองเจอโปรแกรมที่เข้าท่าอยู่ 9 ตัว คือ fetchpop, PopTart, 
get-mail, gwpop, pimp, pop-perl, popc, popmail และ upop 
ตัวแรกที่ผมเลือกคือ fetchpop ซึ่งสร้างโดย Seung-Hong Oh 
ผมได้เขียนความสามารถการเปลี่ยนหัวจดหมายเข้าไป และเพิ่มความสามารถต่างๆ 
ซึ่งผู้สร้างได้รับมันเข้าไปใช้ในเวอร์ชัน 1.9</para>

<para>A few weeks later, though, I stumbled across the code for
popclient by Carl Harris, and found I had a problem.  Though fetchpop
had some good original ideas in it (such as its background-daemon
mode), it could only handle POP3 and was rather amateurishly coded
(Seung-Hong was at that time a bright but inexperienced programmer,
and both traits showed).  Carl's code was better, quite professional
and solid, but his program lacked several important and rather
tricky-to-implement fetchpop features (including those I'd coded
myself).</para>

<para>ไม่กี่สัปดาห์ต่อมา ผมเข้าไปอ่านโค้ดของ popclient ซึ่งสร้างโดย คาร์ล 
แฮร์ริส และพบปัญหา ถึงแม้ fetchpop จะมีแนวคิดดีๆ 
อย่างการทำงานในโหมดดีมอนเบื้องหลัง แต่มันสามารถทำงานกับ POP3 เท่านั้น 
และโค้ดของมันก็ไม่ค่อยดีเท่าที่ควร เพราะ Seung-Hong 
ตอนนั้นเป็นโปรแกรมเมอร์ที่เก่ง แต่ยังขาดประสบการณ์อยู่ 
และความสามารถของเขาทั้งคู่ถูกแสดงออกในโค้ด ผมพบว่าโค้ดของคาร์ลดีกว่า 
ค่อนข้างเป็นมืออาชีพและแน่นหนา แต่โปรแกรมของเขายังขาดความสามารถสำคัญ 
และค่อนข้างทำยาก ซึ่งมีใน fetchpop รวมถึงสิ่งที่ผมเขียนเองด้วย</para>

<para>Stay or switch?  If I switched, I'd be throwing away the coding I'd
already done in exchange for a better development base.</para>

<para>จะเปลี่ยนไหม? ถ้าผมเลือกจะเปลี่ยน ผมต้องทิ้งสิ่งที่ผมสร้างขึ้นมา 
เพื่อแลกกับโปรแกรมใหม่ที่ดีกว่าในการพัฒนาต่อ</para>

<para>A practical motive to switch was the presence of multiple-protocol
support.  POP3 is the most commonly used of the post-office server
protocols, but not the only one.  Fetchpop and the other competition
didn't do POP2, RPOP, or APOP, and I was already having vague thoughts
of perhaps adding <ulink url="http://www.imap.org">IMAP</ulink>
(Internet Message Access Protocol, the most recently designed and most
powerful post-office protocol) just for fun.</para>

<para>แรงจูงใจในทางปฏิบัติที่จะเปลี่ยน 
คือการได้ความสามารถในการสนับสนุนหลายโพรโทคอล โพรโทคอล POP3 นั้น 
ใช้กันมากในเครื่องแม่ข่ายตู้ไปรษณีย์เมล แต่ยังมีโพรโทคอลชนิดอื่นอีก fetchpop 
และโปรแกรมบางตัวนั้นไม่สนับสนุน POP2, RPOP หรือ APOP 
และผมยังมีเค้าความคิดที่จะเพิ่ม <ulink url="http://www.imap.org">IMAP</ulink> 
(Internet Message Access Protocal) ซึ่งเป็นโพรโทคอลที่ออกแบบมาใหม่ล่าสุด 
และมีประสิทธิภาพมากที่สุดเข้าไปอีกด้วย เพื่อความสนุกสนาน</para>

<para>But I had a more theoretical reason to think switching might be as
good an idea as well, something I learned long before Linux.</para>

<para>แต่ผมมีเหตุผลทางทฤษฎีที่คิดว่าการเปลี่ยนอาจจะดีก็ได้ 
ซึ่งเป็นสิ่งที่ผมเรียนรู้มานานก่อนจะพบกับลินุกซ์</para>

<blockquote><para>3. ``Plan to throw one away; you will, anyhow.''
       (Fred Brooks, <citetitle>The Mythical Man-Month</citetitle>,
       Chapter 11)</para></blockquote>

<blockquote><para>3. ``เตรียมพร้อมที่จะทิ้งสิ่งเดิมไป คุณได้ทิ้งแน่ 
       ไม่ว่าจะอย่างไร'' (จาก เฟรด บรูกส์ ใน 
       <citetitle>The Mythical Man-Month</citetitle>, บทที่ 11)
       </para></blockquote>

<para>Or, to put it another way, you often don't really understand the
problem until after the first time you implement a solution.  The
second time, maybe you know enough to do it right.  So if you want to
get it right, be ready to start over <emphasis>at least</emphasis>
once <link linkend="JB">[JB]</link>.</para>

<para>หรือพูดอีกอย่างหนึ่ง คุณมักจะไม่ได้เข้าใจปัญหาอย่างแท้จริง 
จนกว่าคุณจะเริ่มลงมือทำครั้งแรก พอลงมือครั้งที่สอง 
คุณอาจจะรู้แล้วว่าต้องทำอย่างไร ดังนั้นถ้าคุณต้องการจะทำให้ถูกต้องจริงๆ 
ก็ควรเตรียมพร้อมที่จะเริ่มต้นใหม่ <link linkend="JB">[JB]</link></para>

<para>Well (I told myself) the changes to fetchpop had been my first try.
So I switched.</para>

<para>ผมบอกตัวเองว่าสิ่งที่ผมเพิ่มไปใน fetchpop เป็นความพยายามครั้งแรกของผม 
ดังนั้นผมเปลี่ยน</para>

<para>After I sent my first set of popclient patches to Carl Harris on 25
June 1996, I found out that he had basically lost interest in
popclient some time before.  The code was a bit dusty, with minor bugs
hanging out.  I had many changes to make, and we quickly agreed that
the logical thing for me to do was take over the program.</para>

<para>หลังจากผมส่งแพตช์แรกไปให้กับ คาร์ล แฮร์ริส ในวันที่ 25 มิถุนายน 1996 
ผมพบว่าเขาเริ่มจะหมดความสนใจในตัวโปรแกรมก่อนหน้านั้นแล้ว 
โค้ดนั้นไม่ค่อยเรียบร้อย และมีบั๊กประปราย ผมมีเรื่องที่อยากแก้หลายจุด 
และเราก็ตกลงกันได้อย่างรวดเร็ว ว่าผมควรจะรับโปรแกรมนี้ไปดูแลต่อ</para>

<para>Without my actually noticing, the project had escalated.  No longer
was I just contemplating minor patches to an existing POP client.
I took on maintaining an entire one, and there were ideas bubbling in
my head that I knew would probably lead to major changes.</para>

<para>ผมไม่ได้สังเกตเลยว่า งานมันเริ่มจะใหญ่ขึ้นเรื่อยๆ 
ผมไม่ได้คิดถึงแค่แพตช์เล็กแพตช์น้อยสำหรับโปรแกรม POP เดิมอีกต่อไป 
ผมกำลังดูแลโปรแกรมทั้งตัว และผมก็เกิดความคิดในสมองมากมาย 
ซึ่งผมรู้ดีว่าจะนำไปสู่การเปลี่ยนแปลงขนานใหญ่</para>

<para>In a software culture that encourages code-sharing, this is a natural
way for a project to evolve.  I was acting out this principle:</para>

<para>ในวัฒนธรรมซอฟต์แวร์ที่เน้นการแบ่งปันโค้ด 
นี่เป็นวิถีทางตามธรรมชาติสำหรับโครงการต่างๆ ที่จะก้าวหน้าต่อไป 
ผมกำลังทำตามหลักการนี้:</para>

<blockquote><para>4. If you have the right attitude, interesting
	problems will find you.</para></blockquote>

<blockquote><para>4. ถ้าคุณมีทัศนคติที่เหมาะสม ปัญหาที่น่าสนใจจะเข้ามาเจอคุณเอง
	</para></blockquote>

<para>But Carl Harris's attitude was even more important.  He
understood that</para>

<para>แต่ทัศนคติของ คาร์ล แฮร์ริส นั้นสำคัญกว่า เขาเข้าใจดีว่า</para>

<blockquote><para>5. When you lose interest in a program, your last
       duty to it is to hand it off to a competent
       successor.</para></blockquote>

<blockquote><para>5. เมื่อคุณหมดความสนใจในโปรแกรมเดิมแล้ว 
       หน้าที่สุดท้ายของคุณคือ ส่งต่อให้กับผู้สืบทอดที่มีฝีมือ
       </para></blockquote>

<para>Without ever having to discuss it, Carl and I knew we had a common
goal of having the best solution out there.  The only question for
either of us was whether I could establish that I was a safe pair of
hands.  Once I did that, he acted with grace and dispatch.  I hope I
will do as well when it comes my turn.</para>

<para>และเราไม่ต้องถกเถียงกันเลย 
ผมและคาร์ลรู้ว่าเรามีเป้าหมายร่วมกันที่จะหาคำตอบที่ดีที่สุดที่มีอยู่ 
คำถามเดียวที่เกิดขึ้นกับแต่ละฝ่ายคือ ผมจะสามารถยืนยันได้ไหม 
ว่าผมจะเป็นผู้ดูแลที่วางใจได้ เมื่อผมทำได้ เขาก็จากไปอย่างนุ่มนวล ผมหวังว่า
ผมจะทำเช่นนั้นเหมือนกัน เมื่อถึงตาที่ผมต้องส่งต่อให้คนอื่น</para>

</sect1>
<!-- The Importance of Having Users -->
<sect1><title>ความสำคัญของผู้ใช้</title>

<para>And so I inherited popclient.  Just as importantly, I inherited
popclient's user base.  Users are wonderful things to have, and
not just because they demonstrate that you're serving a need, that 
you've done something right.  Properly cultivated, they can 
become co-developers.</para>

<para>และแล้วผมก็รับช่วง popclient ต่อ ที่สำคัญไม่แพ้กันก็คือ 
ผมก็รับช่วงฐานผู้ใช้ของ popclient ต่ออีกด้วย 
การมีผู้ใช้งานโปรแกรมของเราเป็นสิ่งที่ยอดมาก ไม่ใช่แค่เพราะพวกเขาแสดงให้เห็น 
ว่าคุณกำลังสนองความต้องการที่มีอยู่จริง ว่าคุณกำลังทำสิ่งที่ควร 
แต่ถ้าเตรียมการดีๆ เขาก็อาจมาเป็นผู้ร่วมพัฒนากับคุณได้</para>

<para>Another strength of the Unix tradition, one that Linux pushes to
a happy extreme, is that a lot of users are hackers too.  Because
source code is available, they can be <emphasis>effective</emphasis>
hackers.  This can be tremendously useful for shortening debugging
time.  Given a bit of encouragement, your users will diagnose
problems, suggest fixes, and help improve the code far more quickly
than you could unaided.</para>

<para>จุดแข็งอีกอย่างหนึ่งของธรรมเนียมยูนิกซ์ ซึ่งลินุกซ์ผลักดันไปถึงจุดสุดยอด 
คือผู้ใช้ส่วนมากมักเป็นแฮ็กเกอร์ด้วย และเนื่องจากผู้ใช้สามารถเข้าถึงซอร์สโค้ดได้
พวกเขาจึงกลายเป็นแฮ็กเกอร์ที่ <emphasis>ลงมือจริง</emphasis> 
สิ่งนี้ช่วยย่นระยะเวลาในการจัดการกับบั๊กลงได้อย่างมากมาย 
เพียงแค่คุณกระตุ้นพวกเขาเล็กน้อย เหล่าผู้ใช้จะช่วยกันหาสาเหตุของปัญหา 
และแนะนำวิธีแก้ไข แถมช่วยพัฒนาโค้ดได้เร็วกว่าที่คุณทำเองคนเดียวเสียอีก</para>

<blockquote><para>6. Treating your users as co-developers is your
       least-hassle route to rapid code improvement and effective
       debugging.</para></blockquote>

<blockquote><para>6. การปฏิบัติต่อผู้ใช้เยี่ยงผู้ร่วมงาน 
       เป็นหนทางที่สะดวกที่สุด ที่จะนำไปสู่การพัฒนาโค้ดอย่างรวดเร็ว 
       และการแก้บั๊กอย่างได้ผล</para></blockquote>

<para>The power of this effect is easy to underestimate.  In fact, pretty
well all of us in the open-source world drastically underestimated
how well it would scale up with number of users and against system
complexity, until Linus Torvalds showed us differently.</para>

<para>เรามักจะประเมินผลของวิธีการแบบนี้ต่ำไป ความจริงแล้ว 
พวกเราส่วนใหญ่ในโลกโอเพนซอร์สประเมินพลาดไปอย่างแรง 
ว่าผลของมันขยายตามจำนวนผู้ใช้ โดยเอาชนะความซับซ้อนของระบบได้ดีเพียงใด 
จนกระทั่ง ไลนัส ทอร์วัลด์ ได้แสดงให้เราเห็น 
ว่ามันไม่ได้เป็นอย่างที่เราคิด</para>

<para>In fact, I think Linus's cleverest and most consequential hack
was not the construction of the Linux kernel itself, but rather his
invention of the Linux development model.  When I expressed this
opinion in his presence once, he smiled and quietly repeated something
he has often said: ``I'm basically a very lazy person who likes to get
credit for things other people actually do.''  Lazy like a fox.  Or,
as Robert Heinlein famously wrote of one of his characters, too lazy
to fail.</para>

<para>ความจริงแล้ว ผมคิดว่าผลงานที่ชาญฉลาดที่สุด และเกิดผลมากที่สุดของไลนัส 
ไม่ใช่การสร้างเคอร์เนลลินุกซ์ แต่เป็นการสร้างรูปแบบการพัฒนาลินุกซ์ต่างหาก 
ครั้งหนึ่งเมื่อเจอหน้าเขา ผมแสดงความเห็นนี้ของผมให้เขาฟัง เขายิ้ม และพูดเบาๆ 
อย่างที่เขาเคยพูดอยู่เสมอว่า ``ผมเป็นแค่คนขี้เกียจสุดๆ คนหนึ่ง 
ที่อยากได้ชื่อจากผลงานของคนอื่น'' ขี้เกียจอย่างหมาจิ้งจอก หรืออย่างที่ โรเบิร์ต 
ไฮน์ไลน์ นักเขียนชื่อดังได้บรรยายตัวละครของเขาตัวหนึ่งไว้ว่า 
``ขี้เกียจที่จะล้มเหลว''</para>

<para>In retrospect, one precedent for the methods and success of
Linux can be seen in the development of the GNU Emacs Lisp library and
Lisp code archives.  In contrast to the cathedral-building style of
the Emacs C core and most other GNU tools, the evolution of the Lisp
code pool was fluid and very user-driven.  Ideas and prototype modes
were often rewritten three or four times before reaching a stable
final form.  And loosely-coupled collaborations enabled by the
Internet, <foreignphrase>a la</foreignphrase> Linux, were
frequent.</para>

<para>ถ้าเรามองย้อนกลับไป วิธีการและความสำเร็จของลินุกซ์ เคยเกิดขึ้นมาก่อนแล้ว 
ในการพัฒนาไลบรารี Lisp พร้อมทั้งคลังโค้ด Lisp ของโครงการ GNU Emacs 
ซึ่งวิธีนี้ตรงข้ามกับการพัฒนาส่วนหลักที่เขียนด้วยภาษาซีของ Emacs 
และโปรแกรมส่วนมากของ GNU ซึ่งสร้างด้วยวิธีแบบมหาวิหาร การพัฒนาโค้ดส่วน Lisp 
นั้นเป็นไปอย่างไหลลื่น และริเริ่มโดยผู้ใช้อย่างมาก 
แนวคิดและตัวต้นแบบมักจะถูกแก้ไขและเขียนใหม่ 3-4 ครั้ง ก่อนจะเสถียรพอ 
แถมการพัฒนาร่วมกันนั้นก็ทำผ่านอินเทอร์เน็ต เช่นเดียวกับลินุกซ์</para>

<para>Indeed, my own most successful single hack previous to fetchmail
was probably Emacs VC (version control) mode, a Linux-like
collaboration by email with three other people, only one of whom
(Richard Stallman, the author of Emacs and founder of the <ulink
url="http://www.fsf.org">Free Software Foundation</ulink>) I have met
to this day.  It was a front-end for SCCS, RCS and later CVS from
within Emacs that offered ``one-touch'' version control operations.
It evolved from a tiny, crude sccs.el mode somebody else had written.
And the development of VC succeeded because, unlike Emacs itself,
Emacs Lisp code could go through release/test/improve generations very
quickly.</para>

<para>อันที่จริง ก่อนผมจะทำ fetchmail 
ผลงานที่ผมคิดว่าประสบความสำเร็จที่สุดของผมนั้น คงเป็นโหมด VC (Version Control)
ของ Emacs โดยเป็นการทำงานร่วมกันผ่านเมลแบบลินุกซ์กับคนอื่นอีก 3 คน 
ซึ่งในนั้น จนถึงทุกวันนี้ มีเพียงคนเดียว (คือ ริชาร์ด สตอลล์แมน ผู้สร้าง Emacs 
และผู้ก่อตั้ง <ulink url="http://www.fsf.org">มูลนิธิซอฟต์แวร์เสรี</ulink>) 
ที่ผมเคยได้พบหน้า โหมด VC เป็น ส่วนติดต่อ (front end) ของ SCCS, RCS และ CVS ของ 
Emacs ที่มีสามารถดำเนินการกับระบบควบคุมเวอร์ชันได้ใน ``สัมผัสเดียว'' 
พัฒนามาจากโหมด sccs.el เล็กๆ เถื่อนๆ ที่ใครบางคนเขียนไว้ การพัฒนาของ VC 
ประสบความสำเร็จเพราะ Lisp ได้ผ่านขั้นตอนต่างๆ ของวัฏจักรซอฟต์แวร์ 
(ออก/ทดสอบ/พัฒนา) อย่างรวดเร็ว ไม่เหมือนตัว Emacs เอง</para>

<para>The Emacs story is not unique.  There have been other software
products with a two-level architecture and a two-tier user community
that combined a cathedral-mode core and a bazaar-mode toolbox.  One
such is MATLAB, a commercial data-analysis and visualization tool. 
Users of MATLAB and other products with a similar structure invariably
report that the action, the ferment, the innovation mostly takes place
in the open part of the tool where a large and varied community can
tinker with it.</para>

<para>เรื่องทำนองนี้ไม่ได้เกิดแค่กับ Emacs แต่ยังมีผลิตภัณฑ์ซอฟต์แวร์อื่น 
ที่มีโครงสร้างโปรแกรมแบ่งเป็นสองระดับ และมีชุมชนผู้ใช้สองระดับ 
ซึ่งประกอบด้วยแกนที่พัฒนาในแบบมหาวิหาร และเครื่องมือประกอบที่พัฒนาในแบบตลาดสด 
ตัวอย่างหนึ่งคือ MATLAB 
เครื่องมือเชิงพาณิชย์สำหรับวิเคราะห์ข้อมูลและแสดงเป็นภาพ ผู้ใช้ MATLAB 
และผลิตภัณฑ์อื่นทำนองนี้ ต่างรายงานเหมือนๆ กัน ว่าความเคลื่อนไหว ความตื่นตัว 
และนวัตกรรม มักเกิดในส่วนที่เปิด 
ซึ่งชุมชนที่ใหญ่โตและหลากหลายสามารถเข้าไปทำอะไรเองได้</para>

</sect1>
<!-- Release Early, Release Often -->
<sect1><title>ออกเนิ่นๆ ออกถี่ๆ</title>

<para>Early and frequent releases are a critical part of the Linux
development model.  Most developers (including me) used to believe
this was bad policy for larger than trivial projects, because early
versions are almost by definition buggy versions and you don't want to
wear out the patience of your users.</para>

<para>การออกโปรแกรมแต่เนิ่นๆ และออกมาบ่อยๆ 
เป็นส่วนสำคัญของรูปแบบการพัฒนาลินุกซ์ นักพัฒนาส่วนมาก (รวมทั้งผมด้วย) 
เคยเชื่อว่า การทำอย่างนี้เป็นวิธีที่ไม่เข้าท่าเลยสำหรับโครงการใหญ่ๆ 
เพราะรุ่นที่ออกเร็ว จะเป็นการบอกว่าเป็นรุ่นที่อุดมไปด้วยบั๊ก 
และคุณไม่ต้องการที่จะทนฟังเสียงบ่นจากผู้ใช้งาน</para>

<para>This belief reinforced the general commitment to a
cathedral-building style of development.  If the overriding objective
was for users to see as few bugs as possible, why then you'd only
release a version every six months (or less often), and work like a
dog on debugging between releases.  The Emacs C core was developed
this way.  The Lisp library, in effect, was not&mdash;because there were
active Lisp archives outside the FSF's control, where you could go to
find new and development code versions independently of Emacs's
release cycle <link linkend="QR">[QR]</link>.</para>

<para>ความเชื่อนี้ ถือเป็นการสนับสนุนการพัฒนาแบบสร้างมหาวิหาร 
ถ้าจุดประสงค์หลักคือการให้ผู้ใช้พบบั๊กให้น้อยที่สุด 
ทำไมเราไม่ออกรุ่นจริงทุกหกเดือน (หรือนานกว่านั้นก็ได้) 
และทำงานอย่างหนักเพื่อจะตรวจสอบและแก้ไขบั๊กในทุกรุ่นที่ออก การพัฒนาแกนของ Emacs 
ที่เขียนด้วยภาษาซี ก็ทำด้วยวิธีนี้เอง แต่ในทางตรงข้าม ไลบรารี Lisp 
กลับใช้วิธีอื่น เพราะมีคลังของ Lisp อยู่นอกการควบคุมของ FSF 
และเราสามารถจะไปเอา Lisp รุ่นใหม่ๆ และรุ่นที่กำลังพัฒนาอยู่มาใช้ได้ 
โดยไม่ขึ้นกับวงจรการออกรุ่นของ Emacs <link linkend="QR">[QR]</link></para>

<para>The most important of these, the Ohio State Emacs Lisp archive,
anticipated the spirit and many of the features of today's big Linux
archives.  But few of us really thought very hard about what we were
doing, or about what the very existence of that archive suggested
about problems in the FSF's cathedral-building development model.  I
made one serious attempt around 1992 to get a lot of the Ohio code
formally merged into the official Emacs Lisp library.  I ran into
political trouble and was largely unsuccessful.</para>

<para>ในบรรดาคลังเหล่านี้ แหล่งที่สำคัญที่สุด ก็คือคลัง Lisp ของรัฐโอไฮโอ 
ซึ่งประมาณกันว่าเป็นศูนย์รวม และเป็นที่มาของความสามารถต่างๆ 
ในคลังซอฟต์แวร์ลินุกซ์ใหญ่ๆ ในปัจจุบัน 
แต่มีพวกเราน้อยคนที่จะคิดลงไปลึกซึ้งเกี่ยวกับสิ่งที่เราได้ทำไป 
หรือเกี่ยวกับการมีอยู่ของคลังดังกล่าว 
ว่าเป็นเครื่องบ่งชี้ถึงปัญหาของรูปแบบการพัฒนาในแบบมหาวิหารของ FSF 
ในปี 1992 ผมเคยพยายามผนวกโค้ดจากโอไฮโอหลายชิ้น เข้าในโค้ดหลักของไลบรารี Lisp 
ของ Emacs อย่างเป็นทางการ แต่ก็ติดปัญหาการเมืองใน FSF 
และก็ล้มเหลวในที่สุด</para>

<para>But by a year later, as Linux became widely visible, it was clear that
something different and much healthier was going on there.  Linus's
open development policy was the very opposite of cathedral-building.
Linux's Internet archives were burgeoning, multiple distributions were
being floated.  And all of this was driven by an unheard-of frequency
of core system releases.</para>

<para>แต่หนึ่งปีหลังจากนั้น เมื่อลินุกซ์เริ่มจะเป็นที่รู้จัก ก็เป็นที่ชัดเจน 
ว่ารูปแบบการพัฒนาที่แตกต่างและมีประสิทธิภาพกว่าได้เกิดขึ้นที่นั่น 
นโยบายการพัฒนาอย่างเปิดกว้างของไลนัสตรงข้ามกับแบบมหาวิหารอย่างสิ้นเชิง 
คลังซอฟต์แวร์ของลินุกซ์ในอินเทอร์เน็ตผุดขึ้นอย่างรวดเร็ว ผู้จัดจำหน่ายต่างๆ 
ก็เริ่มเกิดขึ้นมา สิ่งเหล่านี้เกิดขึ้นได้เพราะความถี่ของการออกของระบบแกน 
ชนิดที่เราไม่เคยได้ยินมาก่อน</para>

<para>Linus was treating his users as co-developers in the most effective
possible way:</para>

<para>ไลนัส ปฏิบัติกับผู้ใช้ของเขาเหมือนกับผู้ร่วมงาน 
ด้วยวิธีที่มีประสิทธิภาพที่สุด:</para>

<blockquote><para>7. Release early.  Release often.  And listen to
your customers.</para></blockquote>

<blockquote><para>7. ออกเนิ่นๆ ออกถี่ๆ และฟังเสียงผู้ใช้</para></blockquote>

<para>Linus's innovation wasn't so much in doing quick-turnaround releases
incorporating lots of user feedback (something like this had been
Unix-world tradition for a long time), but in scaling it up to a level
of intensity that matched the complexity of what he was developing.
In those early times (around 1991) it wasn't unknown for him to
release a new kernel more than once a <emphasis>day!</emphasis> Because he
cultivated his base of co-developers and leveraged the Internet for
collaboration harder than anyone else, this worked.</para>

<para>นวัตกรรมของไลนัสไม่ได้อยู่ที่เรื่องการออกรุ่นที่เปลี่ยนแปลงปุบปับ 
โดยรวบรวมสิ่งที่ผู้ใช้ตอบกลับมาเป็นจำนวนมาก 
(ซึ่งเป็นสิ่งที่เคยเกิดในธรรมเนียมของโลกยูนิกซ์นานมาแล้ว) 
แต่อยู่ที่การขยายขอบเขตขึ้นไปถึงระดับความเข้มข้นที่พอเหมาะกับความซับซ้อนของสิ่งที่เขาพัฒนา 
ในช่วงแรกนั้น (ราวปี 1991) ไม่ใช่เรื่องแปลกเลยสำหรับเขา 
ที่จะออกเคอร์เนลใหม่มากกว่าหนึ่งครั้ง <emphasis>ต่อวัน!</emphasis>
เขาทำได้เนื่องจากเขามีผู้ร่วมงานที่เขาสร้างขึ้นจำนวนมาก 
และใช้อินเทอร์เน็ตในการร่วมมือทำงานมากกว่าใครๆ</para>

<para>But <emphasis>how</emphasis> did it work?  And was it something
I could duplicate, or did it rely on some unique genius of Linus
Torvalds?</para>

<para>แต่ว่ามันทำงานได้<emphasis>อย่างไร?</emphasis> 
มันเป็นสิ่งที่ผมจะลองทำตามได้ไหม? หรือว่านี่เป็นพรสวรรค์เฉพาะตัวของ ไลนัส 
ทอร์วัลด์ เท่านั้น?</para>

<para>I didn't think so.  Granted, Linus is a damn fine hacker. How
many of us could engineer an entire production-quality operating
system kernel from scratch?  But Linux didn't represent any awesome
conceptual leap forward.  Linus is not (or at least, not yet) an
innovative genius of design in the way that, say, Richard Stallman or
James Gosling (of NeWS and Java) are.  Rather, Linus seems to me to be
a genius of engineering and implementation, with a sixth sense for
avoiding bugs and development dead-ends and a true knack for finding
the minimum-effort path from point A to point B.  Indeed, the whole
design of Linux breathes this quality and mirrors Linus's essentially
conservative and simplifying design approach.</para>

<para>ผมไม่คิดอย่างนั้น ผมยอมรับว่าไลนัสเป็นแฮ็กเกอร์ที่เก่งมาก 
มีพวกเราสักกี่คนที่จะสามารถควบคุมการสร้างเคอร์เนลของระบบปฏิบัติการระดับคุณภาพโดยเริ่มจากศูนย์ได้อย่างนี้? 
แต่ลินุกซ์ไม่ได้เป็นตัวแทนของการก้าวกระโดดทางความคิดที่ยิ่งใหญ่อะไรเลย 
ไลนัสเองก็ไม่ได้เป็น (หรืออย่างน้อยก็ยังไม่ได้เป็น) อัจฉริยะในการออกแบบในแบบที่ 
ริชาร์ด สตอลล์แมน หรือ เจมส์ กอสลิง (ผู้สร้าง NeWS และจาวา) เป็นเลย 
แต่ไลนัสเป็นอัจฉริยะในการควบคุมการพัฒนา 
โดยมีสัมผัสพิเศษในการหลีกเลียงบั๊กและทางตันของการพัฒนา 
และฉลาดในการหาเส้นทางที่เปลืองแรงน้อยที่สุดจากจุดหนึ่งไปอีกจุดหนึ่ง 
อันที่จริง การออกแบบของลินุกซ์อาศัยคุณสมบัตินี้ของไลนัสเป็นหลัก 
และสะท้อนถึงวิธีออกแบบที่อนุรักษนิยมและเรียบง่ายของไลนัสเอง</para>

<para>So, if rapid releases and leveraging the Internet medium to the hilt
were not accidents but integral parts of Linus's engineering-genius
insight into the minimum-effort path, what was he maximizing?  What
was he cranking out of the machinery?</para>

<para>ดังนั้น ถ้าการออกบ่อยๆ 
และการใช้อินเทอร์เน็ตให้เป็นประโยชน์ไม่ใช่สิ่งที่เกิดขึ้นโดยบังเอิญ 
แต่เป็นพรสวรรค์ของไลนัสในการหาวิธีที่ง่ายและสั้นที่สุดในการพัฒนาล่ะก็ 
เขากำลังมุ่งเพิ่มปัจจัยอะไร? เขาทำให้รูปแบบนี้ทำงานได้อย่างไร?</para>

<para>Put that way, the question answers itself.  Linus was keeping
his hacker/users constantly stimulated and rewarded&mdash;stimulated by
the prospect of having an ego-satisfying piece of the action, rewarded
by the sight of constant (even <emphasis>daily</emphasis>) improvement
in their work.</para>

<para>คำถามนี้มีคำตอบในตัวมันเองอยู่แล้ว 
ไลนัสได้พยายามกระตุ้นและให้รางวัลแก่กลุ่มแฮ็กเกอร์หรือผู้ใช้ของเขาอย่างสม่ำเสมอ 
กระตุ้นโดยสร้างโอกาสของความภาคภูมิใจในตัวเองต่อการกระทำต่างๆ 
ให้รางวัลตอบแทนโดยการทำให้เห็นพัฒนาการของผลงานของพวกเขาเองอย่างสม่ำเสมอ 
(ถึงขนาดออกเป็น <emphasis>รายวัน</emphasis>)</para>

<para>Linus was directly aiming to maximize the number of person-hours
thrown at debugging and development, even at the possible cost of
instability in the code and user-base burnout if any serious bug
proved intractable.  Linus was behaving as though he believed
something like this:</para>

<para>ไลนัสมุ่งเพิ่มปริมาณคน-ชั่วโมงของเหล่านักพัฒนาในการตรวจสอบบั๊ก 
และพัฒนาโปรแกรม แม้จะเสี่ยงต่อการเกิดปัญหาด้านเสถียรภาพของโค้ด 
และจำนวนผู้ใช้จะลดลงไปเมื่อเกิดบั๊กร้ายแรงที่แก้ลำบาก ไลนัสได้แสดงตัวว่า 
เขาเองเชื่อในสิ่งต่อไปนี้:</para>

<blockquote><para>8. Given a large enough beta-tester and co-developer
       base, almost every problem will be characterized quickly and
       the fix obvious to someone.</para></blockquote>

<blockquote><para>8. ถ้ามีผู้ทดสอบและผู้พัฒนามากพอ ปัญหาแทบทุกอย่างจะมีคนรู้ 
       และต้องมีใครสักคนในนั้นที่แก้ปัญหาได้</para></blockquote>

<para>Or, less formally, ``Given enough eyeballs, all bugs are
shallow.''  I dub this: ``Linus's Law''.</para>

<para>หรือพูดง่ายๆ คือ ``มีลูกตามากพอ บั๊กทุกตัวจะง่ายลงเอง'' (Given enough 
eyeballs, all bugs are shallow) ผมขอตั้งคำพูดนี้เป็น ``กฎของไลนัส''</para>

<para>My original formulation was that every problem ``will be
transparent to somebody''.  Linus demurred that the person who
understands and fixes the problem is not necessarily or even usually
the person who first characterizes it.  ``Somebody finds the
problem,'' he says, ``and somebody <emphasis>else</emphasis>
understands it. And I'll go on record as saying that finding it is the
bigger challenge.'' That correction is important; we'll see how in the
next section, when we examine the practice of debugging in more
detail.  But the key point is that both parts of the process (finding
and fixing) tend to happen rapidly.</para>

<para>จริงๆ แล้วสูตรของผมตอนแรกคือ ปัญหาทุกปัญหา ``จะมีใครบางคนมองออก'' 
ไลนัสได้ค้านว่า ผู้ที่เข้าใจและสามารถแก้ไขปัญหาได้ 
ไม่จำเป็นต้องเป็นคนเดียวกับคนแรกที่พบมัน ``มีใครคนหนึ่งเจอปัญหา'' เขากล่าว 
``เดี๋ยวก็มี <emphasis>ใครอีกคน</emphasis> ที่เข้าใจตัวปัญหา 
และผมคิดว่าการค้นพบปัญหานั้นท้าทายมากกว่า'' การแก้คำพูดตรงนี้ถือว่าสำคัญ 
ซึ่งเราจะเห็นต่อไปในหัวข้อถัดไป เมื่อเราสำรวจวิธีการดีบั๊กในรายละเอียด 
แต่สิ่งที่สำคัญคือ ทั้งสองขั้นตอนของกระบวนการ (การค้นพบและแก้ไขปัญหา) 
มีแนวโน้มที่จะเกิดขึ้นอย่างรวดเร็ว</para>

<para>In Linus's Law, I think, lies the core difference underlying the
cathedral-builder and bazaar styles.  In the cathedral-builder view of
programming, bugs and development problems are tricky, insidious, deep
phenomena.  It takes months of scrutiny by a dedicated few to develop
confidence that you've winkled them all out.  Thus the long release
intervals, and the inevitable disappointment when long-awaited
releases are not perfect.</para>

<para>ผมคิดว่า ความแตกต่างของการพัฒนาแบบมหาวิหารและตลาดสด 
ก็อยู่ในกฎของไลนัสนี่แหละ ในมุมมองของนักพัฒนาแบบสร้างมหาวิหาร 
บั๊กและปัญหาในการพัฒนานั้นยาก มีเงื่อนงำ ลึกลับซับซ้อน 
ต้องใช้เวลานานนับเดือนในการตรวจสอบโดยทีมงานเล็กๆ 
เพื่อจะสร้างความมั่นใจว่าได้กำจัดบั๊กไปหมดแล้ว ดังนั้น 
จึงทำให้ระยะเวลาการออกรุ่นยาวนาน และมักจะเกิดความผิดหวัง 
เมื่อโปรแกรมรุ่นใหม่ที่รอคอยมาอย่างยาวนาน ทำงานไม่สมบูรณ์</para>

<para>In the bazaar view, on the other hand, you assume that bugs are
generally shallow phenomena&mdash;or, at least, that they turn shallow
pretty quickly when exposed to a thousand eager co-developers pounding on
every single new release.  Accordingly you release often in order to
get more corrections, and as a beneficial side effect you have less to
lose if an occasional botch gets out the door.</para>

<para>ในทางกลับกัน ในมุมมองแบบตลาดสด คุณจะถือว่าบั๊กเป็นเรื่องง่ายๆ 
หรืออย่างน้อยก็จะกลายเป็นเรื่องง่ายๆ อย่างรวดเร็ว 
เมื่อนักพัฒนาที่กระตือรือร้นนับพันช่วยกันกำจัดมันในโปรแกรมที่ออกมาทุกรุ่น 
ดังนั้นคุณจึงปล่อยโปรแกรมบ่อยๆ เพื่อที่บั๊กจะถูกกำจัดมากขึ้น 
และผลข้างเคียงที่ดีก็คือ คุณจะลดโอกาสเสียหายถ้ามีปัญหาหลุดออกไปจริงๆ</para>

<para>And that's it.  That's enough.  If ``Linus's Law'' is false,
then any system as complex as the Linux kernel, being hacked over by
as many hands as the that kernel was, should at some point have
collapsed under the weight of unforseen bad interactions and
undiscovered ``deep'' bugs.  If it's true, on the other hand, it is
sufficient to explain Linux's relative lack of bugginess and its
continuous uptimes spanning months or even years.</para>

<para>เท่านั้นแหละ เพียงพอแล้ว ถ้า ``กฎของไลนัส'' ผิดล่ะก็ ระบบที่ซับซ้อนมากๆ 
ขนาดเคอร์เนลลินุกซ์ ซึ่งถูกแฮ็กโดยคนจำนวนมากพอๆ กัน 
คงจะล้มเพราะการประสานงานที่ไม่ดี และเพราะบั๊ก ``ลึกลับ'' ที่ตรวจไม่พบ 
ในทางกลับกัน ถ้ามันถูกต้อง นี่ก็เพียงพอที่จะอธิบายได้ 
ว่าทำไมลินุกซ์จึงมีบั๊กน้อย และไม่ล่มเมื่อเปิดทิ้งไว้เป็นเดือนๆ 
หรือแม้แต่เป็นปีๆ</para>

<para>Maybe it shouldn't have been such a surprise, at that.
Sociologists years ago discovered that the averaged opinion of a mass
of equally expert (or equally ignorant) observers is quite a bit more
reliable a predictor than the opinion of a single randomly-chosen one of the
observers.  They called this the <firstterm>Delphi effect</firstterm>.
It appears that what Linus has shown is that this applies even to
debugging an operating system&mdash;that the Delphi effect can tame
development complexity even at the complexity level of an OS
kernel. <link linkend="CV">[CV]</link></para>

<para>สิ่งเหล่านี้อาจไม่น่าตื่นเต้นเท่าไรนัก หลายปีก่อน นักสังคมวิทยาพบว่า 
ความเห็นโดยเฉลี่ยของกลุ่มผู้เชี่ยวชาญที่มีระดับพอๆ กัน 
(หรือคนที่ไม่รู้อะไรเลยที่ระดับพอๆ กันก็ได้) 
จะมีความน่าเชื่อถือในการทำนายมากกว่าความเห็นของใครสักคนที่ถูกสุ่มมา 
พวกเขาเรียกสิ่งนี้ว่า <firstterm>ปรากฏการณ์เดลไฟ (Delphi Effect)</firstterm> 
ซึ่งปรากฏว่า ไลนัสได้แสดงให้เห็นว่า 
ปรากฏการณ์นี้ใช้ได้กับการดีบั๊กระบบปฏิบัติการด้วย กล่าวคือ 
ปรากฏการณ์เดลไฟสามารถจัดการกับความซับซ้อนของการพัฒนา 
แม้กับระดับความซับซ้อนขนาดเคอร์เนลของระบบปฏิบัติการ 
<link linkend="CV">[CV]</link></para>

<para>One special feature of the Linux situation that clearly helps
along the Delphi effect is the fact that the contributors for any
given project are self-selected.  An early respondent pointed out that
contributions are received not from a random sample, but from people
who are interested enough to use the software, learn about how it
works, attempt to find solutions to problems they encounter, and
actually produce an apparently reasonable fix.  Anyone who passes all
these filters is highly likely to have something useful to
contribute.</para>

<para>สิ่งพิเศษอย่างหนึ่งในเงื่อนไขของลินุกซ์ 
ที่ช่วยเสริมปรากฏการณ์เดลไฟเข้าไปอีก 
คือผู้ร่วมสมทบงานของแต่ละโครงการได้ผ่านการกลั่นกรองตัวเองมาแล้ว 
ผู้เข้าร่วมในช่วงแรกๆ ชี้ว่า การสมทบงานที่ได้รับ ไม่ได้มาแบบสุ่มเสี่ยง 
แต่มาจากผู้คนที่สนใจเพียงพอที่จะใช้ซอฟต์แวร์ เรียนรู้วิธีการทำงาน 
พยายามหาทางแก้ปัญหาที่พบ และลงมือสร้างแพตช์ที่เข้าท่า 
ใครก็ตามที่ผ่านการกลั่นกรองเหล่านี้มาได้ ก็มีแนวโน้มจะมีสิ่งดีๆ 
ที่จะร่วมสมทบ</para>

<para>Linus's Law can be rephrased as ``Debugging is parallelizable''.
Although debugging requires debuggers to communicate with some
coordinating developer, it doesn't require significant coordination
between debuggers.  Thus it doesn't fall prey to the same quadratic
complexity and management costs that make adding developers
problematic.</para>

<para>กฎของไลนัสสามารถกล่าวได้อีกแบบว่า ``การแก้บั๊กสามารถทำขนานกันได้'' 
(Debugging is parallelizable) 
ถึงแม้การแก้บั๊กจะจำเป็นต้องให้ผู้ตรวจบั๊กสื่อสารกับนักพัฒนาที่เป็นผู้ประสานงาน 
แต่บรรดาผู้ตรวจบั๊กด้วยกันเอง แทบไม่จำเป็นต้องประสานงานกันเลย ดังนั้น 
จึงไม่เพิ่มความซับซ้อนและค่าโสหุ้ยในการจัดการเป็นอัตรากำลังสองเหมือนการเพิ่มนักพัฒนา
</para>

<para>In practice, the theoretical loss of efficiency due to duplication of
work by debuggers almost never seems to be an issue in the Linux
world.  One effect of a ``release early and often'' policy is to
minimize such duplication by propagating fed-back fixes quickly
<link linkend="JH">[JH]</link>.</para>

<para>ในทางปฏิบัติ การสูญเสียประสิทธิภาพจากการทำงานซ้ำซ้อนของผู้ตรวจบั๊กนั้น 
แทบไม่เกิดกับโลกของลินุกซ์เลย ผลของนโยบาย ``ออกเนิ่นๆ ถี่ๆ'' 
ก็คือการลดความซ้ำซ้อนดังกล่าว โดยส่งทอดการแก้ไขต่างๆ 
ที่ตอบกลับมาออกไปสู่ชุมชนอย่างรวดเร็ว <link linkend="JH">[JH]</link></para>

<para>Brooks (the author of <citetitle>The Mythical
Man-Month</citetitle>) even made an off-hand observation related to
this: ``The total cost of maintaining a widely used program is
typically 40 percent or more of the cost of developing
it. Surprisingly this cost is strongly affected by the number of
users. <emphasis>More users find more bugs</emphasis>.'' [emphasis
added].</para>

<para>บรูกส์ (ผู้แต่ง <citetitle>The Mythical Man-Month</citetitle>) 
ได้ตั้งข้อสังเกตที่อาจจะเกี่ยวข้องกับเรื่องนี้ไว้ว่า 
``ต้นทุนในการดูแลรักษาโปรแกรมที่มีผู้ใช้แพร่หลาย มักจะมีค่าประมาณร้อยละ 40 
ของต้นทุนในการพัฒนา น่าสนใจตรงที่ต้นทุนนี้แปรผันกับจำนวนผู้ใช้ 
<emphasis>ยิ่งมีผู้ใช้มากก็เจอบั๊กมาก</emphasis>'' [เน้นข้อความเพิ่ม]</para>

<para>More users find more bugs because adding more users adds more
different ways of stressing the program.  This effect is amplified
when the users are co-developers.  Each one approaches the task
of bug characterization with a slightly different perceptual set
and analytical toolkit, a different angle on the problem.  The
``Delphi effect'' seems to work precisely because of this variation.
In the specific context of debugging, the variation also tends to
reduce duplication of effort.</para>

<para>มีผู้ใช้มากจะค้นพบบั๊กมากขึ้น เพราะเมื่อผู้ใช้เพิ่มขึ้น 
โอกาสที่จะทรมานโปรแกรมในรูปแบบต่างๆ กันก็เพิ่มขึ้น
และผลจะเพิ่มขึ้นอีกเมื่อผู้ใช้เป็นผู้ร่วมพัฒนาด้วย 
เพราะแต่ละคนจะมีวิธีตรวจบั๊กด้วยเครื่องมือวิเคราะห์ที่ต่างกัน 
และด้วยแง่มุมที่ต่างกัน ``ปรากฏการณ์เดลไฟ'' 
ดูจะให้ผลดีก็เพราะความหลากหลายของผู้ใช้นี่เอง ในแง่ของการค้นหาบั๊กแล้ว 
ความหลากหลายจะช่วยลดความซ้ำซ้อนลงไปได้</para>

<para>So adding more beta-testers may not reduce the complexity of the
current ``deepest'' bug from the <emphasis>developer's</emphasis>
point of view, but it increases the probability that someone's toolkit
will be matched to the problem in such a way that the bug is shallow
<emphasis>to that person</emphasis>.</para>

<para>ดังนั้น ในมุมมองของ<emphasis>นักพัฒนา</emphasis> 
การเพิ่มจำนวนผู้ทดสอบอาจจะไม่ช่วยลดความซับซ้อนของบั๊กยากๆ ลง 
แต่มันจะช่วยเพิ่มโอกาสที่เครื่องมือของใครสักคนจะตรงกับตัวปัญหา 
จนทำให้บั๊กดูง่าย<emphasis>สำหรับคนคนนั้น</emphasis></para>

<para>Linus coppers his bets, too.  In case there
<emphasis>are</emphasis> serious bugs, Linux kernel version are
numbered in such a way that potential users can make a choice either
to run the last version designated ``stable'' or to ride the cutting
edge and risk bugs in order to get new features.  This tactic is not
yet systematically imitated by most Linux hackers, but perhaps it should be;
the fact that either choice is available makes both more
attractive. <link linkend="HBS">[HBS]</link> </para>

<para>ไลนัสสนับสนุนความคิดนี้แน่นอน ในกรณีที่เกิดบั๊กร้ายแรง 
เลขรุ่นของเคอร์เนลลินุกซ์จะถูกกำหนดในลักษณะที่ผู้ใช้สามารถเลือกได้ 
ว่าจะใช้รุ่นเก่าที่ ``เสถียร'' หรือจะเสี่ยงใช้รุ่นใหม่ที่เสี่ยงต่อบั๊ก 
เพื่อจะได้ใช้ความสามารถใหม่ๆ 
วิธีการนี้แฮ็กเกอร์ลินุกซ์ส่วนมากยังไม่ได้ทำตามอย่างเป็นระบบ แต่ก็ควรจะทำ 
การมีทางเลือกทำให้ทั้งสองทางดูน่าสนใจขึ้น 
<link linkend="HBS">[HBS]</link></para>

</sect1>
<!-- How Many Eyeballs Tame Complexity -->
<sect1><title>ลูกตาเยอะขนาดไหนที่จะจัดการความซับซ้อนได้</title>

<para>It's one thing to observe in the large that the bazaar style
greatly accelerates debugging and code evolution.  It's another to
understand exactly how and why it does so at the micro-level of
day-to-day developer and tester behavior. In this section (written
three years after the original paper, using insights by developers
who read it and re-examined their own behavior) we'll take a
hard look at the actual mechanisms.  Non-technically inclined 
readers can safely skip to the next section.</para>

<para>การสังเกตในภาพรวม 
ว่ารูปแบบตลาดสดช่วยเร่งอัตราการแก้บั๊กและการวิวัฒนาการของโค้ด ก็เป็นส่วนหนึ่ง 
แต่ในอีกส่วนหนึ่ง เราก็ต้องเข้าใจด้วย 
ว่ามันทำงานอย่างไรและด้วยเหตุผลใดในระดับย่อยของพฤติกรรมประจำวันของนักพัฒนาและนักทดสอบ 
ในหัวข้อนี้ (ซึ่งเขียนขึ้นหลังจากบทความฉบับแรกสามปี 
โดยใช้ข้อมูลเชิงลึกจากนักพัฒนาที่ได้อ่านบทความและสำรวจพฤติกรรมของตน) 
เราจะพิจารณาโดยละเอียดเกี่ยวกับกลไกที่เกิดขึ้นจริง 
ผู้อ่านที่ไม่มีพื้นฐานทางเทคนิคอาจข้ามหัวข้อนี้ไปได้</para>

<para>One key to understanding is to realize exactly why it is that
the kind of bug report non&ndash;source-aware users normally turn in
tends not to be very useful.  Non&ndash;source-aware users tend to report
only surface symptoms; they take their environment for granted, so
they (a) omit critical background data, and (b) seldom include a
reliable recipe for reproducing the bug.</para>

<para>ประเด็นสำคัญที่จะเข้าใจเรื่องนี้ คือการตระหนัก 
ว่าทำไมรายงานบั๊กจากผู้ใช้ที่ไม่สนใจซอร์สมักจะไม่ค่อยมีประโยชน์นัก 
ผู้ใช้ที่ไม่สนใจซอร์สมักจะรายงานแค่อาการผิวเผิน โดยถือว่าสภาพแวดล้อมของเขาปกติ 
ดังนั้นเขาจึง (ก) ละเลยข้อมูลประกอบที่สำคัญ 
(ข) ไม่ค่อยจะบอกวิธีการที่แน่นอนในการทำให้เกิดบั๊กซ้ำ</para>

<para>The underlying problem here is a mismatch between the tester's
and the developer's mental models of the program; the tester, on the
outside looking in, and the developer on the inside looking out.
In closed-source development they're both stuck in these roles, and 
tend to talk past each other and find each other deeply frustrating.</para>

<para>ปัญหาของเรื่องนี้ 
ก็คือความไม่เข้ากันของมโนภาพเกี่ยวกับโปรแกรมของผู้ทดสอบและของผู้พัฒนา 
ผู้ทดสอบมองจากข้างนอกเข้ามาข้างใน แต่ผู้พัฒนามองจากข้างในออกข้างนอก 
ในการพัฒนาแบบซอร์สปิด ทั้งสองฝ่ายจะติดแหง็กอยู่กับบทบาททั้งสองนี้ 
และดูจะคุยกันไม่เข้าใจ รู้สึกว่าอีกฝ่ายน่ารำคาญ</para>

<para>Open-source development breaks this bind, making it far easier
for tester and developer to develop a shared representation grounded
in the actual source code and to communicate effectively about it.
Practically, there is a huge difference in leverage for the developer
between the kind of bug report that just reports externally-visible
symptoms and the kind that hooks directly to the developer's
source-code&ndash;based mental representation of the program.</para>

<para>การพัฒนาแบบโอเพนซอร์สทำลายพันธะดังกล่าวเสีย 
ทำให้ง่ายต่อผู้ทดสอบและผู้พัฒนาที่จะมองภาพร่วมกัน บนพื้นฐานของซอร์สโค้ดจริง 
และสื่อสารเข้าใจกัน ในทางปฏิบัติแล้ว มีความแตกต่างอย่างมากสำหรับนักพัฒนา 
ระหว่างรายงานบั๊กที่รายงานแค่อาการภายนอก 
กับที่พุ่งตรงไปยังเค้าโครงที่มีพื้นฐานจากซอร์สโค้ดของโปรแกรมเอง</para>

<para>Most bugs, most of the time, are easily nailed given even an
incomplete but suggestive characterization of their error conditions
at source-code level.  When someone among your beta-testers can point
out, "there's a boundary problem in line nnn", or even just "under
conditions X, Y, and Z, this variable rolls over", a quick look at the
offending code often suffices to pin down the exact mode of failure
and generate a fix.</para>

<para>แทบทุกครั้ง 
บั๊กจะแก้ง่ายถ้าบรรยายอาการของเงื่อนไขข้อผิดพลาดได้ในระดับซอร์สโค้ด 
แม้จะไม่สมบูรณ์ก็ตาม เมื่อผู้ทดสอบบางคนของคุณสามารถชี้ได้ว่า 
"มีปัญหาเรื่องค่าล้นที่บรรทัด nnn" หรือแม้เพียงแค่ "ภายใต้เงื่อนไข X, Y และ Z 
ตัวแปรนี้จะตีกลับ" แค่มองที่โค้ดที่มีปัญหาอย่างคร่าวๆ 
ก็มักเพียงพอที่จะบ่งชี้ชนิดของข้อผิดพลาด และแก้ไขได้ทันที</para>

<para>Thus, source-code awareness by both parties greatly enhances
both good communication and the synergy between what a beta-tester
reports and what the core developer(s) know.  In turn, this means that
the core developers' time tends to be well conserved, even with many
collaborators.</para>

<para>ดังนั้น การใช้ซอร์สโค้ดทั้งสองฝ่ายจึงช่วยเพิ่มทั้งการสื่อสาร 
และการเสริมแรงกันระหว่างสิ่งที่ผู้ทดสอบรายงานกับสิ่งที่ผู้พัฒนาหลักรู้ ผลก็คือ 
มีแนวโน้มจะช่วยประหยัดเวลานักพัฒนาหลักได้ดี แม้จะต้องประสานงานหลายฝ่าย</para>

<para>Another characteristic of the open-source method that conserves
developer time is the communication structure of typical open-source
projects.  Above I used the term "core developer"; this reflects a
distinction between the project core (typically quite small; a single
core developer is common, and one to three is typical) and the project
halo of beta-testers and available contributors (which often numbers
in the hundreds).</para>

<para>คุณลักษณ์อีกประการหนึ่งของวิธีการโอเพนซอร์สที่ช่วยประหยัดเวลานักพัฒนา 
ก็คือโครงสร้างของการสื่อสารของโครงการโอเพนซอร์สทั่วไป ในย่อหน้าก่อน ผมใช้คำว่า 
"นักพัฒนาหลัก" ซึ่งสะท้อนถึงความแตกต่างระหว่างแกนของโครงการ 
(ซึ่งมักจะเป็นกลุ่มเล็กๆ การมีนักพัฒนาหลักแค่คนเดียวถือเป็นเรื่องปกติ 
และหนึ่งถึงสามคนถือว่าธรรมดา) กับนักทดสอบและผู้ร่วมสมทบที่รายล้อม 
(ซึ่งมักมีจำนวนหลักร้อย)</para>

<para>The fundamental problem that traditional software-development 
organization addresses is Brook's Law: ``Adding more programmers to a
late project makes it later.''  More generally, Brooks's Law predicts
that the complexity and communication costs of a project rise with the
square of the number of developers, while work done only rises
linearly.</para>

<para>ปัญหาพื้นฐานที่องค์กรพัฒนาซอฟต์แวร์แบบดั้งเดิมพยายามแก้ ก็คือกฎของบรูกส์: 
``การเพิ่มโปรแกรมเมอร์ในโครงการที่ล่าช้า จะทำให้เพิ่มความล้าช้าขึ้นไปอีก'' 
หรือกล่าวในรูปทั่วไป กฎของบรูกส์ทำนายว่า 
ความซับซ้อนและต้นทุนการสื่อสารของโครงการ 
จะเพิ่มในอัตรากำลังสองของจำนวนนักพัฒนา 
ในขณะที่งานที่ได้จะเพิ่มในแบบเชิงเส้น</para>

<para>Brooks's Law is founded on experience that bugs tend strongly to
cluster at the interfaces between code written by different people,
and that communications/coordination overhead on a project tends to
rise with the number of interfaces between human beings.  Thus,
problems scale with the number of communications paths between
developers, which scales as the square of the humber of developers
(more precisely, according to the formula N*(N - 1)/2 where N is the
number of developers).</para>

<para>กฎของบรูกส์สร้างขึ้นบนพื้นฐานของประสบการณ์ที่ว่า บั๊กต่างๆ 
มีแนวโน้มที่จะหนีไม่พ้นเรื่องการเชื่อมต่อระหว่างโค้ดที่เขียนโดยคนกลุ่มต่างๆ 
และค่าโสหุ้ยในการสื่อสาร/ประสานงานกันในโครงการ 
ก็มีแนวโน้มจะเพิ่มตามจำนวนการเชื่อมโยงระหว่างมนุษย์ ดังนั้น 
ขนาดของปัญหาจึงโตตามจำนวนช่องทางสื่อสารระหว่างนักพัฒนา 
ซึ่งแปรผันตรงกับกำลังสองของจำนวนนักพัฒนา (หรือพูดให้ละเอียดกว่านั้น 
คือเป็นไปตามสูตร N*(N - 1)/2 เมื่อ N คือจำนวนนักพัฒนา)</para>

<para>The Brooks's Law analysis (and the resulting fear of large
numbers in development groups) rests on a hidden assummption: that the
communications structure of the project is necessarily a complete
graph, that everybody talks to everybody else.  But on open-source
projects, the halo developers work on what are in effect separable
parallel subtasks and interact with each other very little; code
changes and bug reports stream through the core group, and only
<emphasis>within</emphasis> that small core group do we pay the full
Brooksian overhead. <link linkend="SU">[SU]</link> </para>

<para>การวิเคราะห์ตามกฎของบรูกส์ (และความกลัวจำนวนนักพัฒนามากๆ 
ในทีมพัฒนาที่เป็นผลตามมา) ตั้งอยู่บนข้อสมมุติที่ซ่อนอยู่ 
คือโครงสร้างการสื่อสารของโครงการ จะต้องเป็นกราฟสมบูรณ์ (complete graph) เสมอไป 
กล่าวคือ ทุกคนจะพูดกับคนอื่นๆ ทุกคน แต่ในโครงการโอเพนซอร์ส 
นักพัฒนารอบนอกต่างทำงานกับสิ่งที่กลายเป็นงานย่อยที่แบ่งทำขนานกันได้ 
และมีปฏิสัมพันธ์กันเองน้อยมาก 
การแก้ไขโค้ดและรายงานบั๊กต่างส่งเข้าสู่ทีมพัฒนาหลัก และค่าโสหุ้ยตามกฎของบรูกส์ 
ก็จะเกิดกับเฉพาะ <emphasis>ภายใน</emphasis> กลุ่มนักพัฒนาหลักกลุ่มเล็กๆ 
นี้เท่านั้น <link linkend="SU">[SU]</link></para>

<para>There are are still more reasons that source-code&ndash;level bug
reporting tends to be very efficient.  They center around the fact
that a single error can often have multiple possible symptoms,
manifesting differently depending on details of the user's usage
pattern and environment. Such errors tend to be exactly the sort of
complex and subtle bugs (such as dynamic-memory-management errors or
nondeterministic interrupt-window artifacts) that are hardest to
reproduce at will or to pin down by static analysis, and which do the
most to create long-term problems in software.</para>

<para>ยังมีเหตุผลเพิ่มเติม 
ที่ทำให้การรายงานบั๊กในระดับซอร์สโค้ดมีแนวโน้มจะมีประสิทธิภาพมาก 
เนื่องจากบ่อยครั้งที่ข้อผิดพลาดเดียวสามารถแสดงอาการได้หลายแบบ 
โดยขึ้นอยู่กับรายละเอียดของรูปแบบและสภาพแวดล้อมการใช้งานของผู้ใช้ 
ข้อผิดพลาดดังกล่าวมีแนวโน้มที่จะเป็นบั๊กชนิดที่ซับซ้อนและละเอียดอ่อน (เช่น 
ข้อผิดพลาดในการจัดการหน่วยความจำแบบพลวัต 
หรือมีช่วงว่างระหว่างการขัดจังหวะที่ไม่แน่นอน) 
ที่ทำให้เกิดซ้ำตามต้องการหรือชี้ชัดด้วยการวิเคราะห์แบบตายตัวได้ยากที่สุด 
และเป็นบั๊กที่สร้างปัญหาให้กับซอฟต์แวร์ในระยะยาวได้มากที่สุด</para>

<para>A tester who sends in a tentative source-code&ndash;level
characterization of such a multi-symptom bug (e.g. "It looks to me
like there's a window in the signal handling near line 1250" or "Where
are you zeroing that buffer?") may give a developer, otherwise too
close to the code to see it, the critical clue to a half-dozen
disparate symptoms.  In cases like this, it may be hard or even
impossible to know which externally-visible misbehaviour was caused by
precisely which bug&mdash;but with frequent releases, it's unnecessary to
know.  Other collaborators will be likely to find out quickly whether
their bug has been fixed or not. In many cases, source-level bug
reports will cause misbehaviours to drop out without ever having been
attributed to any specific fix.</para>

<para>นักทดสอบที่ส่งรายงานสิ่งที่อาจเป็นบั๊กที่แสดงอาการหลายแบบดังกล่าว 
โดยรายงานในระดับซอร์สโค้ด (เช่น 
"ผมคิดว่ามันมีช่วงว่างระหว่างการจัดการสัญญาณแถวๆ บรรทัดที่ 1250" หรือ 
"คุณเติมค่าศูนย์ในบัฟเฟอร์นั้นตรงไหนหรือ?") 
อาจกำลังให้ข้อมูลที่สำคัญยิ่งยวดสำหรับแก้อาการหลายอาการต่อผู้พัฒนาซึ่งอาจอยู่ใกล้โค้ดเกินกว่าจะเห็นได้ 
ซึ่งในกรณีเช่นนั้น อาจจะยากหรือเป็นไปไม่ได้เลย 
ที่จะรู้ว่าอาการผิดปกติอันไหนเกิดจากบั๊กไหน แต่ด้วยการออกบ่อยๆ 
ก็แทบไม่จำเป็นต้องรู้เลย คนอื่นๆ อาจจะพบอย่างรวดเร็ว 
ว่าบั๊กของเขาได้รับการแก้ไขหรือยัง ในหลายๆ กรณี 
รายงานบั๊กในระดับซอร์สโค้ดจะทำให้อาการผิดปกติหลายอย่างหายไป 
โดยไม่ได้ชี้ชัดถึงวิธีที่แก้ไขเลย</para>

<para>Complex multi-symptom errors also tend to have multiple trace
paths from surface symptoms back to the actual bug.  Which of the
trace paths a given developer or tester can chase may depend on
subtleties of that person's environment, and may well change in a
not obviously deterministic way over time.  In effect, each developer
and tester samples a semi-random set of the program's state space when
looking for the etiology of a symptom.  The more subtle and complex the
bug, the less likely that skill will be able to guarantee the
relevance of that sample.</para>

<para>ข้อผิดพลาดที่ซับซ้อนและแสดงหลายอาการ 
ยังมีแนวโน้มจะมีหลายทางที่จะไล่ไปสู่บั๊กที่แท้จริง 
ทางไหนที่ผู้พัฒนาหรือผู้ทดสอบคนหนึ่งๆ จะสามารถไล่ไปได้ 
ก็ขึ้นอยู่กับรายละเอียดปลีกย่อยของสภาพแวดล้อมของบุคคลนั้น 
และอาจกลายเป็นทางที่แน่นอนชัดเจนได้ในภายหลัง ผลก็คือ 
นักพัฒนาและผู้ทดสอบแต่ละคนจะช่วยสุ่มตัวอย่างสถานะของโปรแกรมแบบต่างๆ 
ขณะหาสมุฏฐานของอาการ ยิ่งบั๊กละเอียดอ่อนและซับซ้อนเท่าใด 
ความชำนาญโดยลำพังก็ช่วยเชื่อมโยงได้น้อยเท่านั้น</para>

<para>For simple and easily reproducible bugs, then, the accent will
be on the "semi" rather than the "random"; debugging skill and
intimacy with the code and its architecture will matter a lot.  But
for complex bugs, the accent will be on the "random".  Under these
circumstances many people running traces will be much more effective
than a few people running traces sequentially&mdash;even if the few have
a much higher average skill level.</para>

<para>สำหรับบั๊กที่ง่ายและทำซ้ำได้ การสุ่มตัวอย่างก็ไม่จำเป็นนัก 
ความชำนาญในการตรวจบั๊กและความคุ้นเคยกับโค้ดและโครงสร้างโปรแกรมจะช่วยได้มาก 
แต่สำหรับบั๊กที่ซับซ้อนแล้ว ก็ต้องอาศัยการสุ่มตัวอย่างช่วย ในสภาวะดังกล่าว 
การมีผู้แกะรอยจากหลายเส้นทางจะได้ผลกว่าการใช้ไม่กี่คนแกะรอยทีละทาง 
แม้ว่าไม่กี่คนที่ว่านั้นจะมีความชำนาญโดยเฉลี่ยสูงกว่าก็ตาม</para>

<para>This effect will be greatly amplified if the difficulty of
following trace paths from different surface symptoms back to a bug
varies significantly in a way that can't be predicted by looking at
the symptoms.  A single developer sampling those paths sequentially
will be as likely to pick a difficult trace path on the first try as
an easy one. On the other hand, suppose many people are trying trace
paths in parallel while doing rapid releases.  Then it is likely one
of them will find the easiest path immediately, and nail the bug in a
much shorter time.  The project maintainer will see that, ship a new
release, and the other people running traces on the same bug will be
able to stop before having spent too much time on their more difficult
traces <link linkend="RJ">[RJ]</link>.</para>

<para>ผลของเรื่องนี้จะใหญ่โตมาก ถ้าความยากของการแกะรอยแบบต่างๆ 
จากอาการเพื่อหาบั๊กนั้น แตกต่างกันมากจนไม่สามารถทำนายได้จากอาการ 
นักพัฒนาเพียงคนเดียวที่ทดลองแกะรอยทีละแบบจะมีโอกาสที่จะเลือกแบบที่ยากก่อนพอๆ 
กับที่จะเลือกแบบที่ง่ายก่อน ในทางกลับกัน สมมุติว่ามีหลายคนลองแกะรอยพร้อมๆ 
กันขณะที่จะออกรุ่นอย่างกระชั้นชิด ก็มีโอกาสที่จะมีบางคนพบทางที่ง่ายที่สุดทันที 
และแก้บั๊กได้ในเวลาอันสั้น ผู้ดูแลโครงการจะเห็น แล้วก็ออกรุ่นใหม่ และคนอื่นๆ 
ที่กำลังแกะรอยบั๊กเดียวกันก็สามารถจะหยุดได้ 
ก่อนที่จะใช้เวลากับการแกะรอยแบบที่ยากนั้นนานเกินไป 
<link linkend="RJ">[RJ]</link></para>

</sect1>
<!-- When Is a Rose Not a Rose? -->
<sect1><title>เมื่อใดที่กุหลาบจะไม่เป็นกุหลาบ?</title>

<para>Having studied Linus's behavior and formed a theory about why it
was successful, I made a conscious decision to test this theory on my
new (admittedly much less complex and ambitious) project.</para>

<para>เมื่อได้ศึกษาวิธีการของไลนัส และสร้างทฤษฎีว่ามันสำเร็จได้อย่างไรแล้ว 
ผมได้ตัดสินใจที่จะทดสอบทฤษฎีนี้กับโครงการของผมเอง 
(ที่ต้องยอมรับว่าซับซ้อนน้อยกว่าและทะเยอทะยานน้อยกว่ามาก)</para>

<para>But the first thing I did was reorganize and simplify popclient
a lot.  Carl Harris's implementation was very sound, but exhibited a
kind of unnecessary complexity common to many C programmers.  He
treated the code as central and the data structures as support for the
code.  As a result, the code was beautiful but the data structure
design ad-hoc and rather ugly (at least by the high standards of this
veteran LISP hacker).</para>

<para>แต่สิ่งแรกที่ผมทำ คือการปรับ popclient ให้ลดความซับซ้อนลง งานของคาร์ล 
แฮรริส นั้นดูดี แต่ก็ได้สร้างความซับซ้อนที่ไม่จำเป็น 
ตามแบบที่โปรแกรมเมอร์ภาษาซีหลายคนชอบทำ เขามองตัวโค้ดเป็นศูนย์กลาง 
และโครงสร้างข้อมูลเป็นส่วนสนับสนุนของโค้ด ผลก็คือ โค้ดนั้นสวยงามดี 
แต่โครงสร้างข้อมูลออกแบบตามอำเภอใจและค่อนข้างแย่ 
(อย่างน้อยก็แย่ตามมาตรฐานที่สูงอยู่แล้วของแฮ็กเกอร์ LISP มือฉมังคนนี้)</para>

<para>I had another purpose for rewriting besides improving the code and the
data structure design, however.  That was to evolve it into something
I understood completely.  It's no fun to be responsible for fixing
bugs in a program you don't understand.</para>

<para>อย่างไรก็ดี ผมมีอีกจุดประสงค์หนึ่งในการเขียนใหม่ 
นอกจากการปรับปรุงโค้ดและโครงสร้างข้อมูล 
นั่นคือการปรับโปรแกรมให้กลายเป็นสิ่งที่ผมเข้าใจได้ทั้งหมด 
มันไม่สนุกเลยในการรับผิดชอบแก้บั๊กของโปรแกรมที่คุณไม่เข้าใจ</para>

<para>For the first month or so, then, I was simply following out the
implications of Carl's basic design.  The first serious change I made
was to add IMAP support.  I did this by reorganizing the protocol
machines into a generic driver and three method tables (for POP2,
POP3, and IMAP).  This and the previous changes illustrate a general
principle that's good for programmers to keep in mind, especially
in languages like C that don't naturally do dynamic typing:</para>

<para>ในราวเดือนแรก ผมทำตามแนวทางที่คาร์ลออกแบบไว้ 
ความเปลี่ยนแปลงที่สำคัญอย่างแรกที่ผมทำ คือเพิ่มการสนับสนุน IMAP 
ผมทำโดยการจัดระบบโพรโทคอลใหม่ให้เป็นไดรเวอร์ทั่วไปหนึ่งตัว 
และตารางวิธีการสามอัน (สำหรับ POP2, POP3 และ IMAP) 
การเปลี่ยนแปลงทั้งครั้งนี้และครั้งก่อน 
แสดงให้เห็นหลักการทั่วไปที่โปรแกรมเมอร์ควรจำให้ขึ้นใจ โดยเฉพาะสำหรับภาษาอย่างซี 
ซึ่งไม่ได้สนับสนุนชนิดข้อมูลแบบพลวัต นั่นคือ:</para>

<blockquote><para>9. Smart data structures and dumb code works a lot
       better than the other way around.</para></blockquote>

<blockquote><para>9. โครงสร้างข้อมูลที่ฉลาดกับโค้ดที่โง่ 
       ทำงานได้ดีกว่าในทางกลับกัน</para></blockquote>

<para>Brooks, Chapter 9: ``Show me your flowchart and conceal your
tables, and I shall continue to be mystified.  Show me your tables,
and I won't usually need your flowchart; it'll be obvious.''  Allowing
for thirty years of terminological/cultural shift, it's the same
point.</para>

<para>บรูกส์, บทที่ 9 : ``ให้ผมดูโฟลว์ชาร์ตของคุณ แล้วปิดตารางของคุณไว้ 
ผมก็ยังจะงงต่อไป แต่ถ้าให้ผมดูตารางของคุณ ผมแทบไม่ต้อดูโฟลว์ชาร์ตของคุณเลย 
ทุกอย่างชัดเจน'' 
เมื่อพิจารณาเวลาสามสิบปีของการเปลี่ยนแปลงของคำศัพท์และยุคสมัยแล้ว 
ประเด็นก็ยังเหมือนเดิม</para>

<para>At this point (early September 1996, about six weeks from zero)
I started thinking that a name change might be in order&mdash;after all,
it wasn't just a POP client any more.  But I hesitated, because there
was as yet nothing genuinely new in the design.  My version of
popclient had yet to develop an identity of its own.</para>

<para>ณ จุดนี้ (ต้นเดือนกันยา 1996 ทำมาแล้วประมาณ 6 อาทิตย์) 
ผมเริ่มคิดจะเปลี่ยนชื่อโครงการแล้ว เพราะมันไม่ใช่แค่โปรแกรมสำหรับ POP 
อีกต่อไป แต่ผมยังไม่แน่ใจ เพราะมันยังไม่มีอะไรใหม่จริงๆ ในด้านการออกแบบ 
popclient รุ่นของผมยังไม่ได้พัฒนาเอกลักษณ์เป็นของตัวเองเลย</para>

<para>That changed, radically, when popclient learned how to forward fetched
mail to the SMTP port.  I'll get to that in a moment.  But first: I
said earlier that I'd decided to use this project to test my theory
about what Linus Torvalds had done right.  How (you may well ask) did
I do that?  In these ways:</para>

<para>แต่เงื่อนไขนั้นก็ได้เปลี่ยนไปอย่างมาก เมื่อ popclient 
เริ่มจะส่งเมลต่อไปยังพอร์ต SMTP ได้ ผมจะกลับมาพูดถึงเรื่องนี้อีกที แต่ก่อนอื่น 
ผมพูดไว้ก่อนหน้านี้ว่า ผมตั้งใจจะใช้โครงการนี้พิสูจน์ทฤษฎีของผมเกี่ยวกับสิ่งที่ 
ไลนัส ทอร์วัลด์ ทำ คุณอาจจะถามว่า ผมทำอย่างไรบ้าง? ผมทำอย่างนี้:</para>

<itemizedlist>
<listitem><para>I released early and often (almost never less often
      than every ten days; during periods of intense development, once
      a day).</para></listitem>

<listitem><para>ผมออกเนิ่นๆ และถี่ๆ (แทบจะไม่เคยทิ้งช่วงเกินสิบวัน 
      และถ้าเป็นช่วงที่มีการพัฒนาแบบเข้มข้น ผมออกทุกวัน)</para></listitem>

<listitem><para>I grew my beta list by adding to it everyone who contacted me
      about fetchmail.</para></listitem>

<listitem><para>ผมเพิ่มรายชื่อผู้ทดสอบโดยใส่ชื่อทุกคนที่คุยกับผมเรื่อง fetchmail
      </para></listitem>

<listitem><para>I sent chatty announcements to the beta list whenever I
      released, encouraging people to participate.</para></listitem>

<listitem><para>ผมประกาศแบบเป็นกันเองไปยังผู้ทดสอบทุกคนเมื่อออก 
      กระตุ้นให้ผู้คนมีส่วนร่วม</para></listitem>

<listitem><para>And I listened to my beta-testers, polling them about design
      decisions and stroking them whenever they sent in patches
      and feedback.</para></listitem>

<listitem><para>และผมฟังผู้ทดสอบเบต้า ขอความเห็นเกี่ยวกับการออกแบบ 
      และขอบคุณเมื่อเขาส่งแพตช์ และความคิดเห็นมาให้</para></listitem>
</itemizedlist>

<para>The payoff from these simple measures was immediate.  From the
beginning of the project, I got bug reports of a quality most
developers would kill for, often with good fixes attached.  I
got thoughtful criticism, I got fan mail, I got intelligent
feature suggestions.  Which leads to:</para>

<para>ผลลัพธ์จากมาตรการง่ายๆ เหล่านี้เห็นได้รวดเร็ว ตั้งแต่เริ่มโครงการ 
ผมได้รับการรายงานบั๊กที่มีคุณภาพระดับที่นักพัฒนาอยากได้ใจจะขาด 
และบ่อยครั้งที่มีวิธีแก้มาให้ด้วย ผมได้รับคำวิจารณ์ที่ให้แนวคิดที่ดี 
ได้รับเมลจากแฟนๆ ได้รับคำแนะนำคุณสมบัติใหม่ๆ ซึ่งนำไปสู่:</para>

<blockquote><para>10. If you treat your beta-testers as if they're
        your most valuable resource, they will respond by becoming
        your most valuable resource.</para></blockquote>

<blockquote><para>10. ถ้าคุณปฏิบัติกับผู้ทดสอบรุ่นเบต้า 
        เหมือนกับเป็นแหล่งทรัพยากรชั้นเยี่ยมแล้ว 
        เขาจะตอบแทนด้วยการเป็นทรัพยากรชั้นเยี่ยมให้</para></blockquote>

<para>One interesting measure of fetchmail's success is the sheer size
of the project beta list, fetchmail-friends.  At the time of latest
revision of this paper (November 2000) it has 287 members and is
adding two or three a week.</para>

<para>ดัชนีชี้วัดความสำเร็จของ fetchmail ที่น่าสนใจอย่างหนึ่ง 
คือขนาดของเมลลิงลิสต์ fetchmail-friends ของผู้ทดสอบเบต้าของโครงการ 
ขณะที่แก้ไขปรับปรุงบทความนี้รุ่นล่าสุด (พฤศจิกายน 2000) มีสมาชิกถึง 287 คน 
และเพิ่มขึ้น 2-3 คนทุกสัปดาห์</para>

<para>Actually, when I revised in late May 1997 I found the list was
beginning to lose members from its high of close to 300 for an
interesting reason.  Several people have asked me to unsubscribe them
because fetchmail is working so well for them that they no longer need
to see the list traffic!  Perhaps this is part of the normal
life-cycle of a mature bazaar-style project.</para>

<para>ความจริงแล้ว ตั้งแต่ผมเริ่มแก้ไขปรับปรุงบทความในปลายเดือนพฤษภาคม 1997 
ผมพบว่าคนในรายชื่อเริ่มจะลดจำนวนลงจากเกือบ 300 คนในตอนแรก ด้วยเหตุผลที่น่าสนใจ 
คือ หลายๆ คนได้ขอให้ผมเอาชื่อเขาออก เพราะ fetchmail ทำงานได้ดีแล้ว 
จนพวกเขาไม่ต้องการมีส่วนร่วมในการสนทนาอีก บางที 
นี่อาจจะเป็นส่วนหนึ่งในวงจรชีวิตของโครงการแบบตลาดสดที่โตเต็มที่แล้วก็ได้</para>

</sect1>
<!-- Popclient becomes Fetchmail -->
<sect1><title>จาก Popclient สู่ Fetchmail</title>

<para>The real turning point in the project was when Harry Hochheiser
sent me his scratch code for forwarding mail to the client machine's
SMTP port.  I realized almost immediately that a reliable
implementation of this feature would make all the other mail delivery
modes next to obsolete.</para>

<para>จุดเปลี่ยนที่แท้จริงของโครงการ เกิดขึ้นเมื่อ Harry Hochheiser 
ส่งร่างโค้ดของเขาสำหรับการส่งเมลต่อไปยังพอร์ต SMTP ของเครื่องลูกข่ายมาให้ผม 
ผมรู้ทันทีว่าความสามารถนี้ถ้าทำงานได้จริงอย่างเชื่อถือได้แล้ว 
จะทำให้วิธีกระจายเมลแบบอื่นๆ เตรียมม้วนเสื่อไปได้เลย</para>

<para>For many weeks I had been tweaking fetchmail rather
incrementally while feeling like the interface design was serviceable
but grubby&mdash;inelegant and with too many exiguous options hanging out
all over.  The options to dump fetched mail to a mailbox file or
standard output particularly bothered me, but I couldn't figure out
why.</para>

<para>เป็นเวลาหลายสัปดาห์ ที่ผมได้ปรับปรุงต่อเติม fetchmail 
โดยรู้สึกว่าส่วนติดต่อนั้นทำงานได้ดี แต่ดูรกรุงรัง 
ไม่สวยและมีตัวเลือกหยุมหยิมเต็มไปหมด 
ผมรำคาญตัวเลือกที่ให้โยนเมลที่ดึงมาไปลงแฟ้ม mailbox หรือเอาต์พุตมาตรฐาน 
แต่ก็ไม่รู้เหมือนกันว่าทำไม</para>

<para>(If you don't care about the technicalia of Internet mail, the
next two paragraphs can be safely skipped.)</para>

<para>(ถ้าคุณไม่สนเรื่องทางเทคนิคของการส่งเมลในอินเทอร์เน็ต 
ก็อ่านข้ามสองย่อหน้าถัดไปนี้ได้เลย)</para>

<para>What I saw when I thought about SMTP forwarding was that popclient had
been trying to do too many things.  It had been designed to be both a
mail transport agent (MTA) and a local delivery agent (MDA).  With
SMTP forwarding, it could get out of the MDA business and be a pure
MTA, handing off mail to other programs for local delivery just as
sendmail does.</para>

<para>สิ่งที่ผมเห็นเมื่อคิดถึงการส่งเมลต่อไปยัง SMTP ก็คือ popclient 
นั้นพยายามทำงานหลายอย่างเกินไป มันถูกออกแบบให้เป็นทั้งโปรแกรมจัดส่งเมลภายนอก 
(mail transport agent &ndash; MTA) และโปรแกรมกระจายเมลภายในเครื่อง (local 
delivery agent &ndash; MDA) เมื่อมีความสามารถในการส่งเมลต่อไปยัง SMTP แล้ว 
มันก็ควรจะเลิกทำตัวเป็น MDA และเป็นเพียง MTA เพียงอย่างเดียว 
แล้วโอนหน้าที่ในการกระจายเมลในเครื่องไปให้โปรแกรมอื่น เหมือนกับที่ sendmail 
ทำอยู่</para>

<para>Why mess with all the complexity of configuring a mail delivery agent
or setting up lock-and-append on a mailbox when port 25 is almost
guaranteed to be there on any platform with TCP/IP support in the
first place?  Especially when this means retrieved mail is guaranteed
to look like normal sender-initiated SMTP mail, which is really what
we want anyway.</para>

<para>ทำไมต้องไปยุ่งกับรายละเอียดในการตั้งค่าการกระจายเมล 
หรือการล็อคกล่องเมลก่อนเขียนต่อท้าย ในเมื่อแทบจะแน่ใจได้ว่ามีพอร์ต 25 
ให้ใช้ในทุกแพล็ตฟอร์มที่สนับสนุน TCP/IP อยู่แล้ว? โดยเฉพาะอย่างยิ่ง 
เมื่อการใช้พอร์ตดังกล่าวยังรับประกันได้ว่าจะทำให้เมลที่ดึงมานั้น ดูเหมือนเมล 
SMTP ปกติที่รับมาจากผู้ส่งโดยตรง ซึ่งเป็นสิ่งที่เราต้องการจริงๆ อยู่แล้ว</para>

<para>(Back to a higher level....)</para>

<para>(กลับสู่เรื่องเดิม...)</para>

<para>Even if you didn't follow the preceding technical jargon, there are
several important lessons here.  First, this SMTP-forwarding concept
was the biggest single payoff I got from consciously trying to emulate
Linus's methods.  A user gave me this terrific idea&mdash;all I had to do
was understand the implications.</para>

<para>ถึงแม้คุณจะไม่ได้ติดตามศัพท์แสงทางเทคนิคในย่อหน้าก่อน 
แต่ก็ยังมีบทเรียนที่สำคัญหลายบทสำหรับเรื่องนี้ สิ่งแรกก็คือ การส่งเมลต่อไปยัง 
SMTP เป็นผลลัพธ์ที่ดีที่สุดที่ผมได้รับจากการเลียนแบบวิธีพัฒนาของไลนัสอย่างจงใจ 
ผู้ใช้คนหนึ่งได้ให้แนวคิดสุดยอดอันนี้ 
สิ่งที่ผมต้องทำคือเข้าใจความหมายและสิ่งที่จะตามมา</para>

<blockquote><para>11. The next best thing to having good ideas is
        recognizing good ideas from your users.  Sometimes the latter
        is better.</para></blockquote>

<blockquote><para>11. สิ่งที่ดีที่สุดรองจากการมีแนวคิดดีๆ 
        ก็คือการตระหนักถึงแนวคิดที่ดีจากผู้ใช้ของคุณ บางครั้ง 
        การตระหนักดังกล่าวก็ถือว่าสำคัญกว่า</para></blockquote>

<para>Interestingly enough, you will quickly find that if you are completely
and self-deprecatingly truthful about how much you owe other people,
the world at large will treat you as though you did every bit of the
invention yourself and are just being becomingly modest about your
innate genius.  We can all see how well this worked for Linus! </para>

<para>สิ่งที่น่าสนใจตามมาคือ คุณจะค้นพบอย่างรวดเร็ว 
ว่าถ้าคุณซื่อสัตย์กับการบอกว่าได้แนวคิดมาจากผู้ใช้มากเท่าไร 
โลกภายนอกยิ่งจะมองว่าคุณเป็นคนสร้างสิ่งนั้นขึ้นมาเองทุกกระเบียดนิ้ว 
และมองคุณว่าเป็นอัจฉริยะที่ถ่อมตัว ดูอย่างไลนัสสิ!</para>

<para>(When I gave my talk at the first Perl Conference in August
1997, hacker extraordinaire Larry Wall was in the front row.  As I got
to the last line above he called out, religious-revival style, ``Tell
it, tell it, brother!''.  The whole audience laughed, because they
knew this had worked for the inventor of Perl, too.)</para>

<para>(ตอนที่ผมพูดบนเวทีในงาน Perl Conference เดือนสิงหาคมปี 1997 ลาร์รี วอลล์ 
แฮ็กเกอร์ผู้ยิ่งยงนั่งอยู่แถวหน้า เมื่อผมพูดถึงเรื่องในย่อหน้าที่ผ่านมา 
เขาตะโกนขึ้นราวกับเสียงปลุกเร้าของนักบุญ ว่า "บอกเขาไป บอกเขาไปให้หมด เพื่อน!" 
ผู้ฟังทั้งหมดหัวเราะครืน เพราะรู้ว่าเรื่องนี้เกิดกับเขาซึ่งเป็นผู้สร้างภาษา 
Perl ด้วย)</para>

<para>After a very few weeks of running the project in the same spirit,
I began to get similar praise not just from my users but from other
people to whom the word leaked out.  I stashed away some of that
email; I'll look at it again sometime if I ever start wondering
whether my life has been worthwhile :-).</para>

<para>สองสามสัปดาห์จากการทำงานโครงการนี้ด้วยแนวคิดเดียวกัน 
ผมเริ่มได้รับการยกย่องคล้ายๆ กันนี้ ไม่ใช่แค่จากผู้ใช้ของผม แต่ยังมาจากคนอื่นๆ 
ที่ได้ยินเรื่องของโครงการด้วย ผมซุกเมลเหล่านั้นบางฉบับออกไป 
ผมอาจจะหยิบกลับมาอ่านในบางครั้ง 
ถ้าเกิดสงสัยขึ้นมาว่าชีวิตผมมีค่าหรือเปล่า :-)</para>

<para>But there are two more fundamental, non-political lessons here that
are general to all kinds of design.</para>

<para>แต่ยังมีบทเรียนพื้นฐานที่ไม่เกี่ยวกับการเมืองอีกสองข้อ 
ที่เกี่ยวกับการออกแบบทุกชนิดโดยทั่วไป</para>

<blockquote><para>12. Often, the most striking and innovative
        solutions come from realizing that your concept of the problem
        was wrong.</para></blockquote>

<blockquote><para>12. บ่อยครั้งที่วิธีการที่เฉียบแหลมและแปลกใหม่ 
        จะมาจากการตระหนักว่า คุณมองปัญหานั้นผิดมาตลอด</para></blockquote>

<para>I had been trying to solve the wrong problem by continuing to
develop popclient as a combined MTA/MDA with all kinds of funky local
delivery modes.  Fetchmail's design needed to be rethought from the
ground up as a pure MTA, a part of the normal SMTP-speaking Internet
mail path.</para>

<para>ผมเคยพยายามแก้ปัญหาผิดประเด็น โดยการพัฒนา popclient ให้เป็นทั้ง MTA/MDA 
ในตัวเดียวกันต่อไป พร้อมกับโหมดการกระจายเมลแบบต่างๆ ภายในเครื่อง แต่การออกแบบ 
fetchmail ต้องเริ่มคิดใหม่แต่ต้นให้เป็น MTA ล้วนๆ 
โดยเป็นส่วนหนึ่งของเส้นทางเมลในอินเทอร์เน็ตผ่านโพรโทคอล SMTP</para>

<para>When you hit a wall in development&mdash;when you find yourself hard put
to think past the next patch&mdash;it's often time to ask not whether
you've got the right answer, but whether you're asking the right
question.  Perhaps the problem needs to be reframed.</para>

<para>เมื่อคุณเจอทางตันในการพัฒนา เมื่อคุณพบว่าตัวเองต้องคิดหนักกับแพตช์ถัดไป 
ก็มักจะเป็นเวลาที่จะเลิกถามตัวเองว่า ``ได้คำตอบที่ถูกต้องหรือยัง'' 
แต่ควรจะถามใหม่ว่า ``ตั้งคำถามถูกหรือเปล่า'' บางทีก็อาจต้องนิยามปัญหาใหม่</para>

<para>Well, I had reframed my problem.  Clearly, the right thing to do was
(1) hack SMTP forwarding support into the generic driver, (2) make it
the default mode, and (3) eventually throw out all the other delivery
modes, especially the deliver-to-file and deliver-to-standard-output
options.</para>

<para>เอาล่ะ ผมได้มองปัญหาของผมใหม่ ชัดเจนว่าสิ่งที่ควรทำคือ (1) 
เพิ่มการส่งเมลต่อไปยัง SMTP เข้าไปในไดรเวอร์ทั่วไป (2) ทำให้มันเป็นโหมดปริยาย 
และ (3) เอาโหมดอื่นๆ ออกไปในที่สุด โดยเฉพาะ โหมดกระจายไปยังแฟ้ม 
(deliver-to-file) และโหมดกระจายไปยังเอาต์พุตมาตรฐาน 
(deliver-to-standard-output)</para>

<para>I hesitated over step 3 for some time, fearing to upset
long-time popclient users dependent on the alternate delivery
mechanisms.  In theory, they could immediately switch to
<filename>.forward</filename> files or their non-sendmail equivalents
to get the same effects.  In practice the transition might have been
messy.</para>

<para>ผมลังเลที่จะทำขั้นที่ 3 อยู่ระยะหนึ่ง เพราะกลัวว่าจะทำให้ผู้ที่ใช้ 
popclient มานานที่อาจจะใช้วิธีกระจายเมลแบบอื่นอยู่ไม่พอใจ ตามทฤษฎีแล้ว 
เขาสามารถเปลี่ยนไปแก้แฟ้ม <filename>.forward</filename> (หรือแฟ้มอื่นๆ 
ที่เทียบเท่าถ้าไม่ใช้ sendmail) ได้ทันที โดยได้ผลเหมือนเดิม 
แต่ในทางปฏิบัติ การเปลี่ยนดังกล่าวอาจจะยุ่งยาก</para>

<para>But when I did it, the benefits proved huge.  The cruftiest parts of
the driver code vanished.  Configuration got radically simpler&mdash;no
more grovelling around for the system MDA and user's mailbox, no more
worries about whether the underlying OS supports file locking.</para>

<para>แต่เมื่อผมได้ทำจริงๆ ผลที่ได้นั้นดีมาก 
ส่วนที่ยุ่งที่สุดของไดรเวอร์ถูกตัดออกไป 
การปรับแต่งค่าทำได้ง่ายขึ้นอย่างเห็นได้ชัด ไม่จำเป็นต้องไปยุ่งกับทั้ง MDA 
และกล่องเมลของผู้ใช้อีกต่อไป ไม่ต้องกังวลว่า OS 
ที่ใช้อยู่สนับสนุนการล็อคแฟ้มหรือเปล่า</para>

<para>Also, the only way to lose mail vanished.  If you specified delivery
to a file and the disk got full, your mail got lost.  This can't
happen with SMTP forwarding because your SMTP listener won't return OK
unless the message can be delivered or at least spooled for later
delivery.</para>

<para>นอกจากนั้น โอกาสเดียวที่จะทำเมลหายก็หมดไปอีกด้วย เดิมที 
ถ้าคุณระบุให้กระจายไปยังแฟ้ม (delivery-to-file) และเนื้อที่ดิสก์เกิดเต็มขึ้นมา 
เมลนั้นจะหายไป แต่สิ่งนี้จะไม่เกิดขึ้นกับการส่งต่อไปยัง SMTP 
เพราะว่าโปรแกรมรับเมลแบบ SMTP จะไม่ยอมตกลงจนกว่าเมลจะถูกกระจายไปเรียบร้อย 
หรืออย่างน้อยก็ส่งเข้าที่พักไว้ รอการกระจายต่อในภายหลัง</para>

<para>Also, performance improved (though not so you'd notice it in a single
run).  Another not insignificant benefit of this change was that the
manual page got a lot simpler.</para>

<para>เรื่องประสิทธิภาพก็ยังสูงขึ้นอีกด้วย (แม้จะไม่รู้สึกในการทำงานครั้งเดียว) 
ผลดีอีกอย่างที่ไม่สำคัญเท่าไร คือคู่มือวิธีใช้ (man page) ดูง่ายลงมาก</para>

<para>Later, I had to bring delivery via a user-specified local MDA
back in order to allow handling of some obscure situations involving
dynamic SLIP.  But I found a much simpler way to do it.</para>

<para>ต่อมาภายหลัง ผมต้องนำส่วนกระจายเมลผ่าน MDA ที่ผู้ใช้กำหนดกลับมาอีก 
เพื่อจัดการกับบางสถานการณ์ที่เกี่ยวกับ SLIP 
แต่ผมพบวิธีที่ง่ายกว่าเดิมมากในการเพิ่มมันเข้าไป</para>

<para>The moral?  Don't hesitate to throw away superannuated features
when you can do it without loss of effectiveness.  Antoine de
Saint-Exup&eacute;ry (who was an aviator and aircraft designer when he
wasn't authoring classic children's books) said:</para>

<para>คติของเรื่องนี้น่ะหรือ? อย่าลังเลที่จะทิ้งความสามารถที่หมดอายุแล้ว 
เมื่อคุณพบว่าคุณสามารถทำได้โดยผลลัพธ์ยังเท่าเดิม อังตวน เดอ แซง-เตกซูเปรี 
(ผู้เป็นนักบินและนักออกแบบเครื่องบิน 
ในช่วงที่ไม่ได้เขียนหนังสืออมตะสำหรับเด็ก) กล่าวไว้ว่า:</para>

<blockquote><para>13. ``Perfection (in design) is achieved not when
     there is nothing more to add, but rather when there is nothing
     more to take away.''</para></blockquote>

<blockquote><para>13. ``ความสมบูรณ์แบบ (ในการออกแบบ) 
     จะได้มาไม่ใช่เมื่อไม่มีอะไรจะเพิ่ม 
     แต่จะได้มาเมื่อไม่มีอะไรจะเอาออกต่างหาก''</para></blockquote>

<para>When your code is getting both better and simpler, that is when you
<emphasis>know</emphasis> it's right.  And in the process, the fetchmail
design acquired an identity of its own, different from the ancestral
popclient.</para>

<para>เมื่อโค้ดขของคุณดีขึ้นและเรียบง่ายขึ้น เมื่อนั้นแหละที่คุณจะรู้สึกว่ามัน 
<emphasis>ใช่</emphasis> และในกระบวนการนี้ การออกแบบของ fetchmail 
ได้สร้างเอกลักษณ์ของตัวเอง ซึ่งแตกต่างไปจาก popclient เดิม</para>

<para>It was time for the name change.  The new design looked much more like
a dual of sendmail than the old popclient had; both are MTAs, but
where sendmail pushes then delivers, the new popclient pulls then
delivers.  So, two months off the blocks, I renamed it fetchmail.</para>

<para>มันถึงเวลาที่จะเปลี่ยนชื่อซะที การออกแบบแบบใหม่ดูเหมือนกับเป็นคู่ของ 
sendmail มากกว่าที่ popclient เดิมเคยเป็น โปรแกรมทั้งคู่เป็น MTA แต่ในขณะที่ 
sendmail จะผลักออกไปแล้วกระจาย แต่ popclient ตัวใหม่จะดึงเข้ามาแล้วกระจาย 
สองเดือนถัดมา ผมเปลี่ยนชื่อมันเป็น fetchmail</para>

<para>There is a more general lesson in this story about how SMTP
delivery came to fetchmail.  It is not only debugging that is
parallelizable; development and (to a perhaps surprising extent)
exploration of design space is, too.  When your development mode is
rapidly iterative, development and enhancement may become special
cases of debugging&mdash;fixing `bugs of omission' in the original
capabilities or concept of the software.</para>

<para>มีบทเรียนทั่วๆ ไปอีกข้อจากเรื่องเกี่ยวกับวิธีที่การกระจายเมลแบบ SMTP 
กลายมาเป็น fetchmail นี้ คือบทเรียนที่ว่า ไม่ใช่แค่การตรวจบั๊กเท่านั้น 
ที่ทำขนานกันได้ แต่การพัฒนาและการสำรวจความเป็นไปได้ของการออกแบบก็ทำขนานได้ 
(ในระดับที่น่าประหลาดใจ) เช่นกัน เมื่อการพัฒนาของคุณมีรูปแบบวนรอบอย่างรวดเร็ว 
การพัฒนาและเพิ่มความสามารถจะกลายเป็นการแก้บั๊กกรณีพิเศษ นั่นคือ 
`บั๊กเนื่องจากสิ่งที่ขาดไป' ในคุณสมบัติหรือแนวคิดเริ่มแรกของตัวซอฟต์แวร์</para>

<para>Even at a higher level of design, it can be very valuable to
have lots of co-developers random-walking through the design space
near your product. Consider the way a puddle of water finds a drain,
or better yet how ants find food: exploration essentially by
diffusion, followed by exploitation mediated by a scalable
communication mechanism. This works very well; as with Harry
Hochheiser and me, one of your outriders may well find a huge win
nearby that you were just a little too close-focused to see.</para>

<para>แม้กับการออกแบบระดับบน 
การมีผู้ร่วมพัฒนาจำนวนมากเดินผ่านการออกแบบของคุณในทิศทางต่างๆ 
ก็ยังมีประโยชน์มากๆ ลองคิดถึงการที่ก้อนน้ำหาทางไหลจนลงท่อ หรือมดที่หาอาหาร 
ต่างเป็นการสำรวจโดยใช้การแพร่กระจาย 
ตามด้วยการช่วงใช้ที่จัดการผ่านกลไกการสื่อสาร วิธีนี้ใช้การได้ดีมาก 
เหมือนกับที่ผมและ Harry Hochheiser ทำ ใครบางคนจากภายนอก 
อาจพบสิ่งสุดยอดที่อยู่ใกล้ๆ ตัวคุณ ที่คุณอยู่ใกล้เกินกว่าจะมองเห็นก็ได้</para>

</sect1>
<!-- Fetchmail Grows Up -->
<sect1><title>Fetchmail เติบโต</title>

<para>There I was with a neat and innovative design, code that I knew
worked well because I used it every day, and a burgeoning beta list.
It gradually dawned on me that I was no longer engaged in a trivial
personal hack that might happen to be useful to few other people.  I
had my hands on a program that every hacker with a Unix box and a
SLIP/PPP mail connection really needs.</para>

<para>แล้วผมก็อยู่กับการออกแบบที่เนี้ยบและมีนวัตกรรม 
อยู่กับโค้ดที่ผมรู้ว่าทำงานได้ดี เพราะผมใช้อยู่ทุกวัน 
และอยู่กับผู้ทดสอบเบต้าที่เพิ่มขยายขึ้นเรื่อยๆ ผมเริ่มรู้สึกทีละนิด 
ว่าผมไม่ได้ผูกพันกับการแฮ็กเล็กๆ น้อยๆ 
ของตัวเองที่อาจจะบังเอิญมีประโยชน์กับคนอื่นบางคนอีกต่อไป 
แต่ผมกำลังเขียนโปรแกรมที่แฮ็กเกอร์ที่ใช้ยูนิกซ์และอ่านเมลผ่าน SLIP/PPP 
ทุกคนต้องมี</para>

<para>With the SMTP forwarding feature, it pulled far enough in front of the
competition to potentially become a ``category killer'', one of those
classic programs that fills its niche so competently that the
alternatives are not just discarded but almost forgotten.</para>

<para>ด้วยความสามารถส่งเมลต่อไปยัง SMTP ทำให้ fetchmail 
นำหน้าคู่แข่งไปไกลจนถึงขั้นสามารถเป็น ``killer'' 
หรือโปรแกรมอมตะที่เติมช่องว่างได้อย่างเฉียบขาด 
จนทำให้ตัวเลือกอื่นไม่ใช่แค่ถูกทิ้งไป แต่แทบจะถูกลืมไปเลย</para>

<para>I think you can't really aim or plan for a result like this.  You have
to get pulled into it by design ideas so powerful that afterward the
results just seem inevitable, natural, even foreordained.  The only
way to try for ideas like that is by having lots of ideas&mdash;or by
having the engineering judgment to take other peoples' good ideas
beyond where the originators thought they could go.</para>

<para>ผมคิดว่าคุณไม่อาจจะตั้งเป้าหรือวางแผนเพื่อให้โปรแกรมมาถึงจุดนี้ได้เลย 
คุณต้องเป็นไปเอง 
ด้วยแนวคิดการออกแบบที่ทรงพลังพอที่ผลลัพธ์ที่ออกมาจะกลายเป็นสิ่งที่เลี่ยงไม่ได้ 
เป็นธรรมชาติ หรือแม้แต่เหมือนถูกลิขิตไว้ 
วิธีเดียวที่จะได้สุดยอดแนวคิดอย่างนั้นมา คือต้องมีความคิดจำนวนมาก 
หรือไม่ก็มีวิจารณญาณทางวิศวกรรมที่นำความคิดของผู้อื่นมาใช้ 
โดยที่เจ้าของไม่นึกว่าจะนำมาใช้ได้ขนาดนี้</para>

<para>Andy Tanenbaum had the original idea to build a simple native Unix for
IBM PCs, for use as a teaching tool (he called it Minix).  Linus
Torvalds pushed the Minix concept further than Andrew probably thought
it could go&mdash;and it grew into something wonderful.  In the same way
(though on a smaller scale), I took some ideas by Carl Harris and
Harry Hochheiser and pushed them hard.  Neither of us was `original'
in the romantic way people think is genius.  But then, most science
and engineering and software development isn't done by original
genius, hacker mythology to the contrary.</para>

<para>แอนดี้ ทาเนนบอม มีความคิดเริ่มแรกคือสร้างยูนิกซ์ง่ายๆ สำหรับ IBM PC 
โดยเฉพาะ เพื่อใช้เป็นตัวอย่างในการสอนหนังสือ (เขาเรียกมันว่ามินิกซ์) ไลนัส 
ทอร์วัลด์ ผลักดันแนวคิดของมินิกซ์ต่อไปจนไกลเกินกว่าที่แอนดี้จะเคยนึกถึง 
และมันก็กลายเป็นสิ่งมหัศจรรย์ ในทำนองเดียวกัน (แต่ขนาดเล็กกว่า) 
ผมนำแนวคิดบางอย่างของ คาร์ล แฮร์ริส และ Harry Hochheiser มาใช้ 
แล้วผลักดันต่ออย่างจริงจัง ในบรรดาพวกเรา ไม่มีใครสักคนที่เป็น `ผู้คิดค้น' 
ในแบบที่ผู้คนนึกฝันว่าเป็นอัจฉริยะเลย แต่จริงๆ แล้วผลงานทางวิทยาศาสตร์ วิศวกรรม 
และการพัฒนาซอฟต์แวร์นั้น ส่วนมากไม่ได้เกิดจากอัจฉริยะที่เป็นผู้คิดค้นเลย 
เรื่องพวกนั้นเป็นตำนานปรัมปราของแฮ็กเกอร์เสียมากกว่า</para>

<para>The results were pretty heady stuff all the same&mdash;in fact, just the
kind of success every hacker lives for!  And they meant I would have
to set my standards even higher.  To make fetchmail as good as I now
saw it could be, I'd have to write not just for my own needs, but also
include and support features necessary to others but outside my orbit.
And do that while keeping the program simple and robust.</para>

<para>ผลลัพธ์ที่ออกมาร้อนแรงพอๆ กัน จะว่าไปแล้ว 
ก็เป็นความสำเร็จชนิดที่แฮ็กเกอร์ทุกคนฝันถึงเลย และนั่นหมายความว่า 
ผมต้องตั้งมาตรฐานของตัวเองให้สูงขึ้น และในการทำให้ fetchmail 
ดีได้อย่างที่ผมมองเห็นความเป็นไปได้นี้ 
นอกจากผมจะต้องเขียนเพื่อสนองความต้องการของตัวเองแล้ว 
ยังต้องเพิ่มความสามารถที่คนอื่นที่อยู่นอกแวดวงของผมต้องการอีกด้วย 
ในขณะเดียวกัน ก็ต้องรักษาตัวโปรแกรมให้เรียบง่ายและแน่นหนาดังเดิมด้วย</para>

<para>The first and overwhelmingly most important feature I wrote after
realizing this was multidrop support&mdash;the ability to fetch mail from
mailboxes that had accumulated all mail for a group of users, and then
route each piece of mail to its individual recipients.</para>

<para>ความสามารถสำคัญอันแรกที่ผมเพิ่มเข้ามาหลังจากตระหนักถึงความจริงข้างต้น 
คือการสนับสนุน multidrop 
หรือความสามารถที่จะดึงเมลจากกล่องเมลรวมที่รวมเมลของผู้ใช้กลุ่มหนึ่ง 
ไปกระจายให้กับผู้ใช้แต่ละคนตามที่จ่าหน้าในเมล</para>

<para>I decided to add the multidrop support partly because some users
were clamoring for it, but mostly because I thought it would shake
bugs out of the single-drop code by forcing me to deal with addressing
in full generality.  And so it proved.  Getting <ulink
url="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc822.txt">RFC
822</ulink> address parsing right took me a remarkably long time, not
because any individual piece of it is hard but because it involved a
pile of interdependent and fussy details.</para>

<para>ผมตัดสินใจที่จะเพิ่มการสนับสนุน multidrop 
ส่วนหนึ่งเพราะมีผู้ใช้จำนวนหนึ่งเรียกร้อง แต่สาเหตุสำคัญคือ 
ผมคาดว่ามันจะช่วยแก้บั๊กต่างๆ ในโค้ดส่วน single drop ออกไปด้วย 
เพราะจะเป็นการบังคับให้ผมมาสนใจกับการจัดการเรื่องที่อยู่เมลในรูปทั่วไปจริงๆ 
เสียที และมันก็เป็นอย่างที่ผมคิด การแจงที่อยู่เมลแบบ <ulink 
url="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc822.txt">RFC 
822</ulink> ให้ถูกต้อง กินเวลาของผมไปมาก ไม่ใช่เพราะว่าโค้ดของมันยาก 
แต่มันมีรายละเอียดที่เกี่ยวพันกันค่อนข้างเยอะ</para>

<para>But multidrop addressing turned out to be an excellent design decision
as well.  Here's how I knew:</para>

<para>แต่การเพิ่มการจัดการที่อยู่เมลแบบ multidrop เข้ามานั้น 
กลายเป็นการตัดสินใจที่ยอดเยี่ยมเกี่ยวกับการออกแบบ ตอนนี้ผมรู้ว่า:</para>

<blockquote><para>14. Any tool should be useful in the expected way,
        but a truly great tool lends itself to uses you never
        expected.</para></blockquote>

<blockquote><para>14. เครื่องมือทั่วไปจะใช้ประโยชน์ได้ตามที่ตั้งใจไว้ 
        แต่เครื่องมือที่ยอดเยี่ยมจริงๆ 
        จะสามารถใช้ไปในทางที่ไม่ได้ตั้งใจไว้ได้ด้วย</para></blockquote>

<para>The unexpected use for multidrop fetchmail is to run mailing
lists with the list kept, and alias expansion done, on the
<emphasis>client</emphasis> side of the Internet connection.  This
means someone running a personal machine through an ISP account can
manage a mailing list without continuing access to the ISP's alias
files.</para>

<para>การใช้ fetchmail แบบ multidrop ที่คาดไม่ถึง 
คือใช้ทำเมลลิ่งลิสต์ โดยเก็บรายชื่อสมาชิกและกระจายเมลในฝั่ง 
<emphasis>เครื่องลูกข่าย</emphasis> ของการเชื่อมต่ออินเทอร์เน็ต 
ซึ่งหมายความว่า ใครก็ตามที่มีเครื่องต่อกับอินเทอร์เน็ตผ่านบัญชีของ ISP 
ก็สามารถจัดการกับเมลลิ่งลิสต์ได้ โดยไม่ต้องอาศัยแฟ้ม alias ในฝั่งของ ISP 
เลย</para>

<para>Another important change demanded by my beta-testers was support
for 8-bit MIME (Multipurpose Internet Mail Extensions) operation.
This was pretty easy to do, because I had been careful to keep the
code 8-bit clean (that is, to not press the 8th bit, unused in the
ASCII character set, into service to carry information within the
program).  Not because I anticipated the demand for this feature, but
rather in obedience to another rule:</para>

<para>การเปลี่ยนแปลงที่สำคัญอีกอย่างที่นักทดสอบของผมเรียกร้องคือ สนับสนุน MIME 
(Multipurpose Internet Mail Extensions) แบบ 8 บิต ซึ่งอันนี้ทำค่อนข้างง่าย 
เพราะผมได้ระวังให้โค้ดทำงานแบบ 8 บิตได้มาตั้งแต่ต้น (กล่าวคือ 
โดยไม่พยายามใช้งานบิตที่ 8 ที่ไม่ได้ใช้ในรหัส ASCII มาเก็บข้อมูลในโปรแกรม) 
ที่ผมทำเช่นนี้ไม่ใช่เป็นเพราะคาดไว้ก่อนว่าจะต้องเพิ่มความสามารถนี้ 
แต่เป็นเพราะผมทำตามกฎอีกข้อหนึ่ง:</para>

<blockquote><para>15. When writing gateway software of any kind, take
        pains to disturb the data stream as little as possible&mdash;and
        <emphasis>never</emphasis> throw away information unless the
        recipient forces you to!</para></blockquote>

<blockquote><para>15. เมื่อจะเขียนโปรแกรมที่เกี่ยวกับทางผ่านของข้อมูล 
        (gateway) ใดๆ พึงหลีกเลี่ยงการเปลี่ยนแปลงกระแสข้อมูลให้มากที่สุด และ 
        <emphasis>ห้าม</emphasis> ทิ้งข้อมูลทุกชนิด 
        ยกเว้นผู้รับจะบังคับให้ทำเช่นนั้น!</para></blockquote>

<para>Had I not obeyed this rule, 8-bit MIME support would have been
difficult and buggy.  As it was, all I had to do is read the MIME
standard (<ulink
url="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1652.txt">RFC
1652</ulink>) and add a trivial bit of header-generation logic.</para>

<para>ถ้าผมไม่ปฏิบัติตามกฎนี้ การสนับสนุน MIME แบบ 8 บิตจะยากและเต็มไปด้วยบั๊ก 
แต่สิ่งที่ผมต้องทำจริงๆ ก็แค่อ่านมาตรฐานของ MIME (<ulink 
url="http://info.internet.isi.edu:80/in-notes/rfc/files/rfc1652.txt">RFC 
1652</ulink>) และเพิ่มส่วนแก้ไขข้อมูลส่วนหัวนิดเดียว</para>

<para>Some European users bugged me into adding an option to limit the
number of messages retrieved per session (so they can control costs
from their expensive phone networks).  I resisted this for a long
time, and I'm still not entirely happy about it.  But if you're
writing for the world, you have to listen to your customers&mdash;this
doesn't change just because they're not paying you in money.</para>

<para>ผู้ใช้บางคนจากยุโรปเรียกร้องให้ผมเพิ่มตัวเลือกในการจำกัดจำนวนเมลที่จะดึงในแต่ละครั้ง 
(เพื่อที่พวกเขาจะได้สามารถควบคุมค่าโทรศัพท์ได้) ผมปฏิเสธเรื่องนี้เป็นเวลานาน 
และผมก็ยังไม่ชอบความสามารถนี้เท่าไรนัก แต่ถ้าคุณเขียนโปรแกรมให้โลกใช้ 
คุณต้องฟังเสียงของผู้ใช้ 
เงื่อนไขนี้ไม่ได้เปลี่ยนแปลงเพียงเพราะเขาไม่ได้ได้จ่ายคุณเป็นตัวเงิน</para>

</sect1>
<!-- A Few More Lessons from Fetchmail -->
<sect1><title>บทเรียนเพิ่มเติมจาก Fetchmail</title>

<para>Before we go back to general software-engineering issues, there are
a couple more specific lessons from the fetchmail experience to
ponder.  Nontechnical readers can safely skip this section.</para>

<para>ก่อนที่เราจะกลับไปสู่ประเด็นเกี่ยวกับวิศวกรรมซอฟต์แวร์ทั่วไป 
ยังมีบทเรียนให้ตรึกตรองอีกนิดหน่อยจากประสบการณ์ของ fetchmail โดยเฉพาะ 
ผู้อ่านที่ไม่มีพื้นฐานทางเทคนิคสามารถข้ามหัวข้อนี้ไปได้</para>

<para>The rc (control) file syntax includes optional `noise' keywords that are
entirely ignored by the parser.  The English-like syntax they allow is
considerably more readable than the traditional terse keyword-value
pairs you get when you strip them all out.</para>

<para>ไวยากรณ์ของแฟ้ม rc (แฟ้มควบคุม) มีคำแทรกที่จะใส่หรือไม่ก็ได้ 
ซึ่งตัวแจงจะไม่สนใจ ไวยากรณ์ที่คล้ายภาษาอังกฤษที่เกิดจากคำแทรกดังกล่าว 
ทำให้อ่านง่ายกว่าการใช้คู่ คำหลัก-ค่า 
ที่สั้นห้วนตามแบบฉบับที่คุณจะได้เมื่อตัดคำแทรกเหล่านั้นออกไป</para>

<para>These started out as a late-night experiment when I noticed how
much the rc file declarations were beginning to resemble an imperative
minilanguage.  (This is also why I changed the original popclient
``server'' keyword to ``poll'').</para>

<para>แนวคิดดังกล่าว เริ่มจากการทดลองอะไรเล่นๆ ตอนดึก 
หลังจากที่ผมสังเกตว่ารูปแบบการประกาศในแฟ้ม rc ชักจะเริ่มคล้ายประโยคคำสั่งย่อยๆ 
(นี่เป็นเหตุผลที่ผมเปลี่ยนคำหลัก ``server'' ของ popclient ไปเป็น 
``poll'')</para>

<para>It seemed to me that trying to make that imperative minilanguage more
like English might make it easier to use.  Now, although I'm a
convinced partisan of the ``make it a language'' school of design as
exemplified by Emacs and HTML and many database engines, I am
not normally a big fan of ``English-like'' syntaxes.</para>

<para>ผมรู้สึกว่าการพยายามทำประโยคคำสั่งย่อยๆ 
ให้คล้ายภาษามนุษย์อาจทำให้มันใช้ง่ายขึ้น ทุกวันนี้ 
แม้ผมจะอยู่ฝ่ายสนับสนุนค่ายการออกแบบที่ ``ทำให้มันเป็นภาษา'' อย่างที่มี Emacs 
และ HTML และโปรแกรมจัดการฐานข้อมูลหลายตัวเป็นตัวอย่าง แต่โดยปกติ 
ผมก็ไม่ได้นิยมไวยากรณ์ที่ ``คล้ายภาษามนุษย์'' มากมายนัก</para>

<para>Traditionally programmers have tended to favor control syntaxes
that are very precise and compact and have no redundancy at all.  This
is a cultural legacy from when computing resources were expensive, so
parsing stages had to be as cheap and simple as possible.  English,
with about 50% redundancy, looked like a very inappropriate model
then.</para>

<para>โดยธรรมเนียมแล้ว 
โปรแกรมเมอร์มีแนวโน้มที่จะชอบไวยากรณ์ควบคุมที่เที่ยงตรงและกระชับ 
และไม่มีส่วนเกินอยู่เลย 
นี่เป็นมรดกทางวัฒนธรรมจากยุคที่ทรัพยากรการคำนวณมีราคาแพง 
ซึ่งทำให้ขั้นตอนการแจงต้องประหยัดและง่ายที่สุดเท่าที่จะทำได้ 
ภาษามนุษย์ซึ่งมีส่วนเกินราว 50% จึงไม่ใช่รูปแบบที่เหมาะสมในขณะนั้น</para>

<para>This is not my reason for normally avoiding English-like syntaxes; I
mention it here only to demolish it.  With cheap cycles and core,
terseness should not be an end in itself.  Nowadays it's more
important for a language to be convenient for humans than to be cheap
for the computer.</para>

<para>นี่ไม่ใช่เหตุผลที่โดยปกติผมพยายามหลีกเลี่ยงไวยากรณ์ที่คล้ายภาษามนุษย์ 
ผมยกเหตุผลดังกล่าวขึ้นมาในที่นี้เพียงเพื่อจะหักล้างเท่านั้น 
ด้วยพลังคำนวณและหน่วยความจำที่ถูกลง 
ความสั้นห้วนก็ไม่ควรจะเป็นคำตอบสุดท้ายอีกต่อไป ทุกวันนี้ 
สิ่งที่สำคัญกว่าสำหรับภาษา ก็คือความสะดวกต่อมนุษย์ 
ไม่ใช่ความง่ายสำหรับคอมพิวเตอร์</para>

<para>There remain, however, good reasons to be wary.  One is the complexity
cost of the parsing stage&mdash;you don't want to raise that to the point
where it's a significant source of bugs and user confusion in itself.
Another is that trying to make a language syntax English-like often
demands that the ``English'' it speaks be bent seriously out of shape,
so much so that the superficial resemblance to natural language is as
confusing as a traditional syntax would have been.  (You see this bad
effect in a lot of so-called ``fourth generation'' and commercial
database-query languages.)</para>

<para>อย่างไรก็ดี ยังมีเหตุผลที่ดีที่พึงระวัง 
ข้อแรกคือความซับซ้อนของขั้นตอนการแจง 
คุณคงไม่ต้องการจะให้ความสำคัญกับมันจนกลายมาเป็นแหล่งบั๊กแหล่งใหญ่ 
หรือทำให้ผู้ใช้สับสน 
อีกข้อหนึ่งคือการพยายามทำไวยากรณ์ของภาษาให้คล้ายภาษามนุษย์ มักจะติดข้อจำกัดว่า 
``ภาษามนุษย์'' ที่ว่านั้น จะถูกดัดจนผิดรูปอย่างร้ายแรง 
จนถึงขั้นที่ความคล้ายคลึงกับภาษาธรรมชาติอย่างผิวเผินจะน่าปวดหัวพอๆ 
กับไวยากรณ์แบบเก่า (คุณจะพบผลร้ายดังกล่าวได้ในสิ่งที่เรียกว่า ภาษา 
``รุ่นที่สี่'' และภาษาสืบค้นฐานข้อมูลเชิงพาณิชย์ต่างๆ)</para>

<para>The fetchmail control syntax seems to avoid these problems
because the language domain is extremely restricted.  It's nowhere
near a general-purpose language; the things it says simply are not
very complicated, so there's little potential for confusion in moving
mentally between a tiny subset of English and the actual control
language.  I think there may be a broader lesson here:</para>

<para>ไวยากรณ์ควบคุมของ fetchmail ดูจะหลีกเลี่ยงปัญหาดังกล่าว 
เพราะกรอบของภาษาจะจำกัดอย่างมาก มันไม่มีอะไรคล้ายกับภาษาอเนกประสงค์เลย 
สิ่งที่บรรยายเป็นเพียงสิ่งที่ไม่ซับซ้อน ดังนั้น 
จึงมีแนวโน้มของความสับสนน้อยมากในการสลับไปมาระหว่างภาษามนุษย์ง่ายๆ 
กับภาษาที่ใช้ควบคุมจริง ผมคิดว่า 
เราน่าจะได้บทเรียนที่กว้างขึ้นสำหรับเรื่องนี้:</para>

<blockquote><para>16. When your language is nowhere near
        Turing-complete, syntactic sugar can be your
        friend.</para></blockquote>

<blockquote><para>16. ตราบใดที่ภาษาของคุณไม่ได้ซับซ้อนระดับภาษาทูริงสมบูรณ์ 
        การเสริมแต่งไวยากรณ์ก็อาจช่วยคุณได้</para></blockquote>

<para>Another lesson is about security by obscurity.  Some fetchmail users
asked me to change the software to store passwords encrypted in the rc
file, so snoopers wouldn't be able to casually see them.</para>

<para>อีกบทเรียนหนึ่ง เป็นเรื่องเกี่ยวกับความนิรภัยโดยอาศัยความลึกลับ 
(security by obscurity) ผู้ใช้ fetchmail 
บางคนขอให้ผมแก้โปรแกรมให้เก็บรหัสผ่านในรูปที่เข้ารหัสลับในแฟ้ม rc 
เพื่อไม่ให้ผู้บุกรุกอ่านรหัสผ่านได้ง่ายนัก</para>

<para>I didn't do it, because this doesn't actually add protection.
Anyone who's acquired permissions to read your rc file will
be able to run fetchmail as you anyway&mdash;and if it's your password
they're after, they'd be able to rip the necessary decoder out of
the fetchmail code itself to get it.</para>

<para>ผมไม่ทำตามคำขอนั้น เพราะมันไม่ได้เพิ่มการปกป้องใดๆ เลย 
ใครก็ตามที่ได้รับสิทธิ์อ่านแฟ้ม rc ของคุณ จะสามารถเรียกใช้ fetchmail 
ในฐานะตัวคุณได้อยู่แล้ว และถ้าเขากำลังล่าหารหัสผ่านของคุณ 
เขาก็สามารถถอดส่วนถอดรหัสออกจากโค้ดของ fetchmail เพื่ออ่านเอาก็ได้</para>

<para>All <filename>.fetchmailrc</filename> password encryption would
have done is give a false sense of security to people who don't think
very hard.  The general rule here is:</para>

<para>สิ่งที่จะได้จากการเข้ารหัสลับรหัสผ่านในแฟ้ม 
<filename>.fetchmailrc</filename> 
ก็คือการให้มายาภาพของความนิรภัยต่อผู้ที่ไม่ได้คิดอย่างถี่ถ้วน 
กฎทั่วไปของเรื่องนี้ก็คือ:</para>

<blockquote><para>17. A security system is only as secure as its
        secret.  Beware of pseudo-secrets.</para></blockquote>

<blockquote><para>17. ระบบนิรภัยจะมีความนิรภัยเท่ากับความลับที่มันเก็บเท่านั้น 
        พึงระวังความนิรภัยหลอกๆ</para></blockquote>

</sect1>
<!-- Necessary Preconditions for the Bazaar Style -->
<sect1><title>เงื่อนไขตั้งต้นที่จำเป็นสำหรับแนวทางตลาดสด</title>

<para>Early reviewers and test audiences for this essay consistently raised
questions about the preconditions for successful bazaar-style
development, including both the qualifications of the project leader
and the state of code at the time one goes public and starts to try to
build a co-developer community.</para>

<para>ผู้ตรวจทานและผู้ทดลองอ่านบทความนี้คนแรกๆ ต่างตั้งคำถามเหมือนๆ กัน 
เกี่ยวกับเงื่อนไขตั้งต้นที่จำเป็นสำหรับการพัฒนาแบบตลาดสด 
รวมทั้งคุณสมบัติของผู้นำโครงการ 
และสถานะของโค้ดขณะที่ออกสู่สาธารณะเพื่อเริ่มสร้างชุมชนผู้ร่วมพัฒนา</para>

<para>It's fairly clear that one cannot code from the ground up in
bazaar style <link linkend="IN">[IN]</link>.  One can test, debug
and improve in bazaar style, but it would be very hard to
<emphasis>originate</emphasis> a project in bazaar mode.  Linus didn't
try it.  I didn't either.  Your nascent developer community needs to
have something runnable and testable to play with.</para>

<para>ค่อนข้างชัดเจนอยู่แล้ว ว่าไม่มีใครสามารถเขียนโค้ดตั้งแต่ต้นในแบบตลาดสดได้ 
<link linkend="IN">[IN]</link> การทดสอบ ตรวจบั๊ก และปรับปรุงในแบบตลาดสดนั้น 
เป็นไปได้ แต่การ <emphasis>เริ่มต้น</emphasis> 
โครงการในแบบตลาดสดเป็นเรื่องที่ยากมาก ไลนัสเองก็ไม่ได้ลองทำ 
ผมก็ไม่ได้ลองเหมือนกัน ชุมชนนักพัฒนาที่จะบังเกิดขึ้น 
จะต้องการอะไรที่ทำงานได้และทดสอบได้ไว้เล่นด้วย</para>

<para>When you start community-building, what you need to be able to
present is a <emphasis>plausible promise</emphasis>.  Your program
doesn't have to work particularly well.  It can be crude, buggy,
incomplete, and poorly documented.  What it must not fail to do is (a)
run, and (b) convince potential co-developers that it can be evolved
into something really neat in the foreseeable future.</para>

<para>เมื่อคุณเริ่มสร้างชุมชน สิ่งที่คุณต้องสามารถนำเสนอให้ได้ก็คือ 
<emphasis>ความเป็นไปได้</emphasis> โปรแกรมของคุณไม่จำเป็นต้องทำงานได้ดี 
มันอาจจะหยาบๆ มีบั๊ก ไม่สมบูรณ์ และขาดเอกสารอธิบายได้ 
แต่สิ่งที่จะพลาดไม่ได้ก็คือ (ก) ต้องเรียกใช้งานได้ (ข) 
ทำให้ผู้ที่จะร่วมพัฒนาเชื่อได้ 
ว่ามันจะวิวัฒน์ไปเป็นสิ่งที่เนี้ยบได้ในอนาคตอันใกล้</para>

<para>Linux and fetchmail both went public with strong, attractive basic
designs.  Many people thinking about the bazaar model as I have
presented it have correctly considered this critical, then jumped from
that to the conclusion that a high degree of design intuition and
cleverness in the project leader is indispensable.</para>

<para>ทั้งลินุกซ์และ fetchmail 
ต่างออกสู่สาธารณะพร้อมการออกแบบที่แข็งแรงและดึงดูด 
หลายคนที่คิดเกี่ยวกับรูปแบบตลาดสดตามที่ผมได้นำเสนอ 
ต่างถือว่าสิ่งนี้สำคัญยิ่งยวด แล้วก็กระโดดจากจุดนั้นไปยังข้อสรุปทันที 
ว่าความหยั่งรู้ในการออกแบบและความฉลาดของผู้นำโครงการ 
เป็นสิ่งที่ขาดเสียไม่ได้</para>

<para>But Linus got his design from Unix.  I got mine initially from
the ancestral popclient (though it would later change a great deal,
much more proportionately speaking than has Linux).  So does the
leader/coordinator for a bazaar-style effort really have to have
exceptional design talent, or can he get by through leveraging the
design talent of others?</para>

<para>แต่ไลนัสได้การออกแบบของเขามาจากยูนิกซ์ ผมเองก็ได้การออกแบบของผมมาจาก 
popclient ที่มีมาก่อน (แม้จะเปลี่ยนไปอย่างมากในภายหลัง 
มากกว่าที่เกิดกับลินุกซ์หลายเท่า) ดังนั้น 
ผู้นำหรือผู้ประสานงานของงานในแบบตลาดสด ยังต้องมีพรสวรรค์ในการออกแบบอย่างเอกอุ 
หรือเขาสามารถสร้างขึ้นได้จากการใช้พรสวรรค์การออกแบบของผู้อื่น?</para>

<para>I think it is not critical that the coordinator be able to
originate designs of exceptional brilliance, but it is absolutely
critical that the coordinator be able to <emphasis>recognize good
design ideas from others</emphasis>.</para>

<para>ผมคิดว่าไม่ใช่เรื่องคอขาดบาดตายเลย 
ที่ผู้ประสานงานจะต้องสามารถออกแบบซอฟต์แวร์ได้อย่างบรรเจิด แต่เป็นเรื่องสำคัญมาก 
ที่ผู้ประสานงานต้องสามารถ 
<emphasis>ตระหนักรู้แนวคิดการออกแบบที่ดีจากผู้อื่น</emphasis></para>

<para>Both the Linux and fetchmail projects show evidence of this.  Linus,
while not (as previously discussed) a spectacularly original designer,
has displayed a powerful knack for recognizing good design and
integrating it into the Linux kernel.  And I have already described
how the single most powerful design idea in fetchmail (SMTP
forwarding) came from somebody else.</para>

<para>ทั้งโครงการลินุกซ์และ fetchmail ต่างแสดงตัวอย่างของเรื่องนี้ 
ในขณะที่ไลนัสไม่ใช่นักออกแบบคิดค้นที่ดีเลิศ (ดังที่ได้กล่าวไปแล้ว) 
แต่เขาได้แสดงความสามารถพิเศษในการตระหนักรู้การออกแบบที่ดี 
และผนวกรวมเข้าในเคอร์เนลลินุกซ์ และผมก็ได้บรรยายไปแล้ว 
ถึงการที่แนวคิดการออกแบบดีที่สุดเพียงชิ้นเดียวใน fetchmail 
(การส่งเมลต่อไปยัง SMTP) มาจากคนอื่น</para>

<para>Early audiences of this essay complimented me by suggesting that I am
prone to undervalue design originality in bazaar projects because I
have a lot of it myself, and therefore take it for granted.  There may
be some truth to this; design (as opposed to coding or debugging) is
certainly my strongest skill.</para>

<para>ผู้อ่านบทความนี้คนแรกๆ ได้ยกยอผม 
โดยบอกว่าผมหมิ่นเหม่ที่จะประเมินคุณค่าของความเป็นผู้คิดค้นในโครงการตลาดสดต่ำเกินไป 
เพราะผมมีความเป็นผู้คิดค้นอยู่ในตัว และก็เลยไม่พูดถึงมัน ก็อาจจะมีส่วนจริง 
การออกแบบเป็นความเชี่ยวชาญที่แข็งที่สุดของผม 
(ถ้าเทียบกับการเขียนโค้ดหรือการตรวจบั๊ก)</para>

<para>But the problem with being clever and original in software design is
that it gets to be a habit&mdash;you start reflexively making things cute
and complicated when you should be keeping them robust and simple.  I
have had projects crash on me because I made this mistake, but I
managed to avoid this with fetchmail.</para>

<para>แต่ปัญหาของความฉลาดและความเป็นผู้คิดค้นในการออกแบบซอฟต์แวร์ 
ก็คือมันจะกลายเป็นนิสัย กล่าวคือ คุณจะเริ่มทำอะไรเจ๋งๆ 
และซับซ้อนแบบเป็นไปโดยอัตโนมัติในจุดที่คุณควรทำให้มันเรียบง่ายและแน่นหนา 
ผมเคยทำโครงการพังเพราะทำผิดแบบนี้มาแล้ว 
แต่ผมพยายามหลีกเลี่ยงปัญหาดังกล่าวเมื่อทำ fetchmail</para>

<para>So I believe the fetchmail project succeeded partly because I
restrained my tendency to be clever; this argues (at least) against
design originality being essential for successful bazaar projects.
And consider Linux.  Suppose Linus Torvalds had been trying to pull
off fundamental innovations in operating system design during the
development; does it seem at all likely that the resulting kernel
would be as stable and successful as what we have?</para>

<para>ดังนั้น ผมจึงเชื่อว่าโครงการ fetchmail 
ประสบความสำเร็จเพราะผมงดนิสัยของผมที่จะพยายามฉลาด เรื่องนี้ 
อย่างน้อยก็สามารถค้านเรื่องที่ว่า 
ความเป็นผู้คิดค้นออกแบบเป็นสิ่งจำเป็นสำหรับความสำเร็จของโครงการตลาดสด 
และลองพิจารณาลินุกซ์ดูสิ สมมุติว่า ไลนัส ทอร์วัลด์ 
ได้พยายามดึงเอานวัตกรรมพื้นฐานของการออกแบบระบบปฏิบัติการออกไปในระหว่างการพัฒนา 
มันจะเป็นไปได้ไหมที่เคอร์เนลที่ได้จะเสถียรและประสบความสำเร็จอย่างที่เรามี?
</para>

<para>A certain base level of design and coding skill is required, of
course, but I expect almost anybody seriously thinking of launching a
bazaar effort will already be above that minimum.  The open-source
community's internal market in reputation exerts subtle pressure on
people not to launch development efforts they're not competent to
follow through on.  So far this seems to have worked pretty
well.</para>

<para>แน่นอนว่าความเชี่ยวชาญในขั้นพื้นฐานของการออกแบบและเขียนโค้ดเป็นสิ่งจำเป็น 
แต่ผมก็คาดหวังว่าใครที่คิดจะตั้งโครงการแบบตลาดสดจริงจัง 
ก็คงมีความสามารถเหนือระดับที่ต้องการอยู่แล้ว 
ตลาดของชื่อเสียงภายในชุมชนโอเพนซอร์สได้ให้แรงกดดันอย่างละเอียดอ่อนต่อผู้คน 
ที่จะไม่ตั้งโครงการพัฒนาที่ตัวเองไม่มีความสามารถจะดูแล เท่าที่ผ่านมา 
แรงกดดันดังกล่าวก็ทำงานได้ดี</para>

<para>There is another kind of skill not normally associated with
software development which I think is as important as design
cleverness to bazaar projects&mdash;and it may be more important.  A
bazaar project coordinator or leader must have good people and
communications skills.</para>

<para>ยังมีความเชี่ยวชาญอีกชนิดหนึ่งที่ไม่ได้เกี่ยวข้องกับการพัฒนาซอฟต์แวร์ 
ที่ผมคิดว่าสำคัญต่อโครงการแบบตลาดสดพอๆ กับความฉลาดในการออกแบบ 
และอาจจะสำคัญกว่าเสียด้วยซ้ำ กล่าวคือ ผู้ประสานงานหรือผู้นำโครงการแบบตลาดสด 
จะต้องมีความเชี่ยวชาญในการติดต่อสื่อสารกับผู้คน</para>

<para>This should be obvious.  In order to build a development
community, you need to attract people, interest them in what you're
doing, and keep them happy about the amount of work they're doing.
Technical sizzle will go a long way towards accomplishing this, but
it's far from the whole story.  The personality you project matters,
too.</para>

<para>เรื่องนี้ควรจะชัดเจนอยู่แล้ว ในการสร้างชุมชนพัฒนา คุณต้องดึงดูดผู้คน 
ทำให้เขาสนใจในสิ่งที่คุณทำ และทำให้เขายินดีกับปริมาณงานที่เขาทำ 
งานทางเทคนิคจะมีอยู่ตลอดเพื่อทำงานนี้ แต่เป็นเพียงส่วนน้อยของเรื่องราวทั้งหมด 
บุคลิกที่คุณแสดงออกก็มีความสำคัญเช่นกัน</para>

<para>It is not a coincidence that Linus is a nice guy who makes
people like him and want to help him.  It's not a coincidence that I'm
an energetic extrovert who enjoys working a crowd and has some of the
delivery and instincts of a stand-up comic.  To make the bazaar model
work, it helps enormously if you have at least a little skill at
charming people.</para>

<para>ไม่ใช่เรื่องบังเอิญที่ไลนัสเป็นคนนิสัยดีที่ทำให้คนที่คล้ายกับเขาต้องการช่วยเขา 
ไม่ใช่เรื่องบังเอิญที่ผมเป็นคนเปิดเผยที่มีชีวิตชีวาซึ่งชอบทำงานกับฝูงชน 
และมีสัญชาตญาณของอารมณ์ขัน ถ้าจะให้รูปแบบตลาดสดทำงานได้ 
การมีความเชี่ยวชาญในการดึงดูดผู้คนจะช่วยได้มากทีเดียว</para>

</sect1>
<!-- The Social Context of Open-Source Software -->
<sect1><title>สภาพแวดล้อมทางสังคมของซอฟต์แวร์โอเพนซอร์ส</title>

<para>It is truly written: the best hacks start out as personal solutions to
the author's everyday problems, and spread because the problem turns
out to be typical for a large class of users.  This takes us back to
the matter of rule 1, restated in a perhaps more useful way:</para>

<para>มีข้อเขียนเกี่ยวกับเรื่องนี้จริงๆ ว่าการแฮ็กที่ดีที่สุด 
เริ่มจากวิธีส่วนตัวในการแก้ปัญหาที่ตัวผู้เขียนพบในชีวิตประจำวัน 
และแพร่หลายออกไป เพราะปรากฏว่าเป็นปัญหาปกติที่ผู้ใช้จำนวนมากก็พบเช่นกัน 
เรื่องนี้นำเรากลับไปสู่กฏข้อที่ 1 
ซึ่งกล่าวใหม่ในแบบที่มีประโยชน์ขึ้นได้ว่า:</para>

<blockquote><para>18. To solve an interesting problem, start by
        finding a problem that is interesting to you.</para></blockquote>

<blockquote><para>18. การแก้ปัญหาที่น่าสนใจ เริ่มจากการค้นหาปัญหาที่คุณสนใจ
        </para></blockquote>

<para>So it was with Carl Harris and the ancestral popclient, and so with me
and fetchmail.  But this has been understood for a long time.  The
interesting point, the point that the histories of Linux and fetchmail
seem to demand we focus on, is the next stage&mdash;the evolution of
software in the presence of a large and active community of users and
co-developers.</para>

<para>ซึ่งเหมือนที่เกิดกับ คาร์ล แฮร์ริส กับ popclient รุ่นแรกๆ และกับผมกับ 
fetchmail อย่างไรก็ดี เรื่องนี้เป็นที่เข้าใจกันมานานแล้ว แต่จุดที่น่าสนใจจริงๆ 
โดยเฉพาะในประวัติของลินุกซ์และ fetchmail ที่เราต้องศึกษา ก็คือขั้นต่อไปต่างหาก 
กล่าวคือ 
วิวัฒนาการของซอฟต์แวร์ในชุมชนผู้ใช้และผู้ร่วมพัฒนาที่มีขนาดใหญ่และตื่นตัวสูง
</para>

<para>In <citetitle>The Mythical Man-Month</citetitle>, Fred Brooks
observed that programmer time is not fungible; adding developers to a
late software project makes it later.  As we've seen previously, he
argued that the complexity and communication costs of a project rise
with the square of the number of developers, while work done only
rises linearly.  Brooks's Law has been widely regarded as a truism.  But
we've examined in this essay an number of ways in which the process of
open-source development falsifies the assumptionms behind it&mdash;and,
empirically, if Brooks's Law were the whole picture Linux would be
impossible.</para>

<para>ในหนังสือ <citetitle>The Mythical Man-Month</citetitle> เฟรด บรูกส์ 
ตั้งข้อสังเกตว่า เวลาในการทำงานของโปรแกรมเมอร์นั้นทดแทนกันไม่ได้ 
การเพิ่มนักพัฒนาให้กับโครงการซอฟต์แวร์ที่ล่าช้าอยู่ 
จะทำให้มันยิ่งล่าช้ายิ่งขึ้น ดังที่เราได้กล่าวไปแล้ว 
เขาอ้างว่าความซับซ้อนและค่าโสหุ้ยในการสื่อสารของโครงการ 
จะเพิ่มขึ้นในอัตรากำลังสองของจำนวนนักพัฒนา ในขณะที่งานที่ได้ 
จะเพิ่มขึ้นเป็นลักษณะเส้นตรงเท่านั้น 
กฎของบรูกส์ได้รับการยอมรับโดยทั่วไปว่าเป็นความจริง 
แต่เราได้วิเคราะห์มาแล้วในบทความนี้ ถึงวิธีต่างๆ 
ที่กระบวนการพัฒนาแบบโอเพนซอร์สได้ทะลายข้อสมมุติต่างๆ ของกฎนี้ 
และถ้าว่ากันที่ผลในทางปฏิบัติ หากกฎของบรูกส์ครอบคลุมทั้งหมดแล้ว 
ลินุกซ์ก็คือสิ่งที่เป็นไปไม่ได้</para>

<para>Gerald Weinberg's classic <citetitle>The Psychology of Computer
Programming</citetitle> supplied what, in hindsight, we can see as a
vital correction to Brooks.  In his discussion of ``egoless
programming'', Weinberg observed that in shops where developers are
not territorial about their code, and encourage other people to look
for bugs and potential improvements in it, improvement happens
dramatically faster than elsewhere. (Recently, Kent Beck's `extreme
programming' technique of deploying coders in pairs looking over one
anothers' shoulders might be seen as an attempt to force this
effect.)</para>

<para>หนังสืออมตะของ เจอรัลด์ เวนเบิร์ก ชื่อ 
<citetitle>จิตวิทยาของการเขียนโปรแกรมคอมพิวเตอร์ (The Psychology of Computer 
Programming)</citetitle> 
เสนอสิ่งที่เราเข้าใจเบื้องหลังได้ว่าเป็นการแก้ไขกฎของบรูกส์ครั้งสำคัญ 
ในการอภิปรายเกี่ยวกับ ``การเขียนโปรแกรมแบบไร้อัตตา'' เวนเบิร์กตั้งข้อสังเกตว่า 
ในหน่วยงานที่นักพัฒนาไม่มีการหวงห้ามโค้ด และยังเชิญชวนให้คนอื่นๆ 
ให้มาช่วยกันหาข้อผิดพลาด และจุดที่อาจจะพัฒนาต่อได้ 
จะมีการพัฒนาได้เร็วกว่าหน่วยงานอื่นๆ อย่างเห็นได้ชัด (เร็วๆ นี้ เทคนิค 
`extreme programming' ของ เคนต์ เบ็ก 
ที่ให้นักพัฒนาจับคู่กันดูโค้ดกันและกัน 
อาจเป็นความพยายามหนึ่งที่จะบังคับให้เกิดผลดังกล่าว)</para>

<para>Weinberg's choice of terminology has perhaps prevented his
analysis from gaining the acceptance it deserved&mdash;one has to smile
at the thought of describing Internet hackers as ``egoless''.  But I
think his argument looks more compelling today than ever.</para>

<para>บางที การเลือกใช้คำของเวนเบิร์ก 
อาจทำให้การวิเคราะห์ของเขาไม่ได้รับการยอมรับเท่าที่ควรจะเป็น 
บางคนอาจจะอมยิ้มเมื่อนึกถึงการบรรยายถึงแฮ็กเกอร์ในอินเทอร์เน็ตด้วยคำว่า 
``ไร้อัตตา'' แต่ผมคิดว่าเหตุผลของเขานั้นดีเหลือเกิน 
โดยเฉพาะอย่างยิ่งในปัจจุบัน</para>

<para>The bazaar method, by harnessing the full power of the ``egoless
programming'' effect, strongly mitigates the effect of Brooks's Law.
The principle behind Brooks's Law is not repealed, but given a large
developer population and cheap communications its effects can be
swamped by competing nonlinearities that are not otherwise visible.
This resembles the relationship between Newtonian and Einsteinian
physics&mdash;the older system is still valid at low energies, but if you
push mass and velocity high enough you get surprises like nuclear
explosions or Linux.</para>

<para>ด้วยการใช้ประโยชน์จากผลของ ``การเขียนโปรแกรมแบบไร้อัตตา'' อย่างเต็มพิกัด  
วิธีการแบบตลาดสดได้บรรเทาผลของกฎของบรูกส์ลงอย่างมาก 
มันไม่ถึงกับทำลายหลักการเบื้องหลังของกฎของบรูกส์ลง 
แต่ด้วยจำนวนนักพัฒนาที่มากพอ และด้วยการสื่อสารที่สะดวก 
ผลของมันสามารถถูกกลบได้ด้วยปัจจัยตรงข้ามที่ไม่ได้มีลักษณะเป็นเชิงเส้น 
ซึ่งจะมองไม่เห็นจนกว่าจะเกิดเงื่อนไขดังกล่าวขึ้น เรื่องนี้ 
ก็คล้ายกับความสัมพันธ์ระหว่างฟิสิกส์แบบนิวตันและแบบไอน์สไตน์ กล่าวคือ 
ระบบเก่าก็ยังใช้การได้ที่ระดับพลังงานต่ำ แต่ถ้าคุณเพิ่มมวลและความเร็วมากพอ 
คุณก็จะพบเรื่องแปลกประหลาดอย่างการระเบิดแบบนิวเคลียร์ หรือลินุกซ์</para>

<para>The history of Unix should have prepared us for what we're
learning from Linux (and what I've verified experimentally on a
smaller scale by deliberately copying Linus's methods <link
linkend="EGCS">[EGCS]</link>).  That is, while coding remains an
essentially solitary activity, the really great hacks come from
harnessing the attention and brainpower of entire communities.  The
developer who uses only his or her own brain in a closed project is
going to fall behind the developer who knows how to create an open,
evolutionary context in which feedback exploring the design space,
code contributions, bug-spotting, and other improvements come from
from hundreds (perhaps thousands) of people.</para>

<para>ประวัติของยูนิกซ์ควรจะช่วยปูพื้นให้กับสิ่งที่เราเรียนรู้จากลินุกซ์ได้ 
(รวมทั้งสิ่งที่ผมได้ลงมือตรวจสอบผ่านการทดลองในขนาดที่เล็กลง 
ด้วยการเลียนแบบวิธีของไลนัสอย่างเจตนา <link linkend="EGCS">[EGCS]</link>) 
นั่นคือ ในขณะที่โดยเนื้อแท้แล้วการเขียนโค้ดยังคงเป็นกิจกรรมที่ต้องทำคนเดียวอยู่ 
แต่การแฮ็กที่สุดยอดจริงๆ 
กลับเกิดจากการควบคุมทิศทางความสนใจและพลังสมองของชุมชนทั้งหมด 
นักพัฒนาที่ใช้แค่สมองของตนเองในโครงการปิด 
กำลังจะถูกแซงโดยนักพัฒนาที่รู้วิธีสร้างสภาพแวดล้อมแบบเปิดเพื่อการวิวัฒน์ 
ที่ซึ่งผลตอบรับที่ช่วยสำรวจวิธีออกแบบที่เป็นไปได้ การสมทบโค้ด การชี้ข้อผิดพลาด 
และการปรับปรุงอื่นๆ จะมาจากคนเป็นร้อยๆ (หรืออาจเป็นพันๆ)</para>

<para>But the traditional Unix world was prevented from pushing this
approach to the ultimate by several factors.  One was the legal
contraints of various licenses, trade secrets, and commercial
interests.  Another (in hindsight) was that the Internet wasn't
yet good enough.</para>

<para>แต่โลกของยูนิกซ์สมัยก่อน กลับไม่สามารถใช้วิธีนี้ไปถึงจุดสูงสุดได้ 
ด้วยปัจจัยหลายประการ ปัจจัยหนึ่งก็คือข้อจำกัดทางกฎหมายของสัญญาอนุญาตแบบต่างๆ 
ความลับทางการค้า และความสนใจทางธุรกิจ นอกจากนี้ อีกปัจจัยหนึ่งที่เข้าใจได้ 
คืออินเทอร์เน็ตยังใช้การได้ไม่ดีพอในตอนนั้น</para>

<para>Before cheap Internet, there were some geographically compact
communities where the culture encouraged Weinberg's ``egoless''
programming, and a developer could easily attract a lot of skilled
kibitzers and co-developers.  Bell Labs, the MIT AI and LCS labs, UC
Berkeley&mdash;these became the home of innovations that are legendary
and still potent.</para>

<para>ก่อนที่อินเทอร์เน็ตจะมีราคาถูกอย่างทุกวันนี้ 
ได้มีชุมชนเล็กๆ ที่รวมตัวกันด้วยพื้นที่ทางภูมิศาสตร์บางกลุ่ม 
ซึ่งมีวัฒนธรรมที่สนับสนุนให้เกิดการเขียนโปรแกรมแบบ ``ไร้อัตตา'' ของเวนเบิร์ก 
และนักพัฒนาสามารถดึงดูดผู้อยากรู้อยากเห็นและผู้ร่วมพัฒนาที่มีทักษะจำนวนมากได้อย่างง่ายดาย 
ชุมชนอย่าง เบลล์แล็บ, แล็บ AI และ LCS ของ MIT, UC Berkeley 
เหล่านี้ได้กลายเป็นบ่อเกิดของนวัตกรรมระดับตำนานมากมาย 
และทุกวันนี้ชุมชนเหล่านี้ก็ยังคงแสดงศักยภาพอยู่</para>

<para>Linux was the first project for which a conscious and successful
effort to use the entire <emphasis>world</emphasis> as its talent
pool was made.  I don't think it's a coincidence that the gestation period of
Linux coincided with the birth of the World Wide Web, and that Linux
left its infancy during the same period in 1993&ndash;1994 that saw the
takeoff of the ISP industry and the explosion of mainstream interest
in the Internet.  Linus was the first person who learned how to play
by the new rules that pervasive Internet access made possible.</para>

<para>ลินุกซ์เป็นโครงการแรกที่สามารถใช้ <emphasis>โลกทั้งใบ</emphasis> 
เป็นแหล่งของพรสวรรค์ได้อย่างจงใจและประสบความสำเร็จ 
ผมไม่คิดว่ามันเป็นเรื่องบังเอิญ ที่ช่วงเวลาบ่มเพาะตัวของลินุกซ์ 
พอดีกันกับการเกิดของเครือข่ายใยแมงมุม (World Wide Web) 
และที่ลินุกซ์เริ่มเติบโตในระหว่างปี 1993&ndash;1994 
ซึ่งตรงกับช่วงที่เกิดอุตสาหกรรมการให้บริการอินเทอร์เน็ต 
และเกิดการบูมของอินเทอร์เน็ตในความสนใจกระแสหลักของผู้คน 
ไลนัสเป็นคนแรกที่รู้วิธีเล่นกับกฎเกณฑ์ใหม่ๆ ที่อินเทอร์เน็ตได้สร้างขึ้น</para>

<para>While cheap Internet was a necessary condition for the Linux model to
evolve, I think it was not by itself a sufficient condition. Another
vital factor was the development of a leadership style and set of
cooperative customs that could allow developers to attract
co-developers and get maximum leverage out of the medium.</para>

<para>แม้อินเทอร์เน็ตราคาถูก จะเป็นเงื่อนไขที่จำเป็นในการพัฒนาในแบบลินุกซ์ 
แต่ผมคิดว่าแค่สิ่งนี้อย่างเดียวยังไม่เพียงพอ ปัจจัยที่สำคัญอีกอย่างหนึ่งก็คือ 
การพัฒนาของรูปแบบความเป็นผู้นำ และประเพณีแห่งความร่วมมือต่างๆ 
ซึ่งทำให้ผู้พัฒนาสามารถดึงดูดผู้ร่วมพัฒนา 
และใช้ประโยชน์สูงสุดจากสื่ออย่างอินเทอร์เน็ต</para>

<para>But what is this leadership style and what are these customs?
They cannot be based on power relationships&mdash;and even if they could
be, leadership by coercion would not produce the results we see.
Weinberg quotes the autobiography of the 19th-century Russian
anarchist Pyotr Alexeyvich Kropotkin's <citetitle>Memoirs of a
Revolutionist</citetitle> to good effect on this subject:</para>

<para>แต่เป็นรูปแบบความเป็นผู้นำแบบไหน? และอะไรคือประเพณีต่างๆ ที่ว่า? 
สิ่งเหล่านี้ไม่สามารถได้มาจากการใช้อำนาจ หรือถึงแม้ว่ามันจะใช้ได้ 
แต่การเป็นผู้นำที่ใช้การบังคับ 
ก็ไม่สามารถสร้างผลลัพธ์อย่างที่เราเห็นอยู่ทุกวันนี้ได้ 
เวนเบิร์กยกคำกล่าวจากอัตชีวประวัติของ ปโยต์ อเล็กเซวิช โครพอตกิน (Pyotr 
Alexeyvich Kropotkin) อนาธิปัตย์ชาวรัสเซียในคริสต์ศตวรรษที่ 19 ในหนังสือ 
<citetitle>ความทรงจำของนักปฏิวัติ (Memoirs of a Revolutionist)</citetitle> 
ซึ่งเกี่ยวข้องกับเรื่องนี้อย่างมาก:</para>

<blockquote>
<para>Having been brought up in a serf-owner's family, I entered active
life, like all young men of my time, with a great deal of confidence
in the necessity of commanding, ordering, scolding, punishing and the
like. But when, at an early stage, I had to manage serious enterprises
and to deal with [free] men, and when each mistake would lead at once to
heavy consequences, I began to appreciate the difference between
acting on the principle of command and discipline and acting on the
principle of common understanding. The former works admirably in a
military parade, but it is worth nothing where real life is concerned,
and the aim can be achieved only through the severe effort of many
converging wills.</para>
</blockquote>

<blockquote>
<para>ด้วยความที่เติบโตมาในครอบครัวที่มีทาส 
ผมได้เข้าสู่ชีวิตที่กระฉับกระเฉงเหมือนๆ กับชายหนุ่มอื่นๆ ในยุคของผม 
ซึ่งมีความมั่นใจในความจำเป็นของการบังคับบัญชา การออกคำสั่ง การตำหนิ การลงโทษ 
และอะไรทำนองนี้ แต่เมื่อผมได้เริ่มบริหารบรรษัทอย่างจริงจัง 
และต้องติดต่อจัดการกับผู้คนซึ่งไม่ใช่ทาส ทั้งความผิดพลาดแต่ละครั้ง 
อาจจะนำไปสู่ความเสียหายอันใหญ่หลวง ผมก็ได้เริ่มตระหนักถึงความแตกต่างระหว่าง 
หลักแห่งการบังคับบัญชาและระเบียบวินัย กับ 
หลักแห่งการทำความเข้าใจขั้นพื้นฐานร่วมกัน 
หลักอันแรกใช้การได้ดีกับการเดินสวนสนามของทหาร 
แต่ไม่มีประโยชน์อะไรเลยในชีวิตจริง จุดหมายที่ตั้งไว้จะบรรลุได้ 
ก็ด้วยความทุ่มเทอย่างแข็งขัน 
จากเจตน์จำนงอันหลากหลายที่มีเป้าหมายร่วมกันเท่านั้น</para>
</blockquote>

<para>The ``severe effort of many converging wills'' is precisely what a
project like Linux requires&mdash;and the ``principle of command'' is
effectively impossible to apply among volunteers in the anarchist's
paradise we call the Internet. To operate and compete effectively,
hackers who want to lead collaborative projects have to learn how to
recruit and energize effective communities of interest in the mode
vaguely suggested by Kropotkin's ``principle of understanding''.  They
must learn to use Linus's Law.<link linkend="SP">[SP]</link></para>

<para>``ความทุ่มเทอย่างแข็งขัน จากเจตน์จำนงอันหลากหลายที่มีเป้าหมายร่วมกัน'' 
คือสิ่งที่โครงการอย่างลินุกซ์ต้องการอย่างไม่ต้องสงสัย และไม่มีทางที่ 
``หลักแห่งการบังคับบัญชา'' 
จะใช้ได้ผลกับเหล่าอาสาสมัครในสวรรค์ของอนาธิปัตย์ที่เราเรียกว่าอินเทอร์เน็ต 
การที่จะดำเนินงานและแข่งขันอย่างได้ผล 
เหล่าแฮ็กเกอร์ที่ต้องการจะเป็นผู้นำโครงการที่ต้องการความร่วมมือใดๆ 
จะต้องเรียนรู้วิธีที่จะสรรหาและกระตุ้นชุมชนที่สนใจจริง 
ในแบบที่กล่าวไว้อย่างหลวมๆ ใน ``หลักแห่งความเข้าใจกัน'' ของโครพอตกิน 
พวกเขาต้องเรียนรู้ที่จะใช้กฏของไลนัส <link linkend="SP">[SP]</link></para>

<para>Earlier I referred to the ``Delphi effect'' as a possible explanation
for Linus's Law.  But more powerful analogies to adaptive systems in
biology and economics also irresistably suggest themselves.  The Linux
world behaves in many respects like a free market or an ecology, a
collection of selfish agents attempting to maximize utility which in
the process produces a self-correcting spontaneous order more
elaborate and efficient than any amount of central planning could have
achieved.  Here, then, is the place to seek the ``principle of
understanding''.</para>

<para>ก่อนหน้านี้ ผมได้กล่าวถึง ``ปรากฏการณ์เดลไฟ'' 
ในฐานะคำอธิบายที่พอจะใช้ได้สำหรับกฎของไลนัส 
แต่ระบบที่ปรับตัวได้ในทางชีววิทยาและเศรษฐศาสตร์ 
ก็น่าจะเป็นตัวเปรียบเทียบที่ดีเช่นกัน โลกของลินุกซ์มีลักษณะหลายๆ 
อย่างคล้ายคลึงกับตลาดเสรีหรือระบบนิเวศน์ 
ซึ่งประกอบด้วยกลุ่มของตัวกระทำที่เห็นแก่ตัว 
ที่พยายามหาทางที่จะได้ประโยชน์สูงสุด โดยในกระบวนการนั้น 
จะเกิดการจัดระเบียบที่มีการแก้ไขตัวเองแบบเป็นไปเอง 
ซึ่งจะมีผลแทรกซึมและมีประสิทธิภาพเกินกว่าที่การวางแผนจากส่วนกลางใดๆ จะทำได้ 
และที่นี่เองที่เราจะมองหา ``หลักแห่งความเข้าใจกัน''</para>

<para>The ``utility function'' Linux hackers are maximizing is not
classically economic, but is the intangible of their own ego
satisfaction and reputation among other hackers.  (One may call their
motivation ``altruistic'', but this ignores the fact that altruism is
itself a form of ego satisfaction for the altruist).  Voluntary
cultures that work this way are not actually uncommon; one other in
which I have long participated is science fiction fandom, which unlike
hackerdom has long explicitly recognized ``egoboo'' (ego-boosting, or
the enhancement of one's reputation among other fans) as the basic
drive behind volunteer activity.</para>

<para>``ฟังก์ชันอรรถประโยชน์'' ที่แฮ็กเกอร์ลินุกซ์พยายามจะทำให้ได้มากที่สุด 
ไม่ได้เกี่ยวกับเรื่องเศรษฐกิจ 
แต่เกี่ยวกับความพึงพอใจส่วนตัวและชื่อเสียงในหมู่แฮ็กเกอร์ด้วยกัน 
(บางคนอาจเรียกแรงจูงใจของพวกเขาเหล่านั้นว่า 
``ความเห็นแก่ประโยชน์ส่วนรวม'' โดยมองข้ามความจริงที่ว่า 
``ความเห็นแก่ประโยชน์ส่วนรวม'' ก็คืออีกรูปแบบหนึ่งของความพึงพอใจส่วนตัวของ 
``ผู้ที่เห็นแก่ประโยชน์ส่วนรวม'') จะว่าไปแล้ว วัฒนธรรมอาสาสมัครในลักษณะนี้ 
ก็ไม่ใช่เรื่องพิเศษอะไร มีอีกกลุ่มหนึ่งที่ผมได้เข้าร่วมมานานแล้ว 
คือกลุ่มผู้รักนิยายวิทยาศาสตร์ 
กลุ่มนี้ต่างจากกลุ่มแฮกเกอร์ตรงที่พวกเขาตระหนักใน ``อีโก้บู'' (egoboo มาจาก 
ego-boosting หรือการเพิ่มชื่อเสียงของบุคคลในหมู่คนคลั่งไคล้สิ่งเดียวกัน) 
อย่างชัดแจ้งมาเป็นเวลานานแล้ว 
ในฐานะสิ่งจูงใจพื้นฐานในการเข้าร่วมกิจกรรมอาสาสมัคร</para>

<para>Linus, by successfully positioning himself as the gatekeeper of a
project in which the development is mostly done by others, and
nurturing interest in the project until it became self-sustaining, has
shown an acute grasp of Kropotkin's ``principle of shared
understanding''.  This quasi-economic view of the Linux world enables
us to see how that understanding is applied.</para>

<para>ไลนัส ซึ่งประสบความสำเร็จในการวางตัวเองเป็นผู้ดูแลโครงการ 
โดยที่การพัฒนาส่วนใหญ่ทำโดยคนอื่นๆ 
และเฝ้าหล่อเลี้ยงความสนใจในตัวโครงการจนกระทั่งมันอยู่ได้ด้วยตัวเอง 
ได้แสดงให้เห็นถึงความเข้าใจอันเฉียบแหลมใน ``หลักแห่งความเข้าใจร่วมกัน'' 
ของโครพอตกิน มุมมองต่อโลกของลินุกซ์ในลักษณะกึ่งเศรษฐศาสตร์แบบนี้ 
เปิดโอกาสให้เราได้เห็นว่า ความเข้าใจนั้นถูกนำไปใช้อย่างไร</para>

<para>We may view Linus's method as a way to create an efficient market in
``egoboo''&mdash;to connect the selfishness of individual hackers as firmly
as possible to difficult ends that can only be achieved by sustained
cooperation.  With the fetchmail project I have shown (albeit on a
smaller scale) that his methods can be duplicated with good results.
Perhaps I have even done it a bit more consciously and systematically
than he.</para>

<para>เราอาจจะมองวิธีของไลนัสเป็นเหมือนการสร้างตลาด ``อีโก้บู'' 
ที่มีประสิทธิภาพ 
โดยร้อยรัดความเห็นแก่ตัวของแฮ็กเกอร์แต่ละคนอย่างแน่นหนาที่สุดเท่าที่จะทำได้ 
เข้ากับปลายทางอันยากลำบาก ซึ่งจะไปถึงได้ก็ด้วยความร่วมมืออย่างไม่ลดละเท่านั้น 
อย่างในโครงการ fetchmail ผมก็ได้แสดงให้ดู (แม้จะในขนาดที่เล็กกว่า) 
ว่าวิธีของเขาสามารถทำซ้ำได้ โดยให้ผลที่ดี บางที 
ผมอาจจะทำแบบจงใจและมีแบบแผนกว่าเขานิดหน่อยด้วยซ้ำ</para>

<para>Many people (especially those who politically distrust free
markets) would expect a culture of self-directed egoists to be
fragmented, territorial, wasteful, secretive, and hostile.  But this
expectation is clearly falsified by (to give just one example) the
stunning variety, quality, and depth of Linux documentation.  It is a
hallowed given that programmers <emphasis>hate</emphasis> documenting;
how is it, then, that Linux hackers generate so much documentation?
Evidently Linux's free market in egoboo works better to produce
virtuous, other-directed behavior than the massively-funded
documentation shops of commercial software producers.</para>

<para>หลายคน (โดยเฉพาะผู้ที่มีความเคลือบแคลงทางการเมืองกับตลาดเสรี) 
อาจคาดไว้ว่า วัฒนธรรมของเหล่าคนอัตตาสูงที่เป็นตัวของตัวเอง คงจะแตกกระจาย 
แบ่งแยก สิ้นเปลือง ลึกลับ และไม่เป็นมิตร 
แต่สิ่งที่คาดไว้นั้นกลับถูกหักล้างอย่างชัดเจนโดยความหลากหลาย คุณภาพ 
และความลึกของเนื้อหาของเอกสารลินุกซ์ (หากจะยกมาเพียงตัวอย่างเดียว) 
เป็นคำสาปที่รู้กันดี ว่าโปรแกรมเมอร์นั้น <emphasis>เกลียด</emphasis> 
การเขียนเอกสาร แล้วแฮ็กเกอร์ลินุกซ์สร้างเอกสารออกมาได้มากมายอย่างนี้ได้อย่างไร? 
อย่างที่เราได้เห็น 
ตลาดเสรีสำหรับอีโก้บูของลินุกซ์สามารถสร้างพฤติกรรมที่มีคุณค่า 
และสนองความต้องการของผู้อื่น 
ได้ดีกว่าหน่วยผลิตเอกสารของผู้ผลิตซอฟต์แวร์เชิงพาณิชย์ 
ที่มีทุนสนับสนุนอย่างมหาศาลเสียอีก</para>

<para>Both the fetchmail and Linux kernel projects show that by properly
rewarding the egos of many other hackers, a strong
developer/coordinator can use the Internet to capture the benefits of
having lots of co-developers without having a project collapse into a
chaotic mess.  So to Brooks's Law I counter-propose the
following:</para>

<para>ทั้งโครงการ fetchmail และเคอร์เนลลินุกซ์ ได้แสดงให้เห็นว่า 
ด้วยการตอบแทนอัตตาของแฮกเกอร์หลายๆ คน อย่างเหมาะสม 
ผู้พัฒนาและผู้ประสานงานที่มีความสามารถ 
สามารถใช้อินเทอร์เน็ตดึงเอาข้อดีของการมีผู้ร่วมพัฒนาเยอะๆ ออกมาได้ 
โดยไม่ทำให้เกิดความสับสนอลหม่าน ดังนั้นเพื่อแย้งกับกฎของบรูกส์ 
ผมขอเสนอกฎข้อต่อไปนี้:</para>

<blockquote><para>19: Provided the development coordinator has a
    communications medium at least as good as the Internet, and knows
    how to lead without coercion, many heads are inevitably better
    than one.</para></blockquote>

<blockquote><para>19. หากผู้ประสานงานมีสื่อที่ดีอย่างน้อยเท่ากับอินเทอร์เน็ต 
    และรู้ว่าจะนำการพัฒนาโดยไม่ต้องบังคับได้อย่างไร 
    หลายหัวย่อมดีกว่าหัวเดียวแน่นอน</para></blockquote>

<para>I think the future of open-source software will increasingly
belong to people who know how to play Linus's game, people who leave
behind the cathedral and embrace the bazaar.  This is not to say that
individual vision and brilliance will no longer matter; rather, I
think that the cutting edge of open-source software will belong to
people who start from individual vision and brilliance, then amplify
it through the effective construction of voluntary communities of
interest.</para>

<para>ผมคิดว่า อนาคตของซอฟต์แวร์โอเพนซอร์ส 
จะเป็นของผู้ที่รู้วิธีเล่นเกมของไลนัสมากขึ้นเรื่อยๆ คนซึ่งหันหลังให้กับมหาวิหาร 
และอ้าแขนรับตลาดสด นี่ไม่ได้หมายความว่า 
วิสัยทัศน์และความหลักแหลมส่วนบุคคลจะไม่มีความหมายอีกต่อไป ถ้าจะพูดให้ถูก 
ผมคิดว่า ความรุดหน้าของซอฟต์แวร์โอเพนซอร์ส 
จะเป็นของผู้ที่เริ่มจากวิสัยทัศน์และความหลักแหลมเฉพาะบุคคล 
และขยายมันออกไปด้วยการสร้างชุมชนอาสาสมัครที่สนใจเรื่องนั้นอย่างเกิดผล</para>

<para>Perhaps this is not only the future of
<emphasis>open-source</emphasis> software.  No closed-source developer
can match the pool of talent the Linux community can bring to bear on
a problem.  Very few could afford even to hire the more than 200
(1999: 600, 2000: 800) people who have contributed to
fetchmail!</para>

<para>บางที นี่อาจจะไม่ได้เป็นแค่อนาคตของซอฟต์แวร์ 
<emphasis>โอเพนซอร์ส</emphasis> เท่านั้น ไม่มีผู้พัฒนาแบบซอร์สปิดรายไหน 
ที่จะเทียบเคียงได้กับศูนย์รวมของผู้มีพรสวรรค์ซึ่งชุมชนลินุกซ์สามารถใช้รับมือกับปัญหา 
และมีน้อยรายมาก ที่จะสามารถจ้างคนได้มากกว่า 200 คน 
(600 ในปี 1999, 800 ในปี 2000) อย่างกลุ่มคนที่ช่วยพัฒนา fetchmail!</para>

<para>Perhaps in the end the open-source culture will triumph not because
cooperation is morally right or software ``hoarding'' is morally wrong
(assuming you believe the latter, which neither Linus nor I do), but
simply because the closed-source world cannot win an evolutionary arms
race with open-source communities that can put orders of magnitude
more skilled time into a problem.</para>

<para>บางที ที่สุดแล้ว วัฒนธรรมโอเพนซอร์สจะประสบชัยชนะ 
ไม่ใช่เพราะความร่วมมือเป็นสิ่งที่ชอบด้วยศีลธรรม หรือ การ ``ปิดบัง'' 
ซอฟต์แวร์เป็นเรื่องผิดศีลธรรม (ในกรณีที่คุณเชื่อในอย่างหลัง 
ซึ่งทั้งไลนัสและผมไม่เชื่อ) แต่เพียงเพราะว่า 
โลกของการปิดซอร์สไม่สามารถเอาชนะการแข่งขันทางวิวัฒนาการกับชุมชนโอเพนซอร์ส 
ซึ่งสามารถระดมเวลาอันเปี่ยมไปด้วยทักษะจำนวนมาก มาให้กับปัญหาหนึ่งๆ ได้</para>

</sect1>
<!-- On Management and the Maginot Line -->
<sect1><title>เกี่ยวกับการบริหารจัดการและปัญหาที่ไม่เป็นปัญหา</title>

<para>The original <citetitle>Cathedral and Bazaar</citetitle> paper
of 1997 ended with the vision above&mdash;that of happy networked hordes
of programmer/anarchists outcompeting and overwhelming the
hierarchical world of conventional closed software.</para>

<para>บทความ <citetitle>มหาวิหารและตลาดสด</citetitle> ฉบับดั้งเดิมของปี 1997 
จบลงด้วยภาพข้างต้น 
คือภาพที่หมู่โปรแกรมเมอร์อนาธิปัตย์ที่ทำงานกันเป็นเครือข่ายอย่างมีความสุข 
เอาชนะและท่วมทับโลกแห่งลำดับชั้นการบริหารของซอฟต์แวร์ปิดแบบเก่า</para>

<para>A good many skeptics weren't convinced, however; and the questions
they raise deserve a fair engagement.  Most of the objections to the
bazaar argument come down to the claim that its proponents have
underestimated the productivity-multiplying effect of conventional
management.</para>

<para>อย่างไรก็ดี ยังมีผู้กังขาอยู่มากพอควรที่ยังไม่เชื่อ และคำถามที่พวกเขาถาม 
ก็สมควรแก่การพิจารณา ความเห็นแย้งต่อเหตุผลของตลาดสดส่วนใหญ่ มาลงเอยที่การอ้าง 
ว่าฝ่ายสนับสนุนรูปแบบตลาดสดประเมินผลของการเพิ่มพูนผลิตภาพของระบบบริหารแบบเดิมต่ำเกินไป</para>

<para>Traditionally-minded software-development managers often object that
the casualness with which project groups form and change and dissolve
in the open-source world negates a significant part of the apparent
advantage of numbers that the open-source community has over any
single closed-source developer.  They would observe that in software
development it is really sustained effort over time and the degree to
which customers can expect continuing investment in the product that
matters, not just how many people have thrown a bone in the pot and
left it to simmer.</para>

<para>ผู้จัดการโครงการพัฒนาซอฟต์แวร์แบบดั้งเดิมมักเห็นค้านว่า 
ความไม่จริงจังของกลุ่มผู้ร่วมโครงการที่มารวมตัว เปลี่ยนแปลง 
และสลายไปในโลกโอเพนซอร์สนั้น 
จะหักล้างกับส่วนสำคัญของข้อดีที่เห็นได้ชัดในเรื่องจำนวน 
ที่ชุมชนโอเพนซอร์สมีเหนือนักพัฒนาซอร์สปิดใดๆ พวกเขาจะตั้งข้อสังเกตว่า 
ในการพัฒนาซอฟต์แวร์นั้น สิ่งที่สำคัญคือความพยายามที่ยั่งยืนจริงๆ ในระยะยาว 
และการที่ลูกค้าสามารถคาดหวังการลงทุนที่ต่อเนื่องในผลิตภัณฑ์ได้ 
ไม่ใช่แค่ว่ามีคนจำนวนมากแค่ไหนที่โยนกระดูกลงหม้อแล้วรอให้แกงอุ่น</para>

<para>There is something to this argument, to be sure; in fact, I have
developed the idea that expected future service value is the key to
the economics of software production in the essay <ulink
url="http://www.tuxedo.org/~esr/writings/magic-cauldron/">
<citetitle>The Magic Cauldron</citetitle></ulink>.</para>

<para>มีประเด็นสำคัญอยู่ในข้อโต้แย้งนี้แน่นอน และอันที่จริง 
ผมได้สร้างแนวคิดที่คาดหวังว่า คุณค่าของการบริการในอนาคต 
จะเป็นกุญแจสำคัญของเศรษฐศาสตร์การผลิตซอฟต์แวร์ อยู่ในบทความ <ulink 
url="http://catb.org/~esr/writings/cathedral-bazaar/magic-cauldron/">
<citetitle>The Magic Cauldron</citetitle></ulink></para>

<para>But this argument also has a major hidden problem; its implicit
assumption that open-source development cannot deliver such sustained
effort.  In fact, there have been open-source projects that maintained
a coherent direction and an effective maintainer community over quite
long periods of time without the kinds of incentive structures or
institutional controls that conventional management finds essential.
The development of the GNU Emacs editor is an extreme and instructive
example; it has absorbed the efforts of hundreds of contributors over
15 years into a unified architectural vision, despite high turnover
and the fact that only one person (its author) has been continuously
active during all that time.  No closed-source editor has ever matched
this longevity record.</para>

<para>แต่ข้อโต้แย้งนี้ก็มีปัญหาใหญ่ซ่อนอยู่เช่นกัน คือการเข้าใจเอาว่า 
การพัฒนาแบบโอเพนซอร์สจะไม่สามารถให้ความพยายามที่ยั่งยืนแบบนั้นได้ 
อันที่จริงแล้ว ก็มีโครงการโอเพนซอร์สหลายโครงการที่ได้รักษาทิศทางที่สอดคล้อง 
และชุมชนผู้ดูแลที่มีประสิทธิภาพมาเป็นเวลานานพอสมควร 
โดยไม่ต้องอาศัยโครงสร้างของแรงจูงใจ 
หรือสายงานการบังคับบัญชาชนิดที่การบริหารแบบเดิมเห็นว่าจำเป็นเลย 
การพัฒนาบรรณาธิกรณ์ GNU Emacs เป็นตัวอย่างที่สุดขั้วและให้แง่คิดได้มาก 
โครงการนี้ ได้ซึมซับเอาความพยายามของผู้ร่วมสมทบงานเป็นร้อยๆ คน ตลอดเวลา 15 ปี 
เข้ามารวมในวิสัยทัศน์ทางสถาปัตยกรรมที่เป็นอันหนึ่งอันเดียวกัน 
แม้จะมีกิจกรรมเกิดขึ้นมากมาย และมีเพียงคนเดียว (คือตัวผู้เขียน Emacs เอง) 
ที่ได้ทำงานอย่างตื่นตัวตลอดช่วงระยะเวลาดังกล่าว 
ไม่มีโปรแกรมบรรณาธิกรณ์ซอร์สปิดตัวไหน ที่จะมีสถิติยาวนานเทียบเท่าได้</para>

<para>This suggests a reason for questioning the advantages of
conventionally-managed software development that is independent of the
rest of the arguments over cathedral vs. bazaar mode.  If it's
possible for GNU Emacs to express a consistent architectural vision
over 15 years, or for an operating system like Linux to do the
same over 8 years of rapidly changing hardware and platform
technology; and if (as is indeed the case) there have been many
well-architected open-source projects of more than 5 years duration
-- then we are entitled to wonder what, if anything, the tremendous
overhead of conventionally-managed development is actually buying
us.</para>

<para>ตัวอย่างนี้ อาจเป็นเหตุผลให้เราตั้งคำถามกลับ 
เกี่ยวกับข้อดีของการพัฒนาซอฟต์แวร์ที่บริหารในแบบเดิม 
โดยไม่ได้เกี่ยวข้องกับส่วนที่เหลือของข้อโต้แย้งระหว่างรูปแบบมหาวิหารกับตลาดสดเลย 
ถ้ามันเป็นไปได้สำหรับ GNU Emacs 
ที่จะแสดงวิสัยทัศน์ทางสถาปัตยกรรมที่คงเส้นคงวาตลอดเวลา 15 ปี 
หรือสำหรับระบบปฏิบัติการอย่างลินุกซ์ ที่จะทำอย่างเดียวกันได้ตลอดเวลา 8 ปี 
ท่ามกลางการเปลี่ยนแปลงอย่างรวดเร็วของเทคโนโลยีฮาร์ดแวร์และแพล็ตฟอร์ม 
และถ้ามีโครงการโอเพนซอร์สที่มีการออกแบบสถาปัตยกรรมเป็นอย่างดีจำนวนมาก 
ที่มีช่วงเวลาการทำงานเกิน 5 ปี (ซึ่งก็มีจริงๆ) แล้วล่ะก็ 
เราก็ต้องตั้งข้อสงสัยแล้วล่ะ ว่าค่าโสหุ้ยหนักๆ ของการพัฒนาด้วยการบริหารแบบเก่า 
จะให้อะไรแก่เราเป็นการตอบแทน (ถ้ามี)</para>

<para>Whatever it is certainly doesn't include reliable execution by
deadline, or on budget, or to all features of the specification; it's
a rare `managed' project that meets even one of these goals, let alone
all three. It also does not appear to be ability to adapt to changes
in technology and economic context during the project lifetime,
either; the open-source community has proven <emphasis>far</emphasis>
more effective on that score (as one can readily verify, for example,
by comparing the 30-year history of the Internet with the short
half-lives of proprietary networking technologies&mdash;or the cost of
the 16-bit to 32-bit transition in Microsoft Windows with the nearly
effortless upward migration of Linux during the same period, not only
along the Intel line of development but to more than a dozen other
hardware platforms, including the 64-bit Alpha as well).</para>

<para>ไม่ว่ามันจะเป็นอะไร แต่ไม่ใช่การดำเนินการที่รับประกันได้ในเรื่องกำหนดการ 
การใช้งบประมาณ หรือการทำได้ครบตามข้อกำหนดแน่ๆ หายากมากที่จะมีโครงการที่ 
`มีการจัดการ' ที่สามารถบรรลุเป้าหมายใดเป้าหมายหนึ่งได้ 
โดยไม่ต้องพูดถึงการบรรลุครบทั้งสามเป้าหมายเลย 
และดูจะไม่ใช่ความสามารถในการปรับตัวตามการเปลี่ยนแปลงของเทคโนโลยี 
และบริบททางเศรษฐกิจในช่วงชีวิตของโครงการเช่นกัน 
ชุมชนโอเพนซอร์สได้พิสูจน์ให้เห็นถึงประสิทธิผลที่มากกว่า 
<emphasis>มาก</emphasis> ในแง่ดังกล่าว (เช่น ดังที่ใครก็สามารถตรวจสอบได้ 
โดยเปรียบเทียบประวัติศาสตร์ 30 ปีของอินเทอร์เน็ต กับครึ่งชีวิตที่สั้นๆ 
ของเทคโนโลยีเครือข่ายที่สงวนสิทธิ์ หรือเปรียบเทียบค่าโสหุ้ยของการย้ายจาก 16 บิต 
ไป 32 บิต ในไมโครซอฟท์วินโดวส์ 
กับการเปลี่ยนรุ่นของลินุกซ์ที่แทบไม่ต้องใช้ความพยายามเลยในช่วงเดียวกัน 
ไม่ใช่แค่ตามสายการพัฒนาของอินเทลเท่านั้น 
แต่รวมถึงการย้ายไปยังฮาร์ดแวร์ชนิดอื่นกว่า 12 ชนิด รวมถึงชิปแอลฟา 64 
บิตด้วย)</para>

<para>One thing many people think the traditional mode buys you is somebody
to hold legally liable and potentially recover compensation from if
the project goes wrong.  But this is an illusion; most software
licenses are written to disclaim even warranty of merchantability, let
alone performance&mdash;and cases of successful recovery for software
nonperformance are vanishingly rare.  Even if they were common,
feeling comforted by having somebody to sue would be missing the
point.  You didn't want to be in a lawsuit; you wanted working
software.</para>

<para>สิ่งหนึ่งที่หลายคนคิดว่าการพัฒนาแบบเก่าจะให้ตอบแทนได้ 
คือใครบางคนที่จะให้สัญญาทางกฎหมาย 
และค่าชดเชยสำหรับการฟื้นตัวในกรณีที่โครงการมีปัญหา 
แต่เรื่องดังกล่าวเป็นเพียงมายาภาพ สัญญาอนุญาตซอฟต์แวร์เกือบทั้งหมด 
ได้เขียนถึงการสงวนการรับผิดชอบแม้กระทั่งการรับประกันคุณค่าเชิงการค้า 
ไม่ต้องพูดถึงเรื่องการทำงานเลย 
และกรณีของการฟื้นตัวหลังซอฟต์แวร์ไม่ทำงานได้สำเร็จก็หายากเต็มที 
หรือแม้จะมีเป็นเรื่องปกติ การรู้สึกสบายใจที่มีใครให้ฟ้องร้องได้ 
ก็เป็นการผิดประเด็น คุณไม่อยากขึ้นโรงขึ้นศาลหรอก 
คุณต้องการซอฟต์แวร์ที่ทำงานได้ต่างหาก</para>

<para>So what is all that management overhead buying?</para>

<para>ฉะนั้นแล้ว อะไรคือสิ่งที่จะได้จากการจ่ายค่าโสหุ้ยของการบริหารดังกล่าว?
</para>

<para>In order to understand that, we need to understand what software
development managers believe they do.  A woman I know who seems to
be very good at this job says software project management has five
functions:</para>

<para>เพื่อที่จะเข้าใจเรื่องดังกล่าว เราต้องเข้าใจเสียก่อน 
ว่าผู้บริหารโครงการพัฒนาซอฟต์แวร์คิดว่าเขากำลังทำอะไรอยู่ 
หญิงสาวคนหนึ่งที่ผมรู้จัก ซึ่งดูจะถนัดเรื่องนี้ บอกว่า 
การบริหารโครงการซอฟต์แวร์ประกอบด้วยหน้าที่ห้าอย่าง:</para>

<itemizedlist>
<listitem><para> To <emphasis>define goals</emphasis> and keep
everybody pointed in the same direction</para></listitem>

<listitem><para><emphasis>กำหนดเป้าหมาย</emphasis> 
และทำให้ทุกคนเดินหน้าไปในทิศทางเดียวกัน</para></listitem>

<listitem><para> To <emphasis>monitor</emphasis> and make sure crucial
details don't get skipped</para></listitem>

<listitem><para><emphasis>ตรวจสอบ</emphasis> 
และทำให้แน่ใจว่าไม่มีการข้ามรายละเอียดที่สำคัญ</para></listitem>

<listitem><para>To <emphasis>motivate</emphasis> people to do boring but necessary drudgework</para></listitem>

<listitem><para><emphasis>กระตุ้น</emphasis> ผู้คนให้ทำงานส่วนที่น่าเบื่อ 
แต่จำเป็น</para></listitem>

<listitem><para>To <emphasis>organize</emphasis> the deployment of
people for best productivity</para></listitem>

<listitem><para><emphasis>แบ่งงาน</emphasis> ให้กับบุคคลต่างๆ 
เพื่อผลการทำงานที่ดี</para></listitem>

<listitem><para>To <emphasis>marshal resources</emphasis> needed to
sustain the project</para></listitem>

<listitem><para><emphasis>จัดสรรทรัพยากร</emphasis> 
ที่จำเป็นสำหรับการดำเนินโครงการ</para></listitem>
</itemizedlist>

<para>Apparently worthy goals, all of these; but under the open-source
model, and in its surrounding social context, they can begin to seem
strangely irrelevant.  We'll take them in reverse order.</para>

<para>เป็นเป้าหมายที่คุ้มค่า ทุกข้อเลย แต่ในรูปแบบโอเพนซอร์ส 
และในสภาพแวดล้อมทางสังคมที่เกี่ยวข้อง เรื่องต่างๆ 
ดังกล่าวกลับเริ่มจะไม่มีผลอย่างน่าประหลาด 
เราจะพิจารณาแต่ละข้อในลำดับย้อนกลับ</para>

<para>My friend reports that a lot of <emphasis>resource
marshalling</emphasis> is basically defensive; once you have your
people and machines and office space, you have to defend them from
peer managers competing for the same resources, and from higher-ups trying
to allocate the most efficient use of a limited pool.</para>

<para>เพื่อนของผมรายงานว่า <emphasis>การจัดสรรทรัพยากร</emphasis> 
โดยทั่วไปเป็นการปกป้อง เมื่อคุณมีคน มีเครื่อง และมีพื้นที่สำนักงานแล้ว 
คุณต้องปกป้องสิ่งเหล่านั้นจากผู้จัดการโครงการอื่นๆ 
ที่จะแข่งขันยื้อแย่งทรัพยากรเดียวกัน 
และจากผู้บริหารระดับบนที่พยายามจะจัดสรรทรัพยากรที่มีจำกัด 
เพื่อใช้ให้เกิดประโยชน์สูงสุด</para>

<para>But open-source developers are volunteers, self-selected for both
interest and ability to contribute to the projects they work on (and
this remains generally true even when they are being paid a salary to
hack open source.)  The volunteer ethos tends to take care of the
`attack' side of resource-marshalling automatically; people bring
their own resources to the table.  And there is little or no need for
a manager to `play defense' in the conventional sense.</para>

<para>แต่นักพัฒนาโอเพนซอร์สล้วนแต่เป็นอาสาสมัคร และได้คัดเลือกตัวเอง 
ทั้งในเรื่องความสนใจและความสามารถในการร่วมงานกับโครงการที่ตนทำงานอยู่แล้ว 
(และโดยทั่วไป เรื่องนี้ก็ยังเป็นจริง 
แม้ในกรณีที่ถูกจ้างด้วยเงินเดือนให้แฮ็กโอเพนซอร์ส) 
แนวความคิดของตัวอาสาสมัครเองมีแนวโน้มจะดูแลด้าน `รุกล้ำ' 
ของการจัดสรรทรัพยากรโดยอัตโนมัติอยู่แล้ว ผู้คนจะนำทรัพยากรของตนมาใช้ในงานเอง 
และผู้จัดการโครงการก็มีความจำเป็นน้อยมาก หรือไม่มีความจำเป็นเลย ที่จะต้อง 
`เล่นบทปกป้อง' ในความหมายปกติ</para>

<para>Anyway, in a world of cheap PCs and fast Internet links, we find
pretty consistently that the only really limiting resource is skilled
attention.  Open-source projects, when they founder, essentially
never do so for want of machines or links or office space; they
die only when the developers themselves lose interest.</para>

<para>อย่างไรก็ดี ในโลกของพีซีราคาถูก และอินเทอร์เน็ตความเร็วสูง 
เราพบอยู่เนืองๆ ว่าทรัพยากรที่มีจำกัดเพียงอย่างเดียว 
ก็คือความสนใจของคนที่เชี่ยวชาญ โครงการโอเพนซอร์สเมื่อจะล่มนั้น 
ไม่ได้ล่มเพราะขาดเครื่องหรือเครือข่ายหรือพื้นที่สำนักงานเลย 
แต่จะตายเมื่อนักพัฒนาเองขาดความสนใจในโครงการอีกต่อไปเท่านั้น</para>

<para>That being the case, it's doubly important that open-source
hackers <emphasis>organize themselves</emphasis> for maximum
productivity by self-selection&mdash;and the social milieu selects
ruthlessly for competence.  My friend, familiar with both the
open-source world and large closed projects, believes that open source
has been successful partly because its culture only accepts the most
talented 5% or so of the programming population.  She spends most of
her time organizing the deployment of the other 95%, and has thus
observed first-hand the well-known variance of a factor of one hundred
in productivity between the most able programmers and the merely
competent.</para>

<para>เมื่อเป็นดังนั้น เรื่องที่สำคัญเป็นสองเท่า 
ก็คือแฮ็กเกอร์โอเพนซอร์สนั้น <emphasis>แบ่งงานตัวเอง</emphasis> 
เพื่อผลิตภาพสูงสุดด้วยการพิจารณาตัวเอง 
อีกทั้งสภาพแวดล้อมทางสังคมก็จะเลือกคนตามความสามารถอย่างไร้ความปรานี 
เพื่อนผมซึ่งคุ้นเคยกับทั้งโลกโอเพนซอร์สและโครงการปิดขนาดใหญ่ 
เชื่อว่าที่โอเพนซอร์สประสบความสำเร็จ 
ส่วนหนึ่งเป็นเพราะวัฒนธรรมของมันยอมรับเฉพาะผู้มีพรสวรรค์ 5% 
แรกของประชากรโปรแกรมเมอร์เท่านั้น และเธอใช้เวลาเกือบทั้งหมดของเธอ 
ในการบริหารการใช้งานประชากรอีก 95% ที่เหลือ และเธอจึงได้มีโอกาสสังเกตโดยตรง 
ถึงความแตกต่างของผลิตภาพถึงร้อยเท่า ระหว่างโปรแกรมเมอร์ที่เก่งสุดๆ 
กับโปรแกรมเมอร์ที่แค่มีความสามารถธรรมดา</para>

<para>The size of that variance has always raised an awkward question: would
individual projects, and the field as a whole, be better off without
more than 50% of the least able in it?  Thoughtful managers have
understood for a long time that if conventional software management's
only function were to convert the least able from a net loss to a
marginal win, the game might not be worth the candle.</para>

<para>ขนาดของความแตกต่างดังกล่าว ได้ทำให้เกิดคำถามเสมอๆ ว่า 
โครงการแต่ละโครงการ รวมทั้งภาพรวมของวงการทั้งหมด จะดีขึ้นไหม ถ้าไม่มีคนกว่า 50% 
ที่ด้อยความสามารถเหล่านั้น? ผู้บริหารโครงการที่ชอบใคร่ครวญ 
จะเข้าใจมาเป็นเวลานานแล้ว ว่าถ้าหน้าที่เดียวของการบริหารโครงการซอฟต์แวร์แบบเดิม 
คือการเปลี่ยนคนที่เก่งน้อยที่สุด จากการขาดทุนสุทธิ ให้ไปเป็นกำไรแล้วล่ะก็ 
จะเป็นเรื่องที่ไม่คุ้มค่าเอาเสียเลย</para>

<para>The success of the open-source community sharpens this question
considerably, by providing hard evidence that it is often cheaper and
more effective to recruit self-selected volunteers from the Internet
than it is to manage buildings full of people who would rather be
doing something else.</para>

<para>ความสำเร็จของชุมชนโอเพนซอร์สได้เพิ่มความแหลมคมของคำถามนี้ขึ้นไปอีก 
โดยให้หลักฐานที่ชัดเจน 
ว่าการใช้อาสาสมัครจากอินเทอร์เน็ตที่ได้กลั่นกรองตัวเองมาก่อนแล้ว 
จะเสียค่าใช้จ่ายน้อยกว่า 
และมีประสิทธิภาพกว่าการบริหารตึกที่เต็มไปด้วยคนที่อาจจะอยากทำอย่างอื่นมากกว่า
</para>

<para>Which brings us neatly to the question of
<emphasis>motivation</emphasis>.  An equivalent and often-heard way to
state my friend's point is that traditional development management is
a necessary compensation for poorly motivated programmers who would
not otherwise turn out good work.</para>

<para>ซึ่งนำเรามาสู่คำถามเรื่อง <emphasis>การกระตุ้น</emphasis> อย่างเหมาะเจาะ 
วิธีที่เทียบเคียงและได้ยินบ่อยๆ ในการบรรยายประเด็นของเพื่อนผม 
คือว่าการบริหารงานพัฒนาแบบเดิมนั้น 
เป็นการชดเชยที่จำเป็นสำหรับโปรแกรมเมอร์ที่ขาดแรงจูงใจ 
ซึ่งจะไม่ทำงานให้ดีถ้าไม่มีการกระตุ้น</para>

<para>This answer usually travels with a claim that the open-source
community can only be relied on only to do work that is `sexy' or
technically sweet; anything else will be left undone (or done only
poorly) unless it's churned out by money-motivated cubicle peons with
managers cracking whips over them.  I address the psychological and
social reasons for being skeptical of this claim in <ulink
url="http://www.tuxedo.org/~esr/magic-cauldron/"><citetitle>Homesteading the
Noosphere</citetitle></ulink>.  For present purposes, however, I think it's
more interesting to point out the implications of accepting it as
true.</para>

<para>คำตอบนี้ มักจะมาพร้อมกับการกล่าวอ้าง ว่าชุมชนโอเพนซอร์สจะพึ่งพาได้ 
ก็แต่สำหรับงานที่ `เจ๋ง' หรือเย้ายวนทางเทคนิคเท่านั้น ส่วนที่เหลือจะถูกทิ้งร้าง 
(หรือทำอย่างลวกๆ) ถ้าไม่ถูกปั่นโดยผู้ใช้แรงงานในคอกที่มีเงินกระตุ้น 
มีผู้บริหารโครงการโบยแส้ให้ทำงาน 
ผมได้ให้เหตุผลทางจิตวิทยาและสังคมสำหรับการตั้งข้อสงสัยในข้ออ้างนี้ใน <ulink 
url="http://catb.org/~esr/writings/cathedral-bazaar/homesteading/"><citetitle>Homesteading the 
Noosphere</citetitle></ulink> แต่อย่างไรก็ดี เพื่อจุดประสงค์ในขณะนี้ 
ผมคิดว่าการชี้ถึงนัยของการยอมรับว่าเรื่องนี้เป็นเรื่องจริง จะน่าสนใจกว่า</para>

<para>If the conventional, closed-source, heavily-managed style of
software development is really defended only by a sort of Maginot Line
of problems conducive to boredom, then it's going to remain viable in
each individual application area for only so long as nobody finds
those problems really interesting and nobody else finds any way to
route around them. Because the moment there is open-source competition
for a `boring' piece of software, customers are going to know that it
was finally tackled by someone who chose that problem to solve because
of a fascination with the problem itself&mdash;which, in software as in
other kinds of creative work, is a far more effective motivator than
money alone.</para>

<para>ถ้ารูปแบบการพัฒนาซอฟต์แวร์ในแบบเดิมซึ่งปิดซอร์สและมีการจัดการอย่างเข้มข้น 
จะมีเหตุผลสนับสนุนเพียงเพราะเรื่องปัญหาที่นำไปสู่ความเบื่อหน่ายแล้วล่ะก็ 
มันก็จะมีผลอยู่ในแต่ละส่วนของโปรแกรมในระหว่างที่ไม่มีใครเห็นว่าปัญหานั้นน่าสนใจ 
และไม่มีใครอีกที่จะกล้ำกรายเข้าไปใกล้เท่านั้น 
เพราะเมื่อมีการแข่งขันของโอเพนซอร์สเกี่ยวกับซอฟต์แวร์ส่วนที่ `น่าเบื่อ' 
ผู้ใช้ก็จะรู้เอง 
ว่าปัญหาจะถูกแก้ในที่สุดโดยใครบางคนที่เลือกปัญหานั้นเพราะความน่าสนใจของปัญหาเอง 
ซึ่งสำหรับซอฟต์แวร์ในฐานะงานสร้างสรรค์แล้ว 
เป็นสิ่งกระตุ้นที่ได้ผลกว่าเงินเพียงอย่างเดียว</para>

<para>Having a conventional management structure solely in order to
motivate, then, is probably good tactics but bad strategy; a
short-term win, but in the longer term a surer loss.</para>

<para>ดังนั้น การมีโครงสร้างการบริหารแบบเดิมเพียงอย่างเดียวเพื่อสร้างแรงกระตุ้น 
จึงอาจเป็นเทคนิคที่ดี แต่เป็นกลยุทธ์ที่แย่ 
เพราะอาจจะได้ประโยชน์ในระยะสั้นก็จริง แต่ในระยะยาวแล้ว 
จะสูญเสียอย่างแน่นอน</para>

<para>So far, conventional development management looks like a bad bet
now against open source on two points (resource marshalling,
organization), and like it's living on borrowed time with respect to a
third (motivation).  And the poor beleaguered conventional manager is
not going to get any succour from the <emphasis>monitoring</emphasis>
issue; the strongest argument the open-source community has is that
decentralized peer review trumps all the conventional methods for
trying to ensure that details don't get slipped.</para>

<para>เท่าที่ผ่านมา การบริหารงานพัฒนาแบบเดิม 
ดูจะไม่ใช่ทางเลือกที่ดีเมื่อเทียบกับโอเพนซอร์สในสองประเด็น (การจัดสรรทรัพยากร 
และการแบ่งงาน) และดูเหมือนจะใช้ได้แค่ชั่วคราวในประเด็นที่สาม (การกระตุ้น) 
และผู้บริหารโครงการแบบเก่าผู้ถูกคุกคามอย่างน่าสงสาร 
ก็จะไม่ได้คะแนนช่วยจากประเด็น <emphasis>การตรวจสอบ</emphasis> เลย 
ข้อโต้แย้งที่แข็งที่สุดที่ชุมชนโอเพนซอร์สมี 
ก็คือว่าการตรวจทานโดยนักพัฒนาอื่นแบบกระจายกำลัง จะชนะวิธีเดิมๆ 
ทั้งหมดในการตรวจสอบให้แน่ใจว่าไม่มีรายละเอียดต่างๆ หลุดรอดไป</para>

<para>Can we save <emphasis>defining goals</emphasis> as a
justification for the overhead of conventional software project
management?  Perhaps; but to do so, we'll need good reason to believe
that management committees and corporate roadmaps are more successful
at defining worthy and widely shared goals than the project leaders
and tribal elders who fill the analogous role in the open-source
world.</para>

<para>เราสามารถเก็บประเด็น <emphasis>การกำหนดเป้าหมาย</emphasis> 
ไว้เป็นเหตุผลสำหรับการยอมเสียค่าโสหุ้ยให้กับการบริหารโครงการซอฟต์แวร์แบบเดิมได้ไหม? 
ก็อาจจะได้ แต่การจะยอมรับ เราก็ต้องการเหตุผลที่ดีที่จะเชื่อ 
ว่าคณะกรรมการบริหารและแผนงานของบริษัท 
จะประสบความสำเร็จในการกำหนดเป้าหมายที่คุ้มค่าและเห็นร่วมกันอย่างกว้างขวาง 
มากกว่าผู้นำโครงการและสมาชิกอาวุโสซึ่งทำหน้าที่คล้ายกันนี้ในโลกโอเพนซอร์ส</para>

<para>That is on the face of it a pretty hard case to make.  And it's not so
much the open-source side of the balance (the longevity of Emacs, or
Linus Torvalds's ability to mobilize hordes of developers with talk of
``world domination'') that makes it tough.  Rather, it's the
demonstrated awfulness of conventional mechanisms for defining the
goals of software projects.</para>

<para>เรื่องนี้ค่อนข้างจะเชื่อได้ยาก ไม่ใช่เพราะข้อมูลสนับสนุนของฝ่ายโอเพนซอร์ส 
(ความยืนยาวของ Emacs หรือความสามารถของ ไลนัส ทอร์วัลด์ 
ในการขับเคลื่อนหมู่นักพัฒนาด้วยการพูดเกี่ยวกับ ``การครองโลก'') 
ที่ทำให้เชื่อได้ยาก แต่เป็นเพราะความน่ากลัวที่ได้แสดงให้เห็นของกลไกแบบเดิม 
ในการกำหนดเป้าหมายของโครงการซอฟต์แวร์มากกว่า</para>

<para>One of the best-known folk theorems of software engineering is that
60% to 75% of conventional software projects either are never
completed or are rejected by their intended users.  If that range is
anywhere near true (and I've never met a manager of any experience who
disputes it) then more projects than not are being aimed at goals
that are either (a) not realistically attainable, or (b) just plain
wrong.</para>

<para>ทฤษฎีชาวบ้านที่รู้จักกันดีที่สุดทฤษฎีหนึ่งของวิศวกรรมซอฟต์แวร์ 
ก็คือร้อยละ 60 ถึง 70 ของโครงการซอฟต์แวร์แบบเดิม จะไม่เคยเสร็จ 
หรือไม่ก็ถูกผู้ใช้กลุ่มเป้าหมายปฏิเสธ 
ถ้าอัตราส่วนดังกล่าวใกล้เคียงกับความเป็นจริง 
(ซึ่งผมก็ไม่เคยเห็นผู้บริหารที่มีประสบการณ์คนไหนกล้าเถียง) ก็หมายความว่า 
มีโครงการส่วนใหญ่ที่กำลังมุ่งสู่เป้าหมายที่ (ก) ไม่สามารถบรรลุได้ในความเป็นจริง 
หรือ (ข) ผิดพลาด</para>

<para>This, more than any other problem, is the reason that in today's
software engineering world the very phrase ``management committee'' is
likely to send chills down the hearer's spine&mdash;even (or perhaps
especially) if the hearer is a manager.  The days when only programmers
griped about this pattern are long past; Dilbert cartoons hang over
<emphasis>executives'</emphasis> desks now.</para>

<para>เรื่องนี้เป็นเหตุผลมากกว่าเรื่องอื่นๆ 
ที่ทำให้ในโลกวิศวกรรมซอฟต์แวร์ทุกวันนี้ วลี ``คณะบริหาร'' 
มักจะทำให้ผู้ที่ได้ยินต้องเสียวสันหลังวาบ แม้ว่า (หรือบางที โดยเฉพาะถ้า) 
ผู้ที่ได้ยินนั้นเป็นผู้บริหารเช่นกัน 
วันที่เรื่องนี้เป็นที่รู้กันเฉพาะในหมู่โปรแกรมเมอร์ ได้ผ่านไปนานแล้ว 
การ์ตูนดิลเบิร์ตทุกวันนี้ ไปไม่ค่อยพ้นโต๊ะของ <emphasis>ผู้บริหาร</emphasis> 
หรอก</para>

<para>Our reply, then, to the traditional software development manager, is
simple&mdash;if the open-source community has really underestimated the
value of conventional management, <emphasis>why do so many of you display
contempt for your own process?</emphasis></para>

<para>ดังนั้น คำตอบของเราสำหรับนักบริหารโครงการพัฒนาซอฟต์แวร์แบบเดิม จึงง่ายดาย 
กล่าวคือ ถ้าชุมชนโอเพนซอร์สประเมินค่าของการบริหารแบบเดิมต่ำเกินไปแล้วล่ะก็ 
<emphasis>ทำไมพวกคุณจำนวนมากถึงได้ดูแคลนกระบวนการของคุณเองเล่า?</emphasis>
</para>

<para>Once again the example of the open-source community sharpens
this question considerably&mdash;because we have <emphasis>fun</emphasis>
doing what we do.  Our creative play has been racking up technical,
market-share, and mind-share successes at an astounding rate.  We're
proving not only that we can do better software, but that
<emphasis>joy is an asset</emphasis>.</para>

<para>อีกครั้งที่ตัวอย่างของชุมชนโอเพนซอร์สได้เพิ่มความแหลมคมให้กับคำถามนี้อย่างชัดเจน 
เพราะเรา <emphasis>สนุก</emphasis> กับสิ่งที่เราทำนั่นเอง 
งานสร้างสรรค์ของเราประสบผลสำเร็จทั้งทางเทคนิค ส่วนแบ่งตลาด และความยอมรับ 
ในอัตราที่น่าอัศจรรย์ เราได้พิสูจน์แล้ว 
ไม่เพียงแค่ว่าเราสามารถพัฒนาซอฟต์แวร์ที่ดีกว่าได้ แต่ยังพิสูจน์ด้วยว่า 
<emphasis>ความรื่นเริงคือทรัพย์สิน</emphasis></para>

<para>Two and a half years after the first version of this essay, the
most radical thought I can offer to close with is no longer a vision
of an open-source&ndash;dominated software world; that, after all,
looks plausible to a lot of sober people in suits these days.</para>

<para>สองปีครึ่งหลังจากเขียนบทความนี้รุ่นแรก 
แนวคิดระดับรากฐานที่สุดที่ผมสามารถให้ได้เพื่อสรุปเรื่องทั้งหมด 
ไม่ใช่วิสัยทัศน์ของโลกซอฟต์แวร์ที่โอเพนซอร์สเป็นใหญ่ 
ซึ่งดูเป็นไปได้สำหรับคนปกติทั่วไปในทุกวันนี้</para>

<para>Rather, I want to suggest what may be a wider lesson about
software, (and probably about every kind of creative or professional
work).  Human beings generally take pleasure in a task when it falls
in a sort of optimal-challenge zone; not so easy as to be boring, not
too hard to achieve.  A happy programmer is one who is neither
underutilized nor weighed down with ill-formulated goals and stressful
process friction.  <emphasis>Enjoyment predicts
efficiency.</emphasis></para>

<para>แต่ผมต้องการชี้แนะในสิ่งที่อาจเป็นบทเรียนที่กว้างขึ้นเกี่ยวกับซอฟต์แวร์ 
(และอาจจะเกี่ยวกับงานสร้างสรรค์และงานวิชาชีพทุกชนิด) 
มนุษย์มักจะมีความยินดีกับงานเมื่อมันมีความท้าทายที่เหมาะสม ไม่ง่ายจนน่าเบื่อ 
และไม่ยากจนไม่สามารถบรรลุได้ โปรแกรมเมอร์ที่มีความสุข 
ก็คือคนที่ไม่ถูกใช้งานต่ำเกินไป หรือต้องแบกรับเป้าหมายที่กำหนดไว้ชุ่ยๆ 
โดยมีแรงเสียดทานต่อการทำงานอย่างเคร่งเครียด 
<emphasis>ความรื่นเริงจะให้ประสิทธิภาพ</emphasis></para>

<para>Relating to your own work process with fear and loathing (even in the
displaced, ironic way suggested by hanging up Dilbert cartoons) should
therefore be regarded in itself as a sign that the process has failed.
Joy, humor, and playfulness are indeed assets; it was not mainly for
the alliteration that I wrote of "happy hordes" above, and it is no
mere joke that the Linux mascot is a cuddly, neotenous penguin.</para>

<para>ถ้าคุณรู้สึกถึงความเกลียดและความกลัวเมื่อนึกถึงกระบวนการทำงานของคุณ 
(แม้จะในแบบประชดประชันตามแบบการ์ตูนดิลเบิร์ตก็ตาม) 
ก็ควรถือว่านั่นเป็นเครื่องหมายบ่งชี้ว่ากระบวนการได้ล้มเหลวเสียแล้ว 
ความรื่นเริง อารมณ์ขัน และความขี้เล่น เป็นทรัพย์สินอย่างแท้จริง 
มันไม่ใช่การทำให้ดูเพราะพริ้งเมื่อผมเขียนถึง "หมู่โปรแกรมเมอร์ผู้มีความสุข" 
และก็ไม่ใช่เรื่องขบขันเลยที่สัตว์นำโชคของลินุกซ์เป็นนกเพนกวินแรกรุ่นอ้วนจ้ำม่ำ
</para>

<para>It may well turn out that one of the most important effects of
open source's success will be to teach us that play is the
most economically efficient mode of creative work.</para>

<para>กลายเป็นว่า ผลที่สำคัญที่สุดอย่างหนึ่งของความสำเร็จของโอเพนซอร์ส 
ก็คือการสอนเรา 
ว่าการเล่นเป็นวิธีที่มีประสิทธิภาพทางเศรษฐกิจที่สุดสำหรับงานสร้างสรรค์</para>

</sect1>
<!-- Epilog: Netscape Embraces the Bazaar -->
<sect1><title>ส่งท้าย: เน็ตสเคปอ้าแขนรับตลาดสด</title>

<para>It's a strange feeling to realize you're helping make history....</para>

<para>เป็นความรู้สึกที่แปลกที่ได้รู้ว่า คุณกำลังร่วมสร้างประวัติศาสตร์...</para>

<para>On January 22 1998, approximately seven months after I first
published <citetitle>The Cathedral and the Bazaar</citetitle>,
Netscape Communications, Inc. announced plans to <ulink
url="http://www.netscape.com/newsref/pr/newsrelease558.html"> give
away the source for Netscape Communicator</ulink>.  I had had no clue
this was going to happen before the day of the announcement.</para>

<para>วันที่ 22 มกราคม 1998 ประมาณเจ็ดเดือนหลังจากที่ผมเผยแพร่บทความ 
<citetitle>มหาวิหารกับตลาดสด</citetitle> บริษัท เน็ตสเคป คอมมิวนิเคชัน 
ได้ประกาศแผนที่จะ <ulink 
url="http://www.netscape.com/newsref/pr/newsrelease558.html">แจกซอร์สของ 
Netscape Communicator</ulink> ผมไม่เคยคาดคิดมาก่อนเลย ว่าสิ่งนี้จะเกิดขึ้น 
จนถึงวันประกาศ</para>

<para>Eric Hahn, executive vice president and chief technology officer at
Netscape, emailed me shortly afterwards as follows: ``On behalf of
everyone at Netscape, I want to thank you for helping us get to this
point in the first place.  Your thinking and writings were fundamental
inspirations to our decision.''</para>

<para>Eric Hahn รองประธานบริหารและหัวหน้าฝ่ายเทคโนโลยีของเน็ตสเคป 
ได้ส่งอีเมลสั้นๆ ถึงผมในภายหลัง บอกว่า: ``ในนามของทุกๆ คนที่เน็ตสเคป 
ผมอยากจะขอบคุณที่คุณได้ช่วยเราตั้งแต่ต้นให้มาถึงจุดนี้ 
ความคิดและข้อเขียนของคุณคือแรงบันดาลใจโดยพื้นฐานของการตัดสินใจของเรา''</para>

<para>The following week I flew out to Silicon Valley at Netscape's
invitation for a day-long strategy conference (on 4 Feb 1998) with
some of their top executives and technical people.  We designed
Netscape's source-release strategy and license together.</para>

<para>ในสัปดาห์ต่อมา ผมบินไปที่ซิลิคอนแวลลีย์ตามคำเชิญของเน็ตสเคป 
เพื่อเข้าร่วมงานประชุมระยะเวลาหนึ่งวัน (ในวันที่ 4 ก.พ. 1998) 
กับผู้บริหารระดับสูงและผู้เชี่ยวชาญทางเทคนิคของบริษัท 
เราร่วมกันวางกลยุทธ์การปล่อยซอร์ส และสัญญาอนุญาตของเน็ตสเคป</para>

<para>A few days later I wrote the following:</para>

<para>สองสามวันถัดมา ผมเขียนว่า:</para>

<blockquote>
<para>Netscape is about to provide us with a large-scale, real-world test of
the bazaar model in the commercial world.  The open-source culture 
now faces a danger; if Netscape's execution doesn't work, the
open-source concept may be so discredited that the commercial world
won't touch it again for another decade.</para>

<para>เน็ตสเคปกำลังจะจัดเตรียมการทดสอบจริงขนาดใหญ่ 
สำหรับรูปแบบตลาดสดในโลกธุรกิจ ขณะนี้ โลกโอเพนซอร์สกำลังเผชิญกับอันตราย 
ถ้าการดำเนินการของเน็ตสเคปไม่เป็นผล 
แนวคิดโอเพนซอร์สอาจจะถูกลดความน่าเชื่อถือลง 
ถึงขนาดที่จะไม่ได้รับความสนใจจากโลกธุรกิจอีกเลยเป็นสิบปี</para>

<para>On the other hand, this is also a spectacular opportunity.  Initial
reaction to the move on Wall Street and elsewhere has been cautiously
positive.  We're being given a chance to prove ourselves, too.  If
Netscape regains substantial market share through this move, it just
may set off a long-overdue revolution in the software industry.</para>

<para>ในทางกลับกัน นี่ก็ถือเป็นโอกาสอันงดงามเช่นกัน 
ปฏิกิริยาเบื้องต้นต่อความเคลื่อนไหวครั้งนี้ในวอลล์สตรีทและที่อื่นๆ 
กำลังเป็นบวกอย่างระมัดระวัง เรากำลังได้รับโอกาสพิสูจน์ตัวเองด้วย 
ถ้าเน็ตสเคปสามารถรุกส่วนแบ่งตลาดกลับมาได้จากความเคลื่อนไหวครั้งนี้ 
ก็อาจเป็นการเริ่มต้นปฏิวัติวงการอุตสาหกรรมซอฟต์แวร์ 
ซึ่งควรจะเกิดมาตั้งนานแล้ว</para>

<para>The next year should be a very instructive and interesting
time.</para>

<para>ปีหน้านี้ น่าจะเป็นช่วงเวลาที่น่าศึกษาและน่าสนใจอย่างยิ่ง</para>
</blockquote>

<para>And indeed it was.  As I write in mid-2000, the development of
what was later named Mozilla has been only a qualified success.  It
achieved Netscape's original goal, which was to deny Microsoft a
monopoly lock on the browser market.  It has also achieved some
dramatic successes (notably the release of the next-generation Gecko
rendering engine).</para>

<para>และมันก็เป็นเช่นนั้นจริงๆ ขณะที่ผมเขียนเรื่องนี้ในกลางปี 2000 
การพัฒนาของสิ่งที่ได้รับการขนานนามต่อมาว่า โมซิลล่า 
ได้กลายเป็นความสำเร็จระดับคุณภาพ โดยสามารถบรรลุเป้าหมายเริ่มแรกของเน็ตสเคป 
คือการปฏิเสธการผูกขาดถาวรของไมโครซอฟท์ในตลาดเบราว์เซอร์ 
และยังประสบความสำเร็จอย่างถล่มทลายอีกด้วย 
(โดยเฉพาะการออกเครื่องจักรซอฟต์แวร์สำหรับวาดหน้าเว็บรุ่นใหม่ที่ชื่อ 
เก็คโค)</para>

<para>However, it has not yet garnered the massive development effort from
outside Netscape that the Mozilla founders had originally hoped for.
The problem here seems to be that for a long time the Mozilla
distribution actually broke one of the basic rules of the bazaar
model; it didn't ship with something potential contributors could easily
run and see working.  (Until more than a year after release, building
Mozilla from source required a license for the proprietary Motif
library.)</para>

<para>อย่างไรก็ดี มันก็ยังไม่ได้รับแรงพัฒนาอย่างใหญ่หลวงจากภายนอกเน็ตสเคป 
อย่างที่ผู้ก่อตั้งโมซิลล่าคาดหวังไว้แต่ต้น ปัญหาของที่นี่ 
ดูจะเป็นเพราะการแจกจ่ายโมซิลล่าได้แหกกฎพื้นฐานของรูปแบบตลาดสดเป็นเวลานาน 
กล่าวคือ ไม่ได้ให้สิ่งที่ผู้ที่อาจร่วมสมทบสามารถเรียกใช้เพื่อดูการทำงานได้ 
(ตลอดเวลากว่าหนึ่งปีตั้งแต่ออก 
การคอมไพล์โมซิลล่าจากซอร์สจำเป็นต้องอาศัยสิทธิ์อนุญาตใช้งานสำหรับไลบรารีโมทีฟ 
ซึ่งเป็นซอฟต์แวร์สงวนสิทธิ์)</para>

<para>Most negatively (from the point of view of the outside world)
the Mozilla group didn't ship a production-quality browser for two and
a half years after the project launch&mdash;and
in 1999 one of the project's principals caused a bit of a sensation by
resigning, complaining of poor management and missed opportunities.
``Open source,'' he correctly observed, ``is not magic pixie
dust.''</para>

<para>ที่เป็นลบมากที่สุด (จากมุมมองของโลกภายนอก) 
คือกลุ่มโมซิลล่าไม่ได้ให้เบราว์เซอร์ระดับคุณภาพเป็นเวลาถึงสองปีครึ่งหลังจากตั้งโครงการ 
และในปี 1999 แกนนำคนสำคัญของโครงการก็ได้สร้างความรู้สึกที่ไม่ดี ด้วยการลาออก 
และบ่นถึงการบริหารที่แย่ และการเสียโอกาสต่างๆ ``โอเพนซอร์ส'' 
เขาตั้งข้อสังเกตอย่างถูกต้อง ``ไม่ใช่เวทมนตร์วิเศษ''</para>

<para>And indeed it is not.  The long-term prognosis for Mozilla looks
dramatically better now (in November 2000) than it did at the time of
Jamie Zawinski's resignation letter&mdash;in the last few weeks the
nightly releases have finally passed the critical threshold to
production usability.  But Jamie was right to point out that going
open will not necessarily save an existing project that suffers from
ill-defined goals or spaghetti code or any of the software
engineering's other chronic ills.  Mozilla has managed to provide an
example simultaneously of how open source can succeed and how it could
fail.</para>

<para>และมันก็ไม่ใช่จริงๆ อาการต่างๆ 
ในระยะยาวของโมซิลล่าดูจะดีขึ้นอย่างมากในขณะนี้ (ในเดือนพฤศจิกายน 2000) 
เทียบกับขณะที่ เจมี่ ซาวินสกี้ เขียนจดหมายลาออก ในช่วงอาทิตย์หลังๆ 
รุ่นปล่อยประจำวันได้ผ่านระดับคุณภาพที่สำคัญไปสู่การใช้งานจริงเป็นที่เรียบร้อย 
แต่เจมี่ก็กล่าวได้ถูกต้อง ที่ชี้ให้เห็นว่า 
การเปิดซอร์สไม่จำเป็นต้องช่วยชีวิตโครงการเดิมที่กำหนดเป้าหมายไว้แย่ๆ 
หรือมีโค้ดที่ยุ่งเหยิง หรือมีอาการป่วยเรื้อรังอื่นๆ 
ทางวิศวกรรมซอฟต์แวร์ได้เสมอไป โมซิลล่าได้แสดงตัวอย่าง 
ทั้งการประสบความสำเร็จและการล้มเหลวของโอเพนซอร์สในเวลาเดียวกัน</para>

<para>In the mean time, however, the open-source idea has scored
successes and found backers elsewhere.  Since the Netscape release
we've seen a tremendous explosion of interest in the open-source
development model, a trend both driven by and driving the continuing
success of the Linux operating system.  The trend Mozilla touched off
is continuing at an accelerating rate.</para>

<para>อย่างไรก็ดี ในช่วงเวลาเดียวกันนี้ แนวคิดโอเพนซอร์สก็ได้ประสบความสำเร็จ 
และมีผู้สนับสนุนในที่อื่นๆ ตั้งแต่การออกซอฟต์แวร์ของเน็ตสเคป 
เราก็ได้เห็นการบูมอย่างมโหฬารของความสนใจในรูปแบบการพัฒนาแบบโอเพนซอร์ส 
ซึ่งเป็นแนวโน้มที่ทั้งรับและให้แรงขับเคลื่อนต่อความสำเร็จของระบบปฏิบัติการลินุกซ์ในเวลาเดียวกัน 
แนวโน้มที่โมซิลล่าได้จุดประกายขึ้น ได้ดำเนินต่อไปในอัตราที่สูงขึ้นเรื่อยๆ</para>
</sect1>

<!-- %%BEGIN ENDNOTES -->
<!--Notes -->
<sect1><title>เชิงอรรถ</title>

<para><citetitle><anchor id="_JB"/>[JB]</citetitle> In
<citetitle>Programing Pearls</citetitle>, the noted computer-science
aphorist Jon Bentley comments on Brooks's observation with ``If you
plan to throw one away, you will throw away two.''.  He is almost
certainly right.  The point of Brooks's observation, and Bentley's,
isn't merely that you should expect first attempt to be wrong, it's
that starting over with the right idea is usually more effective than
trying to salvage a mess.</para>

<para><citetitle><anchor id="JB"/>[JB]</citetitle> ในหนังสือ 
<citetitle>Programing Pearls (อัญมณีแห่งการเขียนโปรแกรม)</citetitle> จอน เบนทลีย์ 
นักตั้งคติพจน์ทางวิทยาการคอมพิวเตอร์ ได้ให้ความเห็นต่อข้อสังเกตของบรูกส์ไว้ว่า 
``ถ้าคุณเตรียมพร้อมที่จะทิ้งสิ่งหนึ่ง คุณจะได้ทิ้งไปสองสิ่ง'' 
เขากล่าวได้ถูกต้องค่อนข้างแน่นอนทีเดียว ประเด็นของข้อสังเกตของบรูกส์และเบนทลีย์ 
ไม่ใช่เพียงแค่ว่าคุณควรคาดได้ว่าความพยายามครั้งแรกจะผิดเท่านั้น แต่ยังย้ำว่า 
การตั้งต้นใหม่ด้วยแนวคิดที่ถูกต้อง 
มักจะเกิดผลมากกว่าการพยายามกู้ซากที่เละเทะ</para>

<para><emphasis><anchor id="_QR"/>[QR]</emphasis> Examples of successful
open-source, bazaar development predating the Internet explosion and
unrelated to the Unix and Internet traditions have existed.  The
development of the
<ulink url="http://www.cdrom.com/pub/infozip/">info-Zip</ulink>
compression utility during 1990&ndash;x1992, primarily for DOS machines, was
one such example.  Another was the RBBS bulletin board system (again for DOS),
which began in 1983 and developed a sufficiently strong community that
there have been fairly regular releases up to the present (mid-1999)
despite the huge technical advantages of Internet mail and
file-sharing over local BBSs.  While the info-Zip community relied to
some extent on Internet mail, the RBBS developer culture was actually
able to base a substantial on-line community on RBBS that was
completely independent of the TCP/IP infrastructure.</para>

<para><emphasis><anchor id="QR"/>[QR]</emphasis> 
มีตัวอย่างของการพัฒนาแบบโอเพนซอร์สในตลาดสด 
ที่ประสบความสำเร็จในยุคก่อนอินเทอร์เน็ตบูม 
และไม่เกี่ยวกับธรรมเนียมของยูนิกซ์และอินเทอร์เน็ตด้วย 
การพัฒนาของโปรแกรมบีบอัดซึ่งมุ่งใช้สำหรับดอส ชื่อ 
<ulink url="http://www.cdrom.com/www/infozip/">info-Zip</ulink> 
ระหว่างปี 1990&ndash;1992 คือตัวอย่างหนึ่งดังกล่าว 
อีกตัวอย่างหนึ่งคือระบบกระดานข่าว RBBS (สำหรับดอสอีกเหมือนกัน) 
ซึ่งเริ่มต้นในปี 1983 
และได้สร้างชุมชนที่แข็งแกร่งพอที่จะมีการออกรุ่นสม่ำเสมอมาจนถึงปัจจุบัน (กลางปี 
1999) 
ถึงแม้เมลและการใช้แฟ้มร่วมกันในอินเทอร์เน็ตจะมีข้อได้เปรียบทางเทคนิคอย่างมากเหนือ 
BBS แล้วก็ตาม ในขณะที่ชุมชนของ info-Zip อาศัยเมลในอินเทอร์เน็ตในระดับหนึ่ง 
แต่วัฒนธรรมของนักพัฒนา RBBS สามารถจะใช้ชุมชนออนไลน์ผ่าน RBBS 
ซึ่งไม่ขึ้นกับโครงสร้างพื้นฐาน TCP/IP เลยได้</para>

<para><emphasis><anchor id="_CV"/>[CV]</emphasis> That transparency and
peer review are valuable for taming the complexity of OS development
turns out, after all, not to be a new concept.  In 1965, very early
in the history of time-sharing operating systems,
Corbat&oacute; and Vyssotsky, co-designers of the Multics operating
system, <ulink
url="http://www.multicians.org/fjcc1.html">wrote</ulink></para>

<para><emphasis><anchor id="CV"/>[CV]</emphasis> แนวคิดที่ว่า 
ความโปร่งใสและการตรวจทานโดยนักพัฒนาอื่น 
มีประโยชน์ต่อการจัดการความซับซ้อนของการพัฒนาระบบปฏิบัติการ 
ปรากฏว่าไม่ใช่เรื่องใหม่แต่อย่างใด ในปี 1965 ซึ่งเป็นช่วงแรกๆ 
ของประวัติศาสตร์ของระบบปฏิบัติการแบบแบ่งเวลาทำงาน (time-sharing) นั้น 
Corbat&oacute; และ Vyssotsky ซึ่งเป็นผู้ร่วมออกแบบระบบปฏิบัติการมัลทิกซ์ 
(Multics) ได้ <ulink
url="http://www.multicians.org/fjcc1.html">เขียน</ulink> ไว้ว่า</para>

<blockquote><para>It is expected that the Multics system will be
published when it is operating substantially... Such publication is
desirable for two reasons: First, the system should withstand public
scrutiny and criticism volunteered by interested readers; second, in
an age of increasing complexity, it is an obligation to present and
future system designers to make the inner operating system as lucid as
possible so as to reveal the basic system issues.</para></blockquote>

<blockquote><para>เราคาดหวังว่าจะเปิดเผยระบบมัลทิกซ์ 
เมื่อมันทำงานได้อย่างมีเสถียรภาพ.. การเปิดเผยดังกล่าวเป็นสิ่งที่ดี 
ด้วยเหตุผลสองประการ: ข้อแรก ระบบจะถูกสังเกตและวิจารณ์ในสาธารณะ 
จากการอาสาสมัครของผู้อ่านที่สนใจ ข้อสอง ในยุคที่ความซับซ้อนเพิ่มมากขึ้น 
ก็เป็นความจำเป็นสำหรับนักออกแบบระบบในปัจจุบันและในอนาคต 
ที่จะทำให้ระบบปฏิบัติการภายในชัดเจนที่สุดเท่าที่จะเป็นไปได้ 
เพื่อจะได้เห็นประเด็นต่างๆ ของระบบพื้นฐาน</para></blockquote>

<!--
        28. Corbat&oacute;, F. J., and V. A. Vyssotsky, Introduction and
            overview of the Multics system, AFIPS Conf Proc 27,
            185-196, 1965.
-->

<para><emphasis><anchor id="_JH"/>[JH]</emphasis> John Hasler has suggested
an interesting explanation for the fact that duplication of effort
doesn't seem to be a net drag on open-source development. He proposes
what I'll dub ``Hasler's Law'': the costs of duplicated work tend to
scale sub-qadratically with team size&mdash;that is, more slowly than the
planning and management overhead that would be needed to eliminate
them.</para>

<para><emphasis><anchor id="JH"/>[JH]</emphasis> จอห์น แฮสเลอร์ 
ได้เสนอแนะคำอธิบายที่น่าสนใจสำหรับข้อเท็จจริงที่ว่า 
การซ้ำซ้อนของแรงงานดูจะไม่กลายเป็นการหน่วงงานพัฒนาโอเพนซอร์ส 
เขาได้เสนอสิ่งที่ผมจะตั้งชื่อให้ว่า ``กฎของแฮสเลอร์'' ซึ่งกล่าวว่า 
ค่าโสหุ้ยของงานที่ซ้ำซ้อน 
มีแนวโน้มจะโตตามขนาดของทีมงานในอัตราที่ต่ำกว่ากำลังสอง กล่าวคือ 
ช้ากว่าค่าโสหุ้ยในการวางแผนและบริหารที่จำเป็นสำหรับการกำจัดความซ้ำซ้อนดังกล่าว
</para>

<para>This claim actually does not contradict Brooks's Law.  It may be
the case that total complexity overhead and vulnerability to bugs
scales with the square of team size, but that the costs from
<emphasis>duplicated</emphasis> work are nevertheless a special case
that scales more slowly.  It's not hard to develop plausible reasons
for this, starting with the undoubted fact that it is much easier to
agree on functional boundaries between different developers' code that
will prevent duplication of effort than it is to prevent the kinds of
unplanned bad interactions across the whole system that underly most
bugs.</para>

<para>คำอ้างนี้ไม่ได้ขัดกับกฎของบรูกส์ อาจจะจริงที่ว่า 
ค่าโสหุ้ยของความซับซ้อนทั้งหมด และความเสี่ยงต่อบั๊ก 
จะโตในอัตรากำลังสองตามขนาดของทีม แต่ค่าโสหุ้ยจาก 
<emphasis>งานที่ซ้ำซ้อน</emphasis> จะเป็นกรณีพิเศษที่โตช้ากว่านั้น 
ไม่ยากเลยที่จะให้เหตุผลกับเรื่องนี้ เริ่มจากข้อเท็จจริงที่ไร้ข้อกังขาที่ว่า 
เป็นการง่ายกว่าที่จะเห็นพ้องในขอบเขตหน้าที่ระหว่างโค้ดของนักพัฒนาต่างๆ 
ซึ่งจะช่วยป้องกันการซ้ำซ้อนของงาน 
ถ้าเทียบกับการป้องกันผลที่เกี่ยวเนื่องถึงกันอย่างไม่ตั้งใจในส่วนต่างๆ ของระบบ 
ซึ่งทำให้เกิดบั๊กต่างๆ</para>

<para>The combination of Linus's Law and Hasler's Law suggests that there
are actually three critical size regimes in software projects.  On
small projects (I would say one to at most three developers) no
management structure more elaborate than picking a lead programmer is
needed.  And there is some intermediate range above that in which the
cost of traditional management is relatively low, so its benefits from
avoiding duplication of effort, bug-tracking, and pushing to see that
details are not overlooked actually net out positive.</para>

<para>เมื่อใช้กฎของไลนัสและกฎของแฮสเลอร์ร่วมกัน ก็จะได้ว่า 
มีขนาดวิกฤติสามขนาดในโครงการซอฟต์แวร์ต่างๆ กล่าวคือ ในโครงการเล็กๆ 
(ที่มีนักพัฒนาหนึ่งถึงสามคน) 
ก็ไม่จำเป็นต้องมีโครงสร้างการบริหารอะไรมากไปกว่าการเลือกนักพัฒนาหลัก 
และมีช่วงของโครงการขนาดกลางที่โตกว่านั้น ซึ่งค่าโสหุ้ยในการบริหารตามปกติจะต่ำ 
ทำให้ข้อดีของการเลี่ยงความซ้ำซ้อนของแรงงาน การติดตามบั๊ก 
และการตรวจสอบการหลุดรอดของรายละเอียด สามารถเอาชนะค่าโสหุ้ยได้</para>

<para>Above that, however, the combination of Linus's Law and Hasler's Law
suggests there is a large-project range in which the costs and
problems of traditional management rise much faster than the expected
cost from duplication of effort.  Not the least of these costs is a
structural inability to harness the many-eyeballs effect, which (as
we've seen) seems to do a much better job than traditional management
at making sure bugs and details are not overlooked.  Thus, in the
large-project case, the combination of these laws effectively drives
the net payoff of traditional management to zero.</para>

<para>แต่ในขนาดที่ใหญ่กว่านั้น การใช้กฎของไลนัสและกฎของแฮสเลอร์ร่วมกัน 
จะให้ผลว่า มีช่วงของโครงการขนาดใหญ่ ที่ค่าโสหุ้ยและปัญหาของการบริหารแบบเดิม 
จะโตเร็วกว่าค่าโสหุ้ยประมาณการของงานที่ซ้ำซ้อน โดยที่ค่าโสหุ้ยเหล่านี้ 
ยังไม่รวมความไร้ประสิทธิภาพในการใช้ผลของลูกตาจำนวนมาก ซึ่งอย่างที่เราเห็น 
ว่าสามารถทำงานได้ดีกว่าการบริหารแบบเดิมมากในการตรวจสอบบั๊กและรายละเอียดต่างๆ 
ดังนั้น ในกรณีของโครงการขนาดใหญ่ ผลของกฎเหล่านี้เมื่อประกอบกัน 
จึงทำให้ลดข้อดีของการบริหารแบบเดิมลงจนเหลือศูนย์</para>

<para><emphasis><anchor id="_HBS"/>[HBS]</emphasis> The split between Linux's
experimental and stable versions has another function related to, but
distinct from, hedging risk.  The split attacks another problem: the
deadliness of deadlines.  When programmers are held both to an
immutable feature list and a fixed drop-dead date, quality goes out
the window and there is likely a colossal mess in the making. I am
indebted to Marco Iansiti and Alan MacCormack of the Harvard Business
School for showing me me evidence that relaxing either one of these
constraints can make scheduling workable.</para>

<para><emphasis><anchor id="HBS"/>[HBS]</emphasis> การแยกรุ่นของลินุกซ์ 
ระหว่างรุ่นทดสอบและรุ่นเสถียร 
ยังทำหน้าที่อีกอย่างที่เกี่ยวข้องกับการกีดกันความเสี่ยง (แต่ไม่ใช่) 
การแยกรุ่นจะจัดการกับปัญหาอีกข้อหนึ่ง คือการไม่มีเส้นตายของเส้นตาย 
เมื่อโปรแกรมเมอร์ต้องอยู่กับทั้งรายการคุณสมบัติโปรแกรมที่ไม่เปลี่ยนแปลง 
และกำหนดการที่ตายตัว คุณภาพก็จะตก และอาจเกิดความยุ่งเหยิงอย่างใหญ่หลวงได้ 
ถ้าจะทำให้ได้ทั้งสองอย่าง ผมเป็นหนี้ต่อ มาร์โค เอียนซิติ และ อลัน 
แม็คคอร์แม็ค จากโรงเรียนธุรกิจฮาร์วาร์ด ที่ได้แสดงหลักฐานให้ผมเห็นว่า 
การผ่อนผันข้อกำหนดอย่างใดอย่างหนึ่ง จะทำให้กำหนดการสามารถบรรลุได้</para>

<para>One way to do this is to fix the deadline but leave the feature
list flexible, allowing features to drop off if not completed by
deadline.  This is essentially the strategy of the "stable" kernel
branch; Alan Cox (the stable-kernel maintainer) puts out releases at
fairly regular intervals, but makes no guarantees about when
particular bugs will be fixed or what features will beback-ported from
the experimental branch.</para>

<para>ทางหนึ่งที่ทำได้ คือกำหนดเส้นตายตายตัว 
แต่ให้รายการคุณสมบัติโปรแกรมยืดหยุ่นได้ โดยยอมทิ้งคุณสมบัติบางอย่างได้ 
ถ้ายังทำไม่เสร็จตามกำหนด นี่คือนโยบายหลักของแขนงเคอร์เนลที่ "เสถียร" อลัน 
ค็อกซ์ (ผู้ดูแลเคอร์เนลรุ่นเสถียร) ออกรุ่นเคอร์เนลเป็นระยะค่อนข้างสม่ำเสมอ 
แต่ไม่รับประกันว่าบั๊กไหนจะแก้เมื่อไร 
หรือความสามารถไหนจะถูกถ่ายกลับมาจากแขนงทดสอบ</para>

<para>The other way to do this is to set a desired feature list and deliver
only when it is done.  This is essentially the strategy of the
"experimental" kernel branch.  De Marco and Lister cited research
showing that this scheduling policy ("wake me up when it's done")
produces not only the highest quality but, on average, shorter
delivery times than either "realistic" or "aggressive" scheduling.</para>

<para>หรืออีกทางหนึ่ง ก็คือกำหนดรายการคุณสมบัติที่ต้องการ 
แล้วออกเมื่อทำเสร็จเท่านั้น นี่คือนโยบายหลักของแขนง "ทดสอบ" ของเคอร์เนล เดอ 
มาร์โค และ ลิสเตอร์ ได้อ้างถึงงานวิจัยที่แสดงให้เห็นว่า นโยบายกำหนดการแบบนี้ 
("ทำเสร็จแล้วปลุกด้วย") จะไม่ใช่แค่ให้คุณภาพสูงสุด แต่โดยเฉลี่ยแล้ว 
ยังทำให้ออกได้เร็วกว่ากำหนดการที่ "ตามความเป็นจริง" หรือ "เคร่งครัด" 
เสียอีก</para>

<para>I have come to suspect (as of early 2000) that in earlier
versions of this essay I severely underestimated the importance of the
"wake me up when it's done" anti-deadline policy to the open-source
community's productivity and quality.  General experience with the
rushed GNOME 1.0 release in 1999 suggests that pressure for a
premature release can neutralize many of the quality benefits open
source normally confers.</para>

<para>ผมได้กลับมาสงสัย (ในช่วงต้นปี 2000) ว่าในบทความนี้รุ่นก่อนๆ 
ผมได้ประเมินความสำคัญของนโยบายต่อต้านเส้นตายที่ว่า "ทำเสร็จแล้วปลุกด้วย" 
ต่อผลิตภาพและคุณภาพของชุมชนโอเพนซอร์สต่ำเกินไปอย่างร้ายแรง ประสบการณ์ทั่วๆ 
ไปของการออก GNOME 1.0 อย่างรีบเร่งในปี 1999 ทำให้เราเห็นว่า 
ความกดดันในการออกรุ่นก่อนที่จะพร้อม 
สามารถสลายข้อดีด้านคุณภาพหลายข้อที่โอเพนซอร์สเคยให้ตามปกติได้</para>

<para>It may well turn out to be that the process transparency of open
source is one of three co-equal drivers of its quality, along with
"wake me up when it's done" scheduling and developer self-selection.</para>

<para>อาจจะกลายเป็นว่า ความโปร่งใสของกระบวนการ 
เป็นหนึ่งในแรงขับดันสามเรื่องที่สำคัญพอๆ กันต่อคุณภาพของโอเพนซอร์ส 
อีกสองเรื่องก็คือกำหนดการแบบ "ทำเสร็จแล้วปลุกด้วย" 
และการกลั่นกรองตัวเองของนักพัฒนา</para>

<para><emphasis><anchor id="_SU"/>[SU]</emphasis> It's tempting, and not
entirely inaccurate, to see the core-plus-halo organization
characteristic of open-source projects as an Internet-enabled spin on
Brooks's own recommendation for solving the N-squared complexity
problem, the "surgical-team" organization&mdash;but the differences are
significant. The constellation of specialist roles such as "code
librarian" that Brooks envisioned around the team leader doesn't
really exist; those roles are executed instead by generalists aided by
toolsets quite a bit more powerful than those of Brooks's day.  Also, the
open-source culture leans heavily on strong Unix traditions of
modularity, APIs, and information hiding&mdash;none of which were
elements of Brooks's prescription.</para>

<para><emphasis><anchor id="SU"/>[SU]</emphasis> ไม่แปลก 
และก็ไม่ผิดไปเสียทั้งหมด 
ถ้าจะมองลักษณะการจัดโครงสร้างที่ประกอบด้วยนักพัฒนาแกนและที่รายล้อม 
ว่าเป็นการใช้ข้อแนะนำของบรูกส์สำหรับแก้ปัญหาอัตราการเติบโตที่เป็นกำลังสอง 
ที่เรียกว่าโครงสร้าง "ทีมผ่าตัด" ในรูปแบบที่ผ่านอินเทอร์เน็ต 
แต่ก็มีความแตกต่างอย่างมาก กลุ่มของบทบาทผู้เชี่ยวชาญ เช่น "บรรณารักษ์โค้ด" 
ที่บรูกส์วาดภาพไว้รอบๆ หัวหน้าทีม ไม่ได้มีอยู่จริง แต่บทบาทเหล่านั้น 
กลับถูกดำเนินการโดยผู้ทำงานทั่วไป 
ที่มีเครื่องมือช่วยที่ค่อนข้างมีประสิทธิภาพกว่าในยุคของบรูกส์ นอกจากนี้ 
วัฒนธรรมโอเพนซอร์สยังอาศัยธรรมเนียมยูนิกซ์ที่เข้มแข็งเกี่ยวกับความเป็นสัดส่วน, 
API และการซ่อนรายละเอียด ซึ่งไม่มีข้อไหนอยู่ในองค์ประกอบที่บรูกส์กำหนดเลย</para>

<para><emphasis><anchor id="_RJ"/>[RJ]</emphasis> The respondent who
pointed out to me the effect of widely varying trace path lengths on
the difficulty of characterizing a bug speculated that trace-path
difficulty for multiple symptoms of the same bug varies
"exponentially" (which I take to mean on a Gaussian or Poisson
distribution, and agree seems very plausible).  If it is
experimentally possible to get a handle on the shape of this
distribution, that would be extremely valuable data.  Large departures
from a flat equal-probability distribution of trace difficulty would
suggest that even solo developers should emulate the bazaar strategy
by bounding the time they spend on tracing a given symptom before they
switch to another.  Persistence may not always be a virtue...</para>

<para><emphasis><anchor id="RJ"/>[RJ]</emphasis> 
ผู้แสดงความเห็นที่ได้ชี้ให้ผมเห็นเกี่ยวกับผลของความยาวที่ต่างกันมากๆ 
ของเส้นทางการแกะรอย ที่มีต่อความยากในการบ่งชี้บั๊ก ได้สันนิษฐานว่า 
ความยากของเส้นทางการแกะรอยอาการอันหลากหลายของบั๊กเดียวกัน 
จะแปรปรวนในแบบเอ็กซ์โพเนนเชียล (ซึ่งผมเดาว่าหมายถึงการกระจายแบบเกาส์หรือปัวซอง 
และเห็นด้วยว่าดูน่าจะเป็นไปได้) 
ถ้าเป็นไปได้ที่จะทดลองเพื่อหารูปร่างของการกระจายดังกล่าว 
ก็จะเป็นข้อมูลที่มีความหมายอย่างยิ่ง 
การที่ความยากในการแกะรอยมีการกระจายที่หนีห่างมากๆ 
จากแบบแบนราบซึ่งความน่าจะเป็นเท่าๆ กัน ก็จะหมายความว่า แม้นักพัฒนาที่ลุยเดี่ยว 
ก็ควรจำลองกลยุทธ์แบบตลาดสด โดยจำกัดเวลาที่ใช้ในการแกะรอยอาการหนึ่งๆ 
ก่อนที่จะเปลี่ยนไปดูอาการอื่น ความมุ่งมั่นอาจไม่ได้เป็นผลดีเสมอไป...</para>

<para><emphasis><anchor id="_IN"/>[IN]</emphasis> An issue related to
whether one can start projects from zero in the bazaar style is
whether the bazaar style is capable of supporting truly innovative
work.  Some claim that, lacking strong leadership, the bazaar can only
handle the cloning and improvement of ideas already present at the
engineering state of the art, but is unable to push the state of the
art.  This argument was perhaps most infamously made by the <ulink
url="http://www.opensource.org/halloween/">Halloween
Documents</ulink>, two embarrassing internal Microsoft memoranda
written about the open-source phenomenon.  The authors compared
Linux's development of a Unix-like operating system to ``chasing
taillights'', and opined ``(once a project has achieved "parity" with
the state-of-the-art), the level of management necessary to push
towards new frontiers becomes massive.''</para>

<para><emphasis><anchor id="IN"/>[IN]</emphasis> 
ประเด็นที่เกี่ยวข้องกับเรื่องที่นักพัฒนาจะสามารถตั้งต้นโครงการจากศูนย์ในแบบตลาดสดได้หรือไม่ 
ก็คือประเด็นว่า 
รูปแบบตลาดสดสามารถสนับสนุนงานที่เป็นนวัตกรรมอย่างแท้จริงได้หรือไม่ บางคนอ้างว่า 
หากปราศจากความเป็นผู้นำที่เข้มแข็งแล้ว 
ตลาดสดก็สามารถทำได้เพียงจัดการการลอกเลียนและปรับปรุงแนวคิดเดิมที่มีอยู่ที่อยู่ในขั้นประดิษฐ์คิดค้นเท่านั้น 
คำโต้แย้งที่เป็นที่รู้จักกันมากที่สุด คงเป็น <ulink 
url="http://www.opensource.org/halloween/">เอกสารวันฮัลโลวีน</ulink> 
ซึ่งเป็นบันทึกข้อความสองชิ้นที่น่ากระอักกระอ่วนของไมโครซอฟท์ 
ที่เขียนเกี่ยวกับปรากฏการณ์โอเพนซอร์ส 
ผู้เขียนเอกสารได้เปรียบเทียบการพัฒนาระบบปฏิบัติการที่คล้ายยูนิกซ์ของลินุกซ์กับการ 
``ไล่กวดไฟท้าย'' และแสดงความเห็นว่า ``(เมื่อโครงการได้ประสบความสำเร็จ 
"เทียบเคียง" กับแนวคิดใหม่ล่าสุดแล้ว) 
ระดับของการบริหารที่ต้องใช้ในการผลักดันไปสู่แนวรุกใหม่จะมากมายมหาศาล''</para>

<para>There are serious errors of fact implied in this argument.  One is
exposed when the Halloween authors themseselves later observe that
``often [...] new research ideas are first implemented and available
on Linux before they are available / incorporated into other
platforms.''</para>

<para>มีข้อผิดพลาดร้ายแรงหลายอย่างเกี่ยวกับข้อเท็จจริงที่ข้อโต้แย้งนี้พยายามจะบอก 
ข้อแรกถูกเปิดเผยเมื่อผู้เขียนเอกสารฮัลโลวีนเองได้ตั้งข้อสังเกตในภายหลังว่า 
``บ่อยครั้ง [...] ที่แนวคิดงานวิจัยใหม่ๆ ถูกทำให้เป็นจริง 
และมีให้ใช้ในลินุกซ์ก่อนที่จะมีหรือถูกรวมเข้าในแพล็ตฟอร์มอื่น''</para>

<para>If we read ``open source'' for ``Linux'', we see that this is far from
a new phenomenon.  Historically, the open-source community did not
invent Emacs or the World Wide Web or the Internet itself by chasing
taillights or being massively managed&mdash;and in the present, there
is so much innovative work going on in open source that one is spoiled
for choice.  The GNOME project (to pick one of many) is pushing the
state of the art in GUIs and object technology hard enough to have
attracted considerable notice in the computer trade press well outside
the Linux community.  Other examples are legion, as a visit to <ulink
url="http://freshmeat.net/">Freshmeat</ulink> on any given day will
quickly prove.</para>

<para>ถ้าเราแทน ``ลินุกซ์'' ด้วย ``โอเพนซอร์ส'' 
เราจะเห็นว่าเรื่องนี้ไม่ใช่เรื่องใหม่อะไรเลย ตามประวัติแล้ว 
ชุมชนโอเพนซอร์สไม่ได้ประดิษฐ์ Emacs หรือ World Wide Web 
หรือตัวอินเทอร์เน็ตเองด้วยการไล่กวดไฟท้าย 
หรือต้องมีการบริหารอย่างมากมายมหาศาลเลย และในปัจจุบัน 
ก็มีงานนวัตกรรมมากมายที่ยังดำเนินต่อไปในโลกโอเพนซอร์ส 
จนถึงกับทำให้ผู้ใช้เคยตัวกับการมีทางเลือก โครงการ GNOME 
(เพื่อเป็นตัวอย่างของอีกหลายโครงการ) ก็ยังคงผลักดัน GUI 
ใหม่ล่าสุดและเทคโนโลยีออบเจ็กต์อย่างหนัก 
มากพอที่จะดึงดูดความสนใจจากสื่อมวลชนสาขาคอมพิวเตอร์ที่อยู่นอกชุมชนลินุกซ์ 
และยังมีตัวอย่างอื่นอีกเป็นกองทัพ ซึ่งการเข้าไปดู <ulink 
url="http://freshmeat.net/">Freshmeat</ulink> สักวันหนึ่ง 
ก็สามารถพิสูจน์ได้อย่างรวดเร็ว</para>

<para>But there is a more fundamental error in the implicit assumption
that the <emphasis>cathedral model</emphasis> (or the bazaar model, or
any other kind of management structure) can somehow make innovation
happen reliably.  This is nonsense.  Gangs don't have breakthrough
insights&mdash;even volunteer groups of bazaar anarchists are usually
incapable of genuine originality, let alone corporate committees of
people with a survival stake in some status quo ante.
<emphasis>Insight comes from individuals.</emphasis> The most their
surrounding social machinery can ever hope to do is to be
<emphasis>responsive</emphasis> to breakthrough insights&mdash;to nourish
and reward and rigorously test them instead of squashing them.</para>

<para>แต่มีข้อผิดพลาดที่พื้นฐานกว่านั้นอีกเรื่องหนึ่ง คือการทึกทักกลายๆ ว่า 
<emphasis>รูปแบบมหาวิหาร</emphasis> (หรือรูปแบบตลาดสด 
หรือรูปแบบการบริหารชนิดอื่นใด) สามารถสร้างนวัตกรรมได้อย่างแน่นอน 
นี่เป็นเรื่องไร้สาระ กลุ่มคนใดๆ ไม่สามารถมีแนวคิดที่พลิกโฉมได้ 
แม้กลุ่มอาสาสมัครอนาธิปัตย์ในตลาดสด ก็มักไม่สามารถคิดค้นอะไรใหม่ได้อย่างแท้จริง 
ไม่ต้องพูดถึงกลุ่มคณะกรรมการในบริษัท 
ที่มีความเสี่ยงต่อการอยู่รอดโดยมีสถานะของบริษัทเป็นเดิมพันเลย แต่ 
<emphasis>แนวคิดมาจากปัจเจกบุคคล</emphasis> ต่างหาก 
สิ่งที่ดีที่สุดที่กลไกทางสังคมที่แวดล้อมเขาสามารถคาดหวังว่าจะทำได้ ก็คือการ 
<emphasis>ตอบสนอง</emphasis> ต่อแนวคิดที่พลิกโฉมต่างๆ 
โดยหล่อเลี้ยงและตอบแทนและทดสอบแนวคิดอย่างจริงจัง แทนที่จะขยี้ทิ้งเสีย</para>

<para>Some will characterize this as a romantic view, a reversion to
outmoded lone-inventor stereotypes.  Not so; I am not asserting that
groups are incapable of <emphasis>developing</emphasis> breakthrough
insights once they have been hatched; indeed, we learn from the
peer-review process that such development groups are essential to
producing a high-quality result.  Rather I am pointing out that every
such group development starts from&mdash;is necessarily sparked by&mdash;one
good idea in one person's head.  Cathedrals and bazaars and other
social structures can catch that lightning and refine it, but they
cannot make it on demand.</para>

<para>บางคนอาจจะมองว่านี่เป็นมุมมองเพ้อฝัน 
ที่ย้อนกลับไปสู่เรื่องของบุคคลตัวอย่างที่เป็นผู้ประดิษฐ์โดยลำพังในแบบเก่า 
ไม่ใช่อย่างนั้น ผมไม่ได้อ้างว่ากลุ่มคนจะไม่สามารถ <emphasis>พัฒนา</emphasis> 
แนวคิดพลิกโฉมได้หลังจากที่ได้เกิดแนวคิดขึ้นแล้ว อันที่จริง 
เราได้เรียนรู้จากกระบวนการตรวจทานโดยนักพัฒนาอื่นมาแล้ว 
ว่ากลุ่มพัฒนาลักษณะนั้นมีความสำคัญต่อการสร้างผลลัพธ์คุณภาพสูง 
แต่ผมกำลังชี้ให้เห็นว่า การพัฒนาในแต่ละกลุ่มดังกล่าว จะเริ่มจาก 
(และต้องถูกจุดประกายโดย) แนวคิดที่ดีในหัวของคนคนหนึ่ง 
มหาวิหารและตลาดสดและโครงสร้างทางสังคมแบบอื่นสามารถจับประกายนั้น 
แล้วปรับปรุงต่อได้ แต่จะไม่สามารถสร้างขึ้นเองได้ตามต้องการ</para>

<para>Therefore the root problem of innovation (in software, or anywhere
else) is indeed how not to squash it&mdash;but, even more fundamentally,
it is <emphasis>how to grow lots of people who can have insights in the 
first place</emphasis>.</para>

<para>ดังนั้น ต้นตอของปัญหาของนวัตกรรม (ในซอฟต์แวร์ หรือในสาขาอื่นๆ) 
โดยเนื้อแท้ จึงอยู่ที่การทำอย่างไรไม่ให้นวัตกรรมต้องถูกทิ้งไป 
แต่ที่อาจจะพื้นฐานกว่านั้น คือ 
<emphasis>ทำอย่างไรจึงจะสร้างกลุ่มคนที่สามารถมีแนวคิดดีๆ 
ได้ตั้งแต่ต้น</emphasis></para>

<para>To suppose that cathedral-style development could manage this
trick but the low entry barriers and process fluidity of the bazaar
cannot would be absurd.  If what it takes is one person with one good
idea, then a social milieu in which one person can rapidly attract the
cooperation of hundreds or thousands of others with that good idea is
going inevitably to out-innovate any in which the person has to do a
political sales job to a hierarchy before he can work on his idea
without risk of getting fired.</para>

<para>การทึกทักว่าการพัฒนาในแบบมหาวิหารจะสามารถจัดการเคล็ดลับนี้ได้ 
แต่แนวกั้นต่อการเข้าร่วมที่ต่ำ และความคล่องตัวของกระบวนการของตลาดสดจะทำไม่ได้ 
จึงเป็นเรื่องน่าขัน ถ้าสิ่งที่ต้องการมีแค่คนคนเดียวที่มีความคิดที่ดีแล้วล่ะก็ 
สภาพแวดล้อมทางสังคมที่คนคนหนึ่งสามารถดึงดูดความร่วมมือของคนอื่นเป็นร้อยเป็นพันที่มีแนวคิดที่ดี 
ก็เลี่ยงไม่ได้ที่จะสร้างนวัตกรรมแซงหน้ารูปแบบใดๆ 
ที่บุคคลต้องพยายามเสนอขายทางการเมืองให้กับผู้บริหารในทำเนียบ 
ก่อนที่จะสามารถทำตามแนวคิดได้ โดยไม่เสี่ยงต่อการถูกไล่ออกจากงาน</para>

<para>And, indeed, if we look at the history of software innovation by
organizations using the cathedral model, we quickly find it is rather
rare.  Large corporations rely on university research for new ideas
(thus the Halloween Documents authors' unease about Linux's facility
at coopting that research more rapidly).  Or they buy out small
companies built around some innovator's brain.  In neither case is the
innovation native to the cathedral culture; indeed, many innovations
so imported end up being quietly suffocated under the "massive level of
management" the Halloween Documents' authors so extol.</para>

<para>และอันที่จริงแล้ว 
ถ้าเราดูประวัติของนวัตกรรมซอฟต์แวร์ที่เกิดจากองค์กรที่ใช้รูปแบบมหาวิหารแล้ว 
เราจะเห็นได้อย่างรวดเร็วว่าเกิดขึ้นน้อยมาก บริษัทใหญ่ๆ จะอาศัยแนวคิดใหม่ๆ 
จากงานวิจัยของมหาวิทยาลัย (ทำให้ผู้เขียนเอกสารวันฮัลโลวีนไม่สบายใจนัก 
เกี่ยวกับเครื่องไม้เครื่องมือของลินุกซ์ 
ที่เลือกหยิบใช้งานวิจัยเหล่านั้นได้รวดเร็วกว่า) หรือมิฉะนั้น 
ก็ซื้อกิจการบริษัทเล็กๆ ที่สร้างขึ้นจากมันสมองของผู้สร้างนวัตกรรมบางคน 
ไม่มีกรณีใดที่นวัตกรรมจะเกิดจากวัฒนธรรมมหาวิหารโดยแท้จริงเลย อันที่จริง 
นวัตกรรมหลายชิ้นที่นำเข้ามาด้วยวิธีดังกล่าว กลับต้องขาดใจตายอย่างเงียบเชียบ 
ภายใต้ "ระดับการบริหารที่มากมายมหาศาล" 
ที่ผู้เขียนเอกสารวันฮัลโลวีนสรรเสริญยิ่งนัก</para>

<para>That, however, is a negative point.  The reader would be better served
by a positive one.  I suggest, as an experiment, the following:</para>

<para>อย่างไรก็ดี นั่นเป็นประเด็นเชิงลบ ผู้อ่านควรได้รับประเด็นเชิงบวกบ้าง 
ผมขอแนะนำให้ทดลองดังนี้:</para>

<itemizedlist>
<listitem><para> Pick a criterion for originality that you believe you
       can apply consistently.  If your definition is ``I know it when
       I see it'', that's not a problem for purposes of this
       test.</para></listitem>

<listitem><para>
       เลือกเกณฑ์สำหรับวัดจำนวนการคิดค้นที่คุณเชื่อว่าสามารถใช้ได้อย่างสม่ำเสมอ 
       ถ้านิยามของคุณคือ ``ฉันรู้เมื่อได้เห็นก็แล้วกัน'' 
       นั่นก็ไม่ใช่ปัญหาสำหรับการทดลองนี้</para></listitem>

<listitem><para>Pick any closed-source operating system competing with Linux,
       and a best source for accounts of current development work on
       it.</para></listitem>

<listitem><para>เลือกระบบปฏิบัติการซอร์สปิดตัวไหนก็ได้ที่แข่งกับลินุกซ์ 
       พร้อมทั้งแหล่งสำหรับตรวจสอบงานพัฒนาปัจจุบัน</para></listitem>

<listitem><para>Watch that source and Freshmeat for one month.  Every
       day, count the number of release announcements on Freshmeat
       that you consider `original' work.  Apply the same definition
       of `original' to announcements for that other OS and count
       them.</para></listitem>

<listitem><para>เฝ้าดูแหล่งดังกล่าวและ Freshmeat ทุกวันเป็นเวลาหนึ่งเดือน 
       นับจำนวนการประกาศออกรุ่นที่ Freshmeat ที่คุณถือว่าเป็นงาน `คิดค้น' 
       และใช้เกณฑ์เดียวกันของงาน `คิดค้น' 
       นี้กับการประกาศของระบบปฏิบัติการอีกตัวนั้น แล้วนับดู</para></listitem>

<listitem><para>Thirty days later, total up both figures.</para></listitem>

<listitem><para>สามสิบวันให้หลัง รวมคะแนนทั้งสองฝ่าย</para></listitem>
</itemizedlist>

<para>The day I wrote this, Freshmeat carried twenty-two release
announcements, of which three appear they might push state of the art
in some respect, This was a slow day for Freshmeat, but I will be
astonished if any reader reports as many as three likely innovations
<emphasis>a month</emphasis> in any closed-source channel.</para>

<para>ในวันที่ผมเขียนตรงนี้ Freshmeat มีประกาศออกรุ่นยี่สิบสองรายการ 
ซึ่งมีสามรายการที่อาจเป็นสิ่งใหม่ล่าสุดในระดับหนึ่ง 
นี่ยังถือเป็นวันที่เชื่องช้าสำหรับ Freshmeat 
แต่ผมจะตกใจมากถ้ามีผู้อ่านท่านใดรายงานว่า มีสิ่งที่อาจเป็นนวัตกรรมถึงสามรายการ 
<emphasis>ต่อเดือน</emphasis> ในแหล่งซอร์สปิดแหล่งไหน</para>

<para><emphasis><anchor id="_EGCS"/>[EGCS]</emphasis> We now have
history on a project that, in several ways, may provide a more
indicative test of the bazaar premise than fetchmail; <ulink
url="http://egcs.cygnus.com/">EGCS</ulink>, the Experimental GNU
Compiler System.</para>

<para><emphasis><anchor id="EGCS"/>[EGCS]</emphasis> ขณะนี้ 
เรามีประวัติศาสตร์ของโครงการที่อาจเป็นการทดสอบที่ชี้วัดศักยภาพของรูปแบบตลาดสดได้ดีกว่า 
fetchmail ในหลายๆ ทาง คือ <ulink url="http://egcs.cygnus.com/">EGCS</ulink> 
(Experimental GNU Compiler System)</para>

<para>This project was announced in mid-August of 1997 as a conscious
attempt to apply the ideas in the early public versions of
<citetitle>The Cathedral and the Bazaar</citetitle>. The project
founders felt that the development of GCC, the Gnu C Compiler, had
been stagnating.  For about twenty months afterwards, GCC and EGCS
continued as parallel products&mdash;both drawing from the same
Internet developer population, both starting from the same GCC source
base, both using pretty much the same Unix toolsets and development
environment.  The projects differed only in that EGCS consciously
tried to apply the bazaar tactics I have previously described, while
GCC retained a more cathedral-like organization with a closed
developer group and infrequent releases.</para>

<para>โครงการนี้ประกาศตัวเมื่อกลางเดือนสิงหาคม 1997 โดยเป็นความพยายามอย่างจงใจ 
ที่จะใช้แนวคิดจากบทความ <citetitle>มหาวิหารกับตลาดสด</citetitle> 
ที่เผยแพร่รุ่นแรก ผู้ก่อตั้งโครงการรู้สึกว่า การพัฒนาของ GCC หรือ GNU C 
Compiler กำลังติดขัด เป็นเวลายี่สิบเดือนตั้งแต่นั้น ที่ GCC และ EGCS 
กลายเป็นผลิตภัณฑ์ที่คู่ขนานกัน 
โดยดึงแรงงานจากนักพัฒนาในอินเทอร์เน็ตกลุ่มเดียวกัน เริ่มต้นจากซอร์สของ GCC 
เดียวกัน ใช้ชุดเครื่องมือและสภาพแวดล้อมการพัฒนาของยูนิกซ์เหมือนกัน 
แต่ต่างกันตรงที่ EGCS พยายามใช้เทคนิคของตลาดสดที่ผมได้บรรยายไปแล้ว ในขณะที่ GCC 
ยังคงใช้โครงสร้างการทำงานที่คล้ายมหาวิหารมากกว่า และทำโดยกลุ่มนักพัฒนาที่ปิด 
และออกรุ่นไม่บ่อย</para>

<para>This was about as close to a controlled experiment as one could ask
for, and the results were dramatic.  Within months, the EGCS versions
had pulled substantially ahead in features; better optimization,
better support for FORTRAN and C++.  Many people found the EGCS 
development snapshots to be more reliable than the most recent
stable version of GCC, and major Linux distributions began to
switch to EGCS.</para>

<para>นี่ถือว่าใกล้เคียงกับการทดลองที่ควบคุมตัวแปรมากที่สุดเท่าที่จะทำได้ 
และผลลัพธ์ก็เห็นได้อย่างรวดเร็ว ภายในไม่กี่เดือน EGCS 
ได้พัฒนาความสามารถไปไกลกว่าอย่างเห็นได้ชัด ทั้งออปติไมซ์ได้ดีกว่า 
และสนับสนุนภาษาฟอร์แทรนและซีพลัสพลัสได้ดีกว่า หลายคนพบว่า EGCS 
รุ่นระหว่างพัฒนายังเชื่อถือได้กว่ารุ่นเสถียรล่าสุดของ GCC เสียอีก 
และดิสทริบิวชันลินุกซ์ต่างๆ ก็เริ่มจะเปลี่ยนมาใช้ EGCS แทน</para>

<para>In April of 1999, the Free Software Foundation (the official
sponsors of GCC) dissolved the original GCC development group and
officially handed control of the project to the the EGCS steering
team.</para>

<para>ในเดือนเมษายน 1999 มูลนิธิซอฟต์แวร์เสรี (ผู้สนับสนุนอย่างเป็นทางการของ 
GCC) ได้ยุบกลุ่มพัฒนา GCC เดิมเสีย แล้วโอนการควบคุมของโครงการไปให้ทีมหลักของ 
EGCS แทน</para>

<para><emphasis><anchor id="_SP"/>[SP]</emphasis> Of course,
Kropotkin's critique and Linus's Law raise some wider issues about the
cybernetics of social organizations.  Another folk theorem of software
engineering suggests one of them; Conway's Law&mdash;commonly stated as
``If you have four groups working on a compiler, you'll get a 4-pass
compiler''.  The original statement was more general: ``Organizations
which design systems are constrained to produce designs which are
copies of the communication structures of these organizations.''  We
might put it more succinctly as ``The means determine the ends'', or
even ``Process becomes product''.</para>

<para><emphasis><anchor id="SP"/>[SP]</emphasis> แน่นอน 
คำวิจารณ์ของโครพอตกินและกฎของไลนัส ได้สร้างประเด็นกว้างๆ 
เกี่ยวกับกลไกไซเบอร์สำหรับจัดโครงสร้างสังคม 
ทฤษฎีชาวบ้านอีกทฤษฎีหนึ่งของวิศวกรรมซอฟต์แวร์ ก็ได้ชี้ให้เห็นอีกประเด็นหนึ่ง 
คือกฎของคอนเวย์ ซึ่งกล่าวกันโดยทั่วไปว่า 
``ถ้าคุณมีทีมงานสี่ทีมร่วมกันทำคอมไพเลอร์ คุณก็จะได้คอมไพเลอร์ที่ทำงานสี่ขั้น'' 
ข้อความดั้งเดิมอยู่ในรูปทั่วไปกว่านั้น: ``องค์กรต่างๆ ที่ออกแบบระบบ 
จะถูกบังคับให้สร้างระบบที่สะท้อนโครงสร้างการสื่อสารขององค์กรเหล่านั้น'' 
เราอาจกล่าวอย่างย่นย่อกว่านั้นได้ว่า ``วิธีการจะกำหนดผลลัพธ์'' หรือแม้แต่ว่า 
``กระบวนการจะกลายเป็นผลิตภัณฑ์''</para>

<para>It is accordingly worth noting that in the open-source community
organizational form and function match on many levels. The network is
everything and everywhere: not just the Internet, but the people doing
the work form a distributed, loosely coupled, peer-to-peer network
that provides multiple redundancy and degrades very gracefully.
In both networks, each node is important only to the extent that other
nodes want to cooperate with it.</para>

<para>น่าสังเกตพอๆ กัน ว่าในชุมชนโอเพนซอร์สนั้น 
รูปแบบโครงสร้างชุมชนก็ตรงกับหน้าที่ที่ทำในหลายระดับ 
เครือข่ายนี้ครอบคลุมทุกอย่างและทุกที่ ไม่ใช่แค่อินเทอร์เน็ต 
แต่ผู้คนที่ทำงานยังได้สร้างเครือข่ายแบบกระจาย ขึ้นต่อกันอย่างหลวมๆ 
ในระดับเดียวกัน ที่มีส่วนที่ทดแทนกันได้เกิดขึ้นกลายส่วน 
และไม่ล้มครืนลงแบบทันทีทันใด ในเครือข่ายทั้งสอง 
แต่ละกลุ่มจะมีความสำคัญแค่ในระดับที่กลุ่มอื่นต้องการจะร่วมมือด้วยเท่านั้น</para>

<para>The peer-to-peer part is essential to the community's astonishing
productivity. The point Kropotkin was trying to make about power
relationships is developed further by the `SNAFU Principle': ``True
communication is possible only between equals, because inferiors are
more consistently rewarded for telling their superiors pleasant lies
than for telling the truth.''  Creative teamwork utterly depends on
true communication and is thus very seriously hindered by the presence
of power relationships.  The open-source community, effectively free
of such power relationships, is teaching us by contrast how dreadfully
much they cost in bugs, in lowered productivity, and in lost
opportunities.</para>

<para>ตรงส่วน ``ในระดับเดียวกัน'' นี้ สำคัญมากสำหรับผลิตภาพอันน่าทึ่งของชุมชน 
ประเด็นที่โครพอตกินพยายามจะชี้เกี่ยวกับความสัมพันธ์เชิงอำนาจ 
ได้ถูกพัฒนาต่อไปโดย `หลัก SNAFU' ที่ว่า ``การสื่อสารที่แท้จริง 
จะเกิดได้ระหว่างคนที่เท่าเทียมกันเท่านั้น 
เพราะผู้ที่ด้อยกว่าจะได้รับการตอบแทนอย่างสม่ำเสมอกว่า 
ถ้าพูดโกหกให้ผู้ที่เหนือกว่าพอใจ เทียบกับการพูดความจริง'' 
ทีมงานที่สร้างสรรค์จะขึ้นอยู่กับการสื่อสารอย่างแท้จริง 
และจะถูกขัดขวางอย่างมากจากการมีความสัมพันธ์เชิงอำนาจ ชุมชนโอเพนซอร์ส 
ซึ่งปราศจากความสัมพันธ์เชิงอำนาจดังกล่าว จึงได้สอนเราในทางตรงกันข้าม 
ให้รู้ถึงข้อเสียของความสัมพันธ์ดังกล่าวในรูปของบั๊ก ผลิตภาพที่ถดถอย 
และโอกาสที่สูญเสียไป</para>

<para>Further, the SNAFU principle predicts in authoritarian organizations 
a progressive disconnect between decision-makers and reality, as more
and more of the input to those who decide tends to become pleasant
lies.  The way this plays out in conventional software development
is easy to see; there are strong incentives for the inferiors to
hide, ignore, and minimize problems.  When this process becomes
product, software is a disaster.</para>

<para>นอกจากนี้ หลัก SNAFU ยังได้ทำนายว่า ในองค์กรที่มีอำนาจหน้าที่นั้น 
จะเกิดการตัดขาดระหว่างผู้มีอำนาจตัดสินใจ กับความเป็นจริง 
เพราะข้อมูลที่ผู้มีอำนาจตัดสินใจจะได้รับ มักมีแนวโน้มจะเป็นการโกหกให้พอใจ 
การเกิดเหตุการณ์เช่นนี้ในการพัฒนาซอฟต์แวร์แบบเดิม ก็เข้าใจได้ง่าย 
เนื่องจากมีแรงจูงใจอย่างแรงกล้าสำหรับผู้ที่ด้อยกว่า ที่จะซ่อน เพิกเฉย 
และลดปัญหาลง เมื่อกระบวนการนี้กลายมาเป็นผลิตภัณฑ์ 
ซอฟต์แวร์ก็กลายเป็นหายนะ</para>
</sect1>
<!-- Bibliography -->
<sect1><title>บรรณานุกรม</title>

<para>I quoted several bits from Frederick P. Brooks's classic
<citetitle>The Mythical Man-Month</citetitle> because, in many
respects, his insights have yet to be improved upon.  I heartily
recommend the 25th Anniversary edition from Addison-Wesley (ISBN
0-201-83595-9), which adds his 1986 ``No Silver Bullet'' paper.</para>

<para>ผมยกคำพูดหลายแห่งมาจากหนังสืออมตะของ เฟรดเดอริก พี. บรูกส์ ชื่อ 
<citetitle>The Mythical Man-Month</citetitle> 
เพราะแนวคิดของเขายังต้องการการพิสูจน์ต่อไปในหลายๆ เรื่อง ผมขอแนะนำอย่างยิ่ง 
ให้อ่านฉบับครบรอบ 25 ปีจาก Addison-Wesley (ISBN 0-201-83595-9) 
ซึ่งเพิ่มบทความ ``No Silver Bullet'' (ไม่มียาครอบจักรวาล) ปี 1986 ของเขา</para>

<para>The new edition is wrapped up by an invaluable 20-years-later
retrospective in which Brooks forthrightly admits to the few
judgements in the original text which have not stood the test of time.
I first read the retrospective after the first public version of this
essay was substantially complete, and was surprised to discover that
Brooks attributed bazaar-like practices to Microsoft! (In fact,
however, this attribution turned out to be mistaken. In 1998 we
learned from the <ulink
url="http://www.opensource.org/halloween/">Halloween Documents</ulink>
that Microsoft's internal developer community is heavily balkanized,
with the kind of general source access needed to support a bazaar not
even truly possible.)</para>

<para>ฉบับปรับปรุงแก้ไขใหม่นี้ ยังปิดท้ายด้วยการหวนรำลึกเมื่อผ่านไป 20 ปี 
อันเป็นบทที่ประเมินค่าไม่ได้ ในบทดังกล่าว 
บรูกส์ยอมรับอย่างจริงใจเกี่ยวกับการตัดสินเล็กน้อยในเนื้อหาดั้งเดิมซึ่งไม่ผ่านการทดสอบของห้วงเวลา 
ผมอ่านบทหวนรำลึกนี้ครั้งแรกหลังจากที่รุ่นแรกของบทความนี้เสร็จไปเยอะแล้ว 
และต้องประหลาดใจที่ได้พบว่า 
บรูกส์ได้ถือว่ากระบวนการที่คล้ายตลาดสดเป็นผลมาจากไมโครซอฟท์! (อย่างไรก็ตาม 
ความจริงแล้ว การผูกโยงดังกล่าวกลายเป็นความผิดพลาด ในปี 1998 เราได้รู้จาก <ulink 
url="http://www.opensource.org/halloween/">เอกสารวันฮัลโลวีน</ulink> 
ว่าชุมชนนักพัฒนาภายในของไมโครซอฟท์นั้น แบ่งเป็นก๊กเป็นเหล่ามากมาย 
ซึ่งการเข้าถึงซอร์สโดยทั่วไปที่จำเป็นสำหรับการทำงานแบบตลาดสดนั้น 
ยังเป็นไปไม่ได้เลย)</para>

<para>Gerald M. Weinberg's <citetitle>The Psychology Of Computer
Programming</citetitle> (New York, Van Nostrand Reinhold 1971)
introduced the rather unfortunately-labeled concept of ``egoless
programming''.  While he was nowhere near the first person to realize
the futility of the ``principle of command'', he was probably the
first to recognize and argue the point in particular connection with
software development.</para>

<para>หนังสือของ เจอรัลด์ เอ็ม. เวนเบิร์ก ชื่อ <citetitle>The Psychology Of 
Computer Programming (จิตวิทยาของการเขียนโปรแกรมคอมพิวเตอร์)</citetitle> 
(New York, Van Nostrand Reinhold 1971) 
ได้เสนอแนวคิดที่ออกจะโชคร้ายที่ได้ชื่อว่า ``การเขียนโปรแกรมแบบไร้อัตตา'' 
ถึงแม้เขาจะไม่มีวี่แววว่าจะเป็นคนแรกที่ตระหนักถึงความสูญเปล่าของ 
``หลักแห่งการบังคับบัญชา'' แต่เขาก็อาจเป็นคนแรกที่มองเห็นและโต้ประเด็นนี้ 
โดยเชื่อมโยงกับการพัฒนาซอฟต์แวร์โดยเฉพาะ</para>

<para>Richard P. Gabriel, contemplating the Unix culture of the
pre-Linux era, reluctantly argued for the superiority of a primitive
bazaar-like model in his 1989 paper ``LISP: Good News, Bad News, and
How To Win Big''.  Though dated in some respects, this essay is still
rightly celebrated among LISP fans (including me).  A correspondent
reminded me that the section titled ``Worse Is Better'' reads almost
as an anticipation of Linux.  The paper is accessible on the World
Wide Web at <ulink
url="http://www.naggum.no/worse-is-better.html">http://www.naggum.no/worse-is-better.html</ulink>.</para>

<para>ริชาร์ด พี. เกเบรียล 
ซึ่งได้ตรึกตรองเกี่ยวกับวัฒนธรรมยูนิกซ์ก่อนยุคลินุกซ์ ได้โต้แย้งอย่างลังเล 
ถึงข้อได้เปรียบของรูปแบบคล้ายตลาดสดในบทความปี 1989 ชื่อ ``LISP: Good News, Bad 
News, and How To Win Big'' (LISP: ข่าวดี, ข่าวร้าย, และวิธีชนะอย่างยิ่งใหญ่'') 
ของเขา แม้จะเก่าแล้วในบางเรื่อง แต่บทความนี้ก็ยังเป็นที่ยกย่องในหมู่แฟนๆ ภาษา 
LISP (รวมถึงผมด้วย) ผู้ร่วมแสดงความเห็นท่านหนึ่งเตือนผมว่า ตอนที่ชื่อ ``Worse 
Is Better'' (แย่กว่าดีกว่า) แทบจะเป็นการเก็งการเกิดของลินุกซ์ทีเดียว 
บทความดังกล่าวสามารถอ่านในเว็บได้ที่ <ulink 
url="http://www.naggum.no/worse-is-better.html">http://www.naggum.no/worse-is-better.html</ulink></para>

<para>De Marco and Lister's <citetitle>Peopleware: Productive Projects
and Teams</citetitle> (New York; Dorset House, 1987; ISBN
0-932633-05-6) is an underappreciated gem which I was delighted to see
Fred Brooks cite in his retrospective.  While little of what the
authors have to say is directly applicable to the Linux or open-source
communities, the authors' insight into the conditions necessary for
creative work is acute and worthwhile for anyone attempting to import
some of the bazaar model's virtues into a commercial context.</para>

<para>หนังสือของ เดอ มาร์โค และ ลิสเตอร์ ชื่อ <citetitle>Peopleware: 
Productive Projects and Teams (พีเพิลแวร์: 
โครงการและทีมงานอุดมผลงาน)</citetitle> 
(New York; Dorset House, 1987; ISBN 0-932633-05-6) 
เป็นอัญมณีมีค่าที่ได้รับความชื่นชมน้อยกว่าที่ควร ซึ่งผมยินดีที่ได้เห็น เฟรด 
บรูกส์ อ้างถึงในบทหวนรำลึกของเขา 
แม้สิ่งที่ผู้เขียนกล่าวถึงจะเกี่ยวข้องโดยตรงกับชุมชนลินุกซ์หรือโอเพนซอร์สน้อยมาก 
แต่แนวคิดของผู้เขียนเกี่ยวกับเงื่อนไขที่จำเป็นสำหรับงานสร้างสรรค์ 
ก็เป็นสิ่งที่เฉียบแหลม 
และคุ้มค่าสำหรับใครก็ตามที่พยายามจะนำข้อดีของรูปแบบตลาดสดไปใช้ในบริบทเชิงพาณิชย์
</para>

<para>Finally, I must admit that I very nearly called this essay ``The
Cathedral and the Agora'', the latter term being the Greek for an open
market or public meeting place.  The seminal ``agoric systems'' papers
by Mark Miller and Eric Drexler, by describing the emergent properties
of market-like computational ecologies, helped prepare me to think
clearly about analogous phenomena in the open-source culture when
Linux rubbed my nose in them five years later.  These papers are
available on the Web at <ulink
url="http://www.agorics.com/agorpapers.html">http://www.agorics.com/agorpapers.html</ulink>.</para>

<para>ท้ายที่สุด ผมต้องยอมรับว่า ผมเกือบจะเรียกบทความนี้ว่า ``The Cathedral and 
the Agora'' จริงๆ โดยคำว่า agora นี้ เป็นภาษากรีก ใช้เรียกตลาดเปิดโล่ง 
หรือที่ประชุมสาธารณะ บทความสัมมนาชื่อ ``agoric systems'' ของ มาร์ค มิลเลอร์ และ 
เอริก เดร็กซ์เลอร์ 
ซึ่งได้บรรยายคุณสมบัติที่อุบัติขึ้นของระบบนิเวศน์คอมพิวเตอร์ที่คล้ายตลาด 
ได้ช่วยให้ผมเตรียมพร้อมสำหรับการคิดอย่างชัดเจน 
เกี่ยวกับปรากฏการณ์เทียบเคียงในวัฒนธรรมโอเพนซอร์ส 
เมื่อลินุกซ์มากระตุ้นเตือนผมในห้าปีต่อมา บทความนี้อ่านได้บนเว็บที่ <ulink
url="http://www.agorics.com/agorpapers.html">http://www.agorics.com/agorpapers.html</ulink></para>

</sect1>
<!-- Acknowledgements -->
<sect1><title>กิติกรรมประกาศ</title>

<para>This essay was improved by conversations with a large number of
people who helped debug it. Particular thanks to Jeff Dutky
<email>dutky@wam.umd.edu</email>, who suggested the ``debugging is
parallelizable'' formulation, and helped develop the analysis that
proceeds from it.  Also to Nancy Lebovitz
<email>nancyl@universe.digex.net</email> for her suggestion that I emulate
Weinberg by quoting Kropotkin.  Perceptive criticisms also came from
Joan Eslinger <email>wombat@kilimanjaro.engr.sgi.com</email> and Marty Franz
<email>marty@net-link.net</email> of the General Technics list.  Glen
Vandenburg <email>glv@vanderburg.org</email> pointeed out the importance of
self-selection in contributor populations and suggested the fruitful
idea that much development rectifies `bugs of omission'; Daniel Upper
<email>upper@peak.org</email> suggested the natural analogies for this.  I'm
grateful to the members of PLUG, the Philadelphia Linux User's group,
for providing the first test audience for the first public version of
this essay.  Paula Matuszek <email>matusp00@mh.us.sbphrd.com</email>
enlightened me about the practice of software management.  Phil Hudson
<email>phil.hudson@iname.com</email> reminded me that the social organization
of the hacker culture mirrors the organization of its software, and
vice-versa. John Buck <email>johnbuck@sea.ece.umassd.edu</email> pointed out
that MATLAB makes an instructive parallel to Emacs.  Russell Johnston
<email>russjj@mail.com</email> brought me to consciousness about some of the
mechanisms discussed in ``How Many Eyeballs Tame Complexity.''
Finally, Linus Torvalds's comments were helpful and his early
endorsement very encouraging.</para>

<para>บทความนี้ได้รับการปรับปรุงด้วยการสนทนากับผู้คนจำนวนมากที่ช่วยตรวจทาน 
ขอขอบคุณ Jeff Dutky <email>dutky@wam.umd.edu</email> ซึ่งได้แนะนำคำสรุปที่ว่า 
``การแก้บั๊กสามารถทำขนานกันได้'' และได้ช่วยวิเคราะห์ตามคำสรุปดังกล่าวด้วย 
ขอบคุณ Nancy Lebovitz <email>nancyl@universe.digex.net</email> สำหรับคำแนะนำว่า 
ผมได้เลียนแบบเวนเบิร์กด้วยการอ้างคำพูดของโครพอตกิน มีคำวิจารณ์ที่ลึกซึ้งจาก 
Joan Eslinger <email>wombat@kilimanjaro.engr.sgi.com</email> และ Marty Franz
<email>marty@net-link.net</email> จากเมลลิ่งลิสต์ General Technics 
นอกจากนี้ Glen Vandenburg <email>glv@vanderburg.org</email> 
ยังได้ชี้ให้เห็นถึงความสำคัญของการกลั่นกรองตัวเองของประชากรผู้สมทบ 
และแนะนำแนวคิดที่ช่วยให้เกิดผลอย่างมาก ว่างานพัฒนาปริมาณมากถือว่าเป็นการแก้ 
`บั๊กเนื่องจากสิ่งที่ขาดไป' Daniel Upper <email>upper@peak.org</email> 
ได้แนะนำการเปรียบเทียบกับธรรมชาติของสิ่งนี้ ผมรู้สึกขอบคุณต่อสมาชิกของ PLUG 
หรือ Philadelphia Linux User's Group 
ที่ได้หาผู้ทดลองอ่านชุดแรกสำหรับบทความรุ่นแรก Paula Matuszek 
<email>matusp00@mh.us.sbphrd.com</email>
ได้ให้ความกระจ่างแก่ผมเกี่ยวกับวิธีการบริหารงานซอฟต์แวร์ 
Phil Hudson <email>phil.hudson@iname.com</email> เตือนผมว่า 
การจัดโครงสร้างของวัฒนธรรมแฮ็กเกอร์ จะสะท้อนโครงสร้างของซอฟต์แวร์ 
และในทางกลับกันก็เป็นจริงด้วย John Buck 
<email>johnbuck@sea.ece.umassd.edu</email> ชี้ว่า MATLAB 
ก็ให้ตัวอย่างที่เหมือนกับ Emacs และ Russell Johnston 
<email>russjj@mail.com</email> 
ทำให้ผมได้สติเกี่ยวกับกลไกบางอย่างที่อภิปรายในหัวข้อ 
``ลูกตาเยอะขนาดไปนที่จะจัดการกับความซับซ้อนได้'' และท้ายที่สุด ความเห็นของ 
ไลนัส ทอร์วัลด์ เป็นประโยชน์มาก และการให้ความเห็นชอบของเขาตั้งแต่เนิ่นๆ นั้น 
ช่วยเป็นกำลังใจได้มาก</para>

</sect1>
<!-- %%END ENDNOTES%% -->
</article>
